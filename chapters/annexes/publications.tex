\Annex{Liste des publications}

Notre travail sur RenamableLogootSplit \cf{chap:renamablelogootsplit}, \ie la proposition d'un mécanisme ne nécessitant aucune coordination synchrone pour réduire le surcoût des \acp{CRDT} pour le type Séquence, a donné lieu à des publications à différents stades de son avancement :
\begin{enumerate}
    \item Dans \cite{2018-rls-middleware-nicolas}, nous motivons le problème identifié et présentons l'idée de RenamableLogootSplit, un \ac{CRDT} pour le type Séquence incorporant un mécanisme de renommage.
    \item Dans \cite{2020-rls-papoc-nicolas}, nous détaillons une première version de RenamableLogootSplit et son mécanisme de renommage.
        Nous présentons dans cette version le mécanisme de résolution de conflits automatique conçu pour intégrer les opérations $\trm{ins}$ et $\trm{rmv}$ concurrentes aux opérations $\trm{ren}$, et inversement.
        Nous présentons aussi dans ce travail notre protocole d'évaluation expérimentale ainsi que ses premiers résultats concernant l'impact du mécanisme de renommage sur le surcoût en métadonnées et en calculs du \ac{CRDT}.
    \item Dans \cite{2022-rls-tpds-nicolas}, nous détaillons RenamableLogootSplit dans son entièreté.
        Ainsi, nous présentons les mécanismes additionnels pour :
        \begin{enumerate}
            \item Intégrer les opérations $\trm{ren}$ concurrentes.
            \item Supprimer à terme les métadonnées introduites par le mécanisme de renommage.
        \end{enumerate}
        Nous accompagnons cette proposition d'une évaluation expérimentale plus poussée, prenant en compte des scénarios avec des opérations $\trm{ren}$ concurrentes et mesurant de nouvelles métriques telles que le temps nécessaire pour rejouer le journal des opérations d'une collaboration.
        Finalement, nous complétons notre travail d'une discussion identifiant plusieurs des limites de RenamableLogootSplit et présentant des pistes possibles pour y répondre.
\end{enumerate}
Nous précisons ci-dessous les informations relatives à chacun de ces articles.

\subsection*{Efficient renaming in CRDTs \cite{2018-rls-middleware-nicolas}}

\paragraph{Auteur} Matthieu Nicolas

\paragraph{Article de position} à Middleware 2018 - 19th ACM/IFIP International Middleware Conference (Doctoral Symposium), Dec 2018, Rennes, France.

\paragraph{Résumé}
\emph{Sequence Conflict-free Replicated Data Types (CRDTs)} allow to replicate and edit, without any kind of coordination, sequences in distributed systems.
To ensure convergence, existing works from the literature add metadata to each element but they do not bound its footprint, which impedes their adoption.
Several approaches were proposed to address this issue but they do not fit a fully distributed setting.
In this paper, we present our ongoing work on the design and validation of a fully distributed renaming mechanism, setting a bound to the metadata's footprint.
Addressing this issue opens new perspectives of adoption of these CRDTs in distributed applications.

\subsection*{Efficient Renaming in Sequence CRDTs \cite{2020-rls-papoc-nicolas}}

\paragraph{Auteurs} Matthieu Nicolas, Gérald Oster, Olivier Perrin

\paragraph{Article d'atelier} à PaPoC 2020 - 7th Workshop on Principles and Practice of Consistency for Distributed Data, Apr 2020, Heraklion / Virtual, Greece.

\paragraph{Résumé}
To achieve high availability, large-scale distributed systems have to replicate data and to minimise coordination between nodes.
Literature and industry increasingly adopt \acfp{CRDT} to design such systems.
\acp{CRDT} are data types which behave as traditional ones, e.g. the Set or the Sequence.
However, unlike traditional data types, they are designed to natively support concurrent modifications.
To this end, they embed in their specification a conflict-resolution mechanism.

To resolve conflicts in a deterministic manner, \acp{CRDT} usually attach identifiers to elements stored in the data structure.
Identifiers have to comply with several constraints, such as uniqueness or belonging to a dense order.
These constraints may hinder the identifiers' size from being bounded.
As the system progresses, identifiers tend to grow.
This inflation deepens the overhead of the \ac{CRDT} over time, leading to performance issues.

To address this issue, we propose a new CRDT for Sequence which embeds a renaming mechanism.
It enables nodes to reassign shorter identifiers to elements in an uncoordinated manner.
Experimental results demonstrate that this mechanism decreases the overhead of the replicated data structure and eventually limits it.

\subsection*{Efficient Renaming in Sequence CRDTs \cite{2022-rls-tpds-nicolas}}

\paragraph{Auteurs} Matthieu Nicolas, Gérald Oster, Olivier Perrin

\paragraph{Article de revue} dans IEEE Transactions on Parallel and Distributed Systems, Institute of Electrical and Electronics Engineers, 2022, 33 (12), pp.3870-3885.

\paragraph{Résumé}
To achieve high availability, large-scale distributed systems have to replicate data and to minimise coordination between nodes.
For these purposes, literature and industry increasingly adopt \acfp{CRDT} to design such systems.
\acp{CRDT} are new specifications of existing data types, e.g. Set or Sequence.
While \acp{CRDT} have the same behaviour as previous specifications in sequential executions, they actually shine in distributed settings as they natively support concurrent updates.
To this end, \acp{CRDT} embed in their specification conflict resolution mechanisms.
These mechanisms usually rely on identifiers attached to elements of the data structure to resolve conflicts in a deterministic and coordination-free manner.
Identifiers have to comply with several constraints, such as being unique or belonging to a dense total order.
These constraints may hinder the identifier size from being bounded.
Identifiers hence tend to grow as the system progresses, which increases the overhead of \acp{CRDT} over time and leads to performance issues.
To address this issue, we propose a novel Sequence \ac{CRDT} which embeds a renaming mechanism.
It enables nodes to reassign shorter identifiers to elements in an uncoordinated manner.
Experimental results demonstrate that this mechanism decreases the overhead of the replicated data structure and eventually minimises it.
