\label{sec:renamablelogootsplit-delivery-model}

L'introduction de l'opération \emph{rename} nécessite de faire évoluer le modèle de livraison des opérations associé à RenamableLogootSplit.
Afin d'illustrer cette nécessité, considérons l'exemple suivant :

\begin{figure}[!ht]
  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
        \newcommand\nodew[1]{
            node[letter, label=#1:{$\betterid{i}{B0}{0}$}] {W}
        }
        \newcommand\nodeo[1]{
            node[letter, label=#1:{$\betterid{l}{C0}{0}$}] {O}
        }
        \newcommand\nodel[1]{
            node[letter, label=#1:{$\betterid{t}{A0}{0}$}] {L}
        }
        \newcommand\noded[1]{
            node[letter, label=#1:{$\betterid{y}{D0}{0}$}] {D}
        }
        \newcommand\renwold[1]{
            node[block, label=#1:{$\betterid{i}{A1}{0..3}$}] {WOLD}
        }
        \newcommand\renwo[1]{
            node[block, label=#1:{$\betterid{i}{A1}{0..1}$}] {WO}
        }
        \newcommand\renr[1]{
            node[letter, label=#1:{$\betterid{i}{A1}{1}\betterid{f}{A2}{0}$}] {R}
        }
        \newcommand\renld[1]{
            node[block, label=#1:{$\betterid{i}{A1}{2..3}$}] {LD}
        }

        \newcommand\initialstate[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{0}}
                ++(0:1.05 * \widthoriginepoch) \nodew{-#3}
                ++(0:\widthletter) \nodeo{-#3}
                ++(0:\widthletter) \nodel{-#3}
                ++(0:\widthletter) \noded{-#3};
        }

        \newcommand\ren[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{A1}}
                ++(0:1.3 * \widthepoch) \renwold{-#3};
        }

        \newcommand\finalstate[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{A1}}
                ++(0:1.3 * \widthepoch) \renwo{-#3}
                ++(0:\widthblock) \renr{#3}
                ++(0:\widthletter) \renld{-#3};
        }

        \newcommand\offseta{ (90:0.7) }
        \newcommand\offsetb{ (-90:0.7) }

        \path
            node {\textbf{A}}
            ++(0:0.5) node (a) {}
            +(0:24) node (a-end) {}
            +(0:2) node[point] (a-initial) {}
            +(0:8) node[point, label=-170:{$\trm{ren}()$}, label={[xshift=20pt]-10:{$\trm{ren(\betterepoch{0}, A,1)}$}}] (a-ren-a1) {}
            +(0:16) node[point, label=-170:{$\trm{ins}(O \prec R \prec L)$}, label={[xshift=20pt]-10:{$\trm{ins}(\betterepoch{A1}, \betterid{i}{A1}{1}\betterid{f}{A2}{0},R)$}}] (a-ins-r) {}
            +(0:22) node (a-final) {};

        \initialstate{(a-initial)}{\offseta}{90};
        \ren{(a-ren-a1)}{\offseta}{90};
        \finalstate{(a-ins-r)}{\offseta}{90};

        \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
        \draw[->, thick] (a-initial) --  (a-ren-a1) -- (a-ins-r) -- (a-final);

        \path
            ++(270:3) node {\textbf{B}}
            ++(0:0.5) node (b) {}
            +(0:24) node (b-end) {}
            +(0:2) node[point] (b-initial) {}
            +(0:12) node (b-recv-ren-a1) {}
            +(0:20) node[point, label=below right:{$?$}] (b-recv-ins-r) {}
            +(0:22) node (b-final) {};

        \path node[cross] (fail) at ($(a-ren-a1)!0.5!(b-recv-ren-a1)$) {};

        \initialstate{(b-initial)}{\offsetb}{-90};

        \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
        \draw[->, thick] (b-initial) --  (b-recv-ins-r) -- (b-final);

        \draw[->, dashed, shorten >= 1] (a-ren-a1) -- (fail);
        \draw[->, dashed, shorten >= 1] (a-ins-r) -- (b-recv-ins-r);
    \end{tikzpicture}
  }
  \caption{Livraison d'une opération \emph{insert} sans avoir reçu l'opération \emph{rename} précédente}
  \label{fig:rls-invalid-delivery-order}
\end{figure}

Dans la \autoref{fig:rls-invalid-delivery-order}, les noeuds A et B répliquent tous deux une même séquence, contenant les éléments "ABCD".
Tout d'abord, le noeud A procède au renommage de cet état.
Puis il insère un nouvel élément, "X", entre "B" et "C".
Les opérations correspondantes aux actions du noeud A sont diffusées sur le réseau.

Cependant, l'opération \emph{rename} n'est pas livrée au noeud B, par exemple suite à un problème réseau.
L'opération \emph{insert} est quant à elle correctement livrée à ce dernier.
Le noeud B doit alors intégrer dans son état un élément et l'identifiant qui lui est attaché.
Mais cet identifiant est issu d'une époque (\epoch{A1}) différente de son époque actuelle (\epoch{0}) et dont le noeud n'avait pas encore connaissance.
Il convient de s'interroger sur l'état à produire dans cette situation.

Comme nous l'avions déjà illustré par la \autoref{fig:concurrent-insert-rename-inconsistent}, les identifiants d'une époque ne peuvent être comparés qu'aux identifiants de la même époque.
Tenter d'intégrer une opération \emph{insert} ou \emph{remove} provenant d'une époque encore inconnue ne résulterait qu'en un état incohérent et une transgression de l'intention utilisateur \cf{prop:rename-op-intention-preservation}.
Il est donc nécessaire d'empêcher ce scénario de se produire.

Pour cela, nous proposons de faire évoluer le modèle de livraison des opérations de RenamableLogootSplit.
Celui-ci repose sur celui de LogootSplit \cf{def:ls-delivery-model}.
Pour rappel, ce modèle requiert que
\begin{enumerate}
  \item Une opération doit être livrée exactement une fois à chaque noeud.
  \item Les opérations $\trm{ins}$ peuvent être livrées dans un ordre quelconque.
  \item L'opération $\trm{rmv}(\trm{idIntervals})$ ne peut être livrée qu'après la livraison des opération d'insertions des éléments formant les $\trm{idIntervals}$.
\end{enumerate}

Pour prévenir les scénarios tels que celui illustré par la \autoref{fig:rls-invalid-delivery-order} nous y ajoutons la règle suivante : les opérations \emph{rename} doivent être livrées à la structure de données avant les opérations qui ont une dépendance causale vers ces dernières.
Nous obtenons donc le modèle de livraison suivant :

\begin{definition}[Modèle de livraison RenamableLogootSplit]
  \label{def:rls-delivery-model}
  Le modèle de livraison RenamableLogootSplit définit les 4 règles suivantes sur la livraison des opérations :
  \begin{enumerate}
    \item Une opération doit être livrée à l'ensemble des noeuds à terme.
    \item Une opération doit être livrée qu'une seule et unique fois aux noeuds.
    \item Une opération \emph{remove} doit être livrée à un noeud une fois que les opérations \emph{insert} des éléments concernés par la suppression ont été livrées à ce dernier.
    \item Une opération peut être délivrée à un noeud qu'à partir du moment où l'opération \emph{rename} qui a introduit son époque de génération a été délivrée à ce même noeud.
  \end{enumerate}
\end{definition}

Il est cependant intéressant de noter que la livraison de l'opération \emph{rename} ne requiert pas de contraintes supplémentaires.
Notamment, une opération \emph{rename} peut être livrée dans le désordre par rapport aux opérations \emph{insert} et \emph{remove} dont elle dépend causalement.
La \autoref{fig:rls-out-of-order-rename} présente un exemple de ce cas figure.

\begin{figure}[!ht]
  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
      \newcommand\nodew[1]{
          node[letter, label=#1:{$\betterid{i}{B0}{0}$}] {W}
      }
      \newcommand\nodeo[1]{
          node[letter, label=#1:{$\betterid{l}{C0}{0}$}] {O}
      }
      \newcommand\nodel[1]{
          node[letter, label=#1:{$\betterid{t}{A0}{0}$}] {L}
      }
      \newcommand\noded[1]{
          node[letter, label=#1:{$\betterid{y}{D0}{0}$}] {D}
      }
      \newcommand\noder[1]{
          node[letter, label=#1:{$\betterid{m}{A1}{0}$}] {R}
      }
      \newcommand\renworld[1]{
          node[block, label=#1:{$\betterid{i}{A1}{0..3}$}] {WORLD}
      }
      \newcommand\renwo[1]{
          node[block, label=#1:{$\betterid{i}{A1}{0..1}$}] {WO}
      }
      \newcommand\renld[1]{
          node[block, label=#1:{$\betterid{i}{A1}{2..3}$}] {LD}
      }

      \newcommand\initialstate[3]{
          \path
              #1
              ++#2
              ++(0:0.5)
              ++(#3:0.5) node[epoch] {\epoch{0}}
              ++(0:1.05 * \widthoriginepoch) \nodew{-#3}
              ++(0:\widthletter) \nodeo{-#3}
              ++(0:\widthletter) \nodel{-#3}
              ++(0:\widthletter) \noded{-#3};
      }

      \newcommand\insr[3]{
          \path
              #1
              ++#2
              ++(0:0.5)
              ++(#3:0.5) node[epoch] {\epoch{0}}
              ++(0:1.05 * \widthoriginepoch) \nodew{-#3}
              ++(0:\widthletter) \nodeo{-#3}
              ++(0:\widthletter) \noder{-#3}
              ++(0:\widthletter) \nodel{-#3}
              ++(0:\widthletter) \noded{-#3};
      }

      \newcommand\finalstate[3]{
          \path
              #1
              ++#2
              ++(0:0.5)
              ++(#3:0.5) node[epoch] {\epoch{A2}}
              ++(0:1.3 * \widthepoch) \renworld{-#3};
      }

      \newcommand\renwold[3]{
          \path
              #1
              ++#2
              ++(0:0.5)
              ++(#3:0.5) node[epoch] {\epoch{A2}}
              ++(0:1.3 * \widthepoch) \renwo{-#3}
              ++(0:\widthblock) \renld{-#3};
      }

      \newcommand\offseta{ (90:0.7) }
      \newcommand\offsetb{ (-90:0.7) }

      \path
          node {\textbf{A}}
          ++(0:0.5) node (a) {}
          +(0:32) node (a-end) {}
          +(0:2) node[point] (a-initial) {}
          +(0:9) node[point, label=-170:{$\trm{ins}(O \prec R \prec L)$}, label={[xshift=100pt]-10:{$\trm{ins}(\betterepoch{A1}, \betterid{m}{A1}{0})$}}] (a-ins-r) {}
          +(0:18) node[point, label=-170:{$\trm{ren}()$}, label={[xshift=20pt]-10:{$\trm{ren(\betterepoch{0}, A,2)}$}}] (a-ren-a2) {}
          +(0:30) node (a-final) {};

      \initialstate{(a-initial)}{\offseta}{90};
      \insr{(a-ins-r)}{\offseta}{90};
      \finalstate{(a-ren-a2)}{\offseta}{90};

      \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
      \draw[->, thick] (a-initial) --  (a-ins-r) -- (a-ren-a2) -- (a-final);

      \path
          ++(270:3) node {\textbf{B}}
          ++(0:0.5) node (b) {}
          +(0:32) node (b-end) {}
          +(0:2) node[point] (b-initial) {}
          +(0:22) node[point] (b-recv-ren-a2) {}
          +(0:28) node[point] (b-recv-ins-r) {}
          +(0:30) node (b-final) {};

      \initialstate{(b-initial)}{\offsetb}{-90};
      \renwold{(b-recv-ren-a2)}{\offsetb}{-90};
      \finalstate{(b-recv-ins-r)}{\offsetb}{-90};

      \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
      \draw[->, thick] (b-initial) -- (b-recv-ren-a2) -- (b-recv-ins-r) -- (b-final);

      \draw[->, dashed, shorten >= 1] (a-ren-a2) -- (b-recv-ren-a2);
      \draw[->, dashed, shorten >= 1] (a-ins-r) -- (b-recv-ins-r);
    \end{tikzpicture}
  }
  \caption{Livraison désordonnée d'une opération \emph{rename} et de l'opération \emph{insert} qui la précède}
  \label{fig:rls-out-of-order-rename}
\end{figure}

Dans cet exemple, les noeuds A et B répliquent tous deux une même séquence, contenant les éléments "ABCD".
Le noeud A commence par insérer un nouvel élément, "X", entre les éléments "B" et "C".
Puis il procède au renommage de son état.
Les opérations correspondantes aux actions du noeud A sont diffusées sur le réseau.

Cependant, suite à un aléa du réseau, le noeud B reçoit les deux opérations \emph{insert} et \emph{rename} dans le désordre.
L'opération \emph{rename} est donc livrée en première au noeud B.
En utilisant les informations contenues dans l'opération, le noeud B renomme chaque identifiant composant son état.

Ensuite, le noeud B reçoit l'opération \emph{insert}.
Comme l'époque de génération de l'opération \emph{insert} (\epoch{0}) est différente de celle de son état courant (\epoch{A2}), le noeud B utilise \textsc{renameId} pour renommer l'identifiant avant de l'insérer.
\id{m}{A1}{0} faisant partie de l'\emph{ancien état}, le noeud B utilise l'index de cet identifiant dans l'\emph{ancien état} (2) pour calculer son équivalent à l'époque \epoch{A2} (\id{i}{A2}{2}).
Le noeud B insère l'élément "X" avec ce nouvel identifiant et converge alors avec le noeud A, malgré la livraison dans le désordre des opérations.
