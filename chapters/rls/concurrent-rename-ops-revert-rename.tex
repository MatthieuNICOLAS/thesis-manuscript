\label{sec:reverting-rename-ops}

À présent, nous développons le scénario présenté dans la \autoref{fig:conflicting-rename-operations}.
Dans la \autoref{fig:revertRenameId}, le noeud A reçoit l'opération \emph{rename} du noeud B.
Cette opération est concurrente à l'opération \emph{rename} que le noeud A a appliqué précédemment.
D'après la relation \emph{priority} proposée, le noeud A sélectionne l'époque introduite \epoch{B2} comme l'époque cible (\epoch{A1} \lepoch \epoch{B2}).
Mais pour pouvoir renommer son état vers l'époque \epoch{B2}, il doit au préalable faire revenir son état courant de l'époque \epoch{A1} à un état équivalent à l'époque \epoch{0}.
Nous devons définir un mécanisme permettant aux noeuds d'annuler les effets d'une opération \emph{rename} appliquée précédemment.

\begin{figure}[!ht]
  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
        \newcommand\nodeh[1]{
            node[letter, label=#1:{$\betterid{i}{B0}{0}$}] {H}
        }
        \newcommand\nodee[1]{
            node[letter, label=#1:{$\betterid{i}{B0}{0}\betterid{f}{A0}{0}$}] {E}
        }
        \newcommand\nodelo[1]{
            node[block, label=#1:{$\betterid{i}{B0}{1..2}$}] {LO}
        }
        \newcommand\renhelo[1]{
            node[block, label=#1:{$\betterid{i}{A1}{0..3}$}] {HELO}
        }
        \newcommand\nodel[1]{
            node[letter, label=#1:{$\betterid{i}{B0}{0}\betterid{m}{B1}{0}$}] {L}
        }
        \newcommand\renhe[1]{
            node[block, label=#1:{$\betterid{i}{A1}{0..1}$}] {HE}
        }
        \newcommand\renl[1]{
            node[letter, label=#1:{$\betterid{i}{A1}{1}\betterid{i}{B0}{0}\betterid{m}{B1}{0}$}] {L}
        }
        \newcommand\renlo[1]{
            node[block, label=#1:{$\betterid{i}{A1}{2..3}$}] {LO}
        }
        \newcommand\renhello[1]{
            node[block, label=#1:{$\betterid{i}{B2}{0..4}$}] {HELLO}
        }

        \newcommand\initialstate[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{0}}
                ++(0:1.05 * \widthoriginepoch) \nodeh{-#3}
                ++(0:\widthletter) \nodee{#3}
                ++(0:\widthletter) \nodelo{-#3};
        }

        \newcommand\ren[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{A1}}
                ++(0:1.3 * \widthepoch) \renhelo{-#3};
        }

        \newcommand\insl[3]{
            \path
            #1
            ++#2
            ++(0:0.5)
            ++(#3:0.5) node[epoch] {\epoch{0}}
            ++(0:1.05 * \widthoriginepoch) \nodeh{-#3}
            ++(0:\widthletter) \nodee{#3}
            ++(0:\widthletter) \nodel{-#3}
            ++(0:\widthletter) \nodelo{#3};
        }

        \newcommand\recvrenl[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{A1}}
                ++(0:1.3 * \widthepoch) \renhe{-#3}
                ++(0:\widthblock) \renl{#3}
                ++(0:\widthletter) \renlo{-#3};
        }
        \newcommand\finalstatea[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{A1}}
                ++(0:1.3 * \widthepoch) \renhe{-#3}
                ++(0:\widthblock) \renl{#3}
                ++(0:\widthletter) \renlo{-#3}
                ++(0:\widthblock) node (ea1-right) {}
                ++(0:4) node[epoch] (e0-left) {\epoch{0}}
                ++(0:1.05 * \widthoriginepoch) \nodeh{-#3}
                ++(0:\widthletter) \nodee{#3}
                ++(0:\widthletter) \nodel{-#3}
                ++(0:\widthletter) \nodelo{#3}
                ++(0:\widthblock) node (e0-right) {}
                ++(0:4) node[epoch] (eb2-left) {\epoch{B2}}
                ++(0:1.3 * \widthepoch) \renhello{#3};

                \draw[->, loosely dash dot, shorten >= 1] (ea1-right) --  node[above, align=center]{\emph{revert to \epoch{0}}} (e0-left);
                \draw[->, loosely dash dot, shorten >= 1] (e0-right) --  node[above, align=center]{\emph{rename to \epoch{B2}}} (eb2-left);
        }
        \newcommand\finalstateb[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{B2}}
                ++(0:1.3 * \widthepoch) \renhello{#3};
        }

        \newcommand\offseta{ (90:0.7) }
        \newcommand\offsetb{ (-90:0.7) }

        \path
            node {\textbf{A}}
            ++(0:0.5) node (a) {}
            +(0:32) node (a-end) {}
            +(0:2) node[point] (a-initial) {}
            +(0:6) node[point] (a-recv-ins-l) {}
            +(0:12) node[point] (a-recv-ren-b2) {}
            +(0:30) node (a-final) {};

        \ren{(a-initial)}{\offseta}{90};
        \recvrenl{(a-recv-ins-l)}{\offseta}{90};
        \finalstatea{(a-recv-ren-b2)}{\offseta}{90};

        \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
        \draw[->, thick] (a-initial) --  (a-recv-ins-l) -- (a-recv-ren-b2) -- (a-final);

        \path
            ++(270:3) node {\textbf{B}}
            ++(0:0.5) node (b) {}
            +(0:32) node (b-end) {}
            +(0:2) node[point] (b-initial) {}
            +(0:8) node[point, label=170:{$\trm{ren}()$}, label={[xshift=30pt]10:{$\trm{ren(\betterepoch{0}, B,2)}$}}] (b-ren-b2) {}
            +(0:30) node (b-final) {};


        \insl{(b-initial)}{\offsetb}{-90};
        \finalstateb{(b-ren-b2)}{\offsetb}{-90};

        \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
        \draw[->, thick] (b-initial) --  (b-ren-b2) -- (b-final);

        \draw[->, dashed, shorten >= 1] (b-initial) -- (a-recv-ins-l);
        \draw[->, dashed, shorten >= 1] (b-ren-b2) -- (a-recv-ren-b2);
    \end{tikzpicture}
  }
  \caption{Annulation d'une opération \emph{rename} intégrée précèdemment en présence d'un identifiant inséré en concurrence}
  \label{fig:revertRenameId}
\end{figure}

C'est précisément le but de \textsc{revertRenameId}, qui associe les identifiants de l'époque \emph{enfant} aux identifiants correspondant dans l'époque \emph{parente}.
Nous décrivons cette fonction dans l'\autoref{alg:revertRenameId}.

\begin{algorithm}[!ht]
  \footnotesize
  \begin{algorithmic}[1]
    \Function{revertRenameId}{id $\in \mathbb{I}$, renamedIds $\in \trm{Arr}\langle \mathbb{I} \rangle$, nodeId $\in \mathbb{N}$, nodeSeq $\in \mathbb{N}$}{: $\mathbb{I}$}
      \Statex \Comment $\text{renamedIds} = [\text{id}_0, \text{id}_1, \cdots, \text{id}_{n-2}, \text{id}_{n-1}]$

        \State $\text{firstId} \gets \text{id}_0$
        \State $\text{lastId} \gets \text{id}_{n - 1}$
        \Statex \Comment $\text{firstId} = \langle \text{pos}, \_, \_, \_ \rangle \oplus \text{suffix}$
        \State $\text{newFirstId} \gets \newFirstId$
        \State $\text{newLastId} \gets \newLastId$

        \If{$\text{id} \lid \text{newFirstId}$}
          \State \Return revRenIdLessThanNewFirstId(id, firstId, newFirstId)
        \ElsIf{$\text{id} = \langle \text{pos}, \text{nodeId}, \text{nodeSeq}, i \rangle$}
            \Statex \Comment id obtained through \autoref{alg:renameId}, ligne \ref{alg:rename-id-in-renamedids}
            \State \Return $\text{id}_i$
        \ElsIf{$\text{newLastId} \lid \text{id}$}
            \State \Return revRenIdGreaterThanNewLastId(id, lastId)
        \Else
            \Statex \Comment $\text{id} = \newlogootsplituple{i} \oplus \text{suffix}$
            \State \Return revRenIdfromPredId(id, renamedIds, $i$)
        \EndIf
    \EndFunction
    \\
    \Function{revRenIdfromPredId}{id $\in \mathbb{I}$, renamedIds $\in \trm{Arr}\langle \mathbb{I} \rangle$, index $\in \mathbb{N}$}{: $\mathbb{I}$}
        \Statex \Comment $\text{renamedIds} = [\text{id}_0, \text{id}_1, \cdots, \text{id}_{n-2}, \text{id}_{n-1}]$
        \Statex \Comment $\text{id} = \newlogootsplituple{\text{index}} \oplus \text{tail}$

        \State $\text{predId} \gets \text{id}_{\text{index}}$
        \State $\text{succId} \gets \text{id}_{\text{index}+1}$

        \If{$\text{tail} \lid \text{predId}$}
            \Statex \Comment id has been inserted causally after the \emph{rename} op
            \State \Return $\text{predId} \oplus \bott \oplus \text{tail}$ \Comment \commentbott
        \ElsIf{$\text{succId} \lid \text{tail}$}
            \Statex \Comment id has been inserted causally after the \emph{rename} op
            \Statex \Comment $\text{succId} = \text{prefix} \oplus \logootsplituple{j}$
            \State $\text{predOfSuccId} \gets \text{prefix} \oplus \langle \text{pos}_j,\text{nodeId}_j,\text{nodeSeq}_j,\text{offset}_{j} - 1 \rangle$
            \State \Return $\text{predOfSuccId} \oplus \topt \oplus \text{tail}$ \Comment \commenttopt
        \Else
            \State \Return tail
        \EndIf
    \EndFunction
  \end{algorithmic}
  \caption{Fonctions principales pour annuler le renommage appliqué précèdemment à un identifiant}
  \label{alg:revertRenameId}
\end{algorithm}

Les objectifs de \textsc{revertRenameId} sont les suivants :
\begin{enumerate}
  \item \label{item:revert-rename-1}
    Restaurer à leur ancienne valeur les identifiants générés causalement avant l'opération \emph{rename} annulée.
  \item \label{item:revert-rename-2}
    Restaurer à leur ancienne valeur les identifiants générés de manière concurrente à l'opération \emph{rename} annulée.
  \item \label{item:revert-rename-3}
    Assigner de nouveaux identifiants respectant l'ordre souhaité aux éléments qui ont été insérés causalement après l'opération \emph{rename} annulée.
\end{enumerate}

Le cas \ref{item:revert-rename-1} est le plus trivial.
Pour retrouver la valeur de $\trm{id}$ à partir de $\trm{newId}$\footnote{Nous appelons $\trm{newX}$ les identifiants dans l'époque résultant de l'application d'une opération \emph{rename}, tandis que $\trm{X}$ décrit leur équivalent à l'époque initiale.}, \textsc{revertRenameId} utilise simplement la valeur de offset de $\trm{newId}$.
En effet, cette valeur correspond à l'index de $\trm{id}$ dans l'\emph{ancien état} (\ie $\trm{renamedIds[offset]} = \trm{id}$).
Par exemple, dans la \autoref{fig:revertRenameId}, l'identifiant \id{i}{A1}{0} a pour offset 0, \textsc{revertRenameId} renvoie donc $\trm{renamedIds[0]} =$ \id{i}{B0}{0}.

Les cas \ref{item:revert-rename-2} et \ref{item:revert-rename-3} sont gérés en utilisant les stratégies suivantes.
Le motif générique pour l'identifiant $\trm{newId}$ est de la forme $\trm{newPredId~tail}$.
Deux invariants sont associés à ce motif.
D'après la \autoref{prop:order}, nous avons :
\[\trm{newId} \in ]\trm{newPredId}, \trm{newSuccId}[\]
et nous devons obtenir :
\[\trm{id} \in ]\trm{predId}, \trm{succId}[\]

Le premier sous-cas se produit quand nous avons $\trm{tail} \in ]\trm{predId}, \trm{succId}[$.
Dans ce cas, $\trm{newId}$ peut résulter d'une opération \emph{insert} concurrent à l'opération \emph{rename} (\ie le cas \ref{item:revert-rename-2}).
Nous avons alors :
\[\trm{newId} \in ]\trm{newPredId~predId}, \trm{newPredId~succId}[\]
Dans cette situation, $\trm{newId}$ a été obtenu en utilisant \textsc{renIdFromPredId} et nous avons $\trm{id} = \trm{tail}$.
Nous observons qu'en renvoyant $\trm{tail}$, \textsc{revertRenameId} valident les deux contraintes, \ie préserver l'ordre souhaité et restaurer à sa valeur initiale l'identifiant.
Pour illustrer ce cas, considérons l'identifiant \id{i}{A1}{1}\id{i}{B0}{0}\id{m}{B1}{0} dans la \autoref{fig:revertRenameId}.
Pour cet identifiant, nous avons :
\begin{itemize}
  \item $newPredId = $\id{i}{A1}{1}, donc $predId = $\id{i}{B0}{0}\id{f}{A0}{0} d'après le cas \ref{item:revert-rename-1}.
  \item $newSuccId = $\id{i}{A1}{2}, donc $succId = $\id{i}{B0}{1} d'après le cas \ref{item:revert-rename-1}.
\end{itemize}
Nous avons donc bien :
\[i^{A1}_{1}i^{B0}_{0}m^{B1}_{0} \in ]i^{A1}_{1}i^{B0}_{0}f^{A0}_{0}, i^{A1}_{1}i^{B0}_{1}[\]
et $tail = $\id{i}{B0}{0}\id{m}{B1}{0}.
Renvoyer cette valeur nous permet ainsi de conserver l'ordre entre les identifiants puisque :

\[i^{B0}_{0}f^{A0}_{0} <_{id} i^{B0}_{0}m^{B1}_{0} <_{id} i^{B0}_{1}\]

Le second sous-cas correspond au cas où nous avons $\trm{tail} < \trm{predId}$.
$\trm{newId}$ ne peut avoir été inséré que causalement après l'opération \emph{rename} (\ie le cas \ref{item:revert-rename-3}).
Nous avons alors :
\[\trm{newId} \in ]\trm{newPredId}, \trm{newPredId~predId}[\]
Puisque $\trm{newId}$ a été inséré causalement après l'opération \emph{rename}, il n'existe pas de contrainte sur la valeur à retourner autre que la \autoref{prop:order}.
Pour gérer ce cas, nous introduisons deux nouveaux tuples exclusifs au mécanisme de renommage : $\trm{MIN\_TUPLE}$ et $\trm{MAX\_TUPLE}$, notés respectivement $\bot$ et $\top$.
Ils sont respectivement le tuple minimal et maximal utilisables pour générer des identifiants.
En utilisant $\trm{MIN\_TUPLE}$, \textsc{revertRenameId} est capable de renvoyer une valeur pour $\trm{id}$ adaptée à l'ordre souhaité (avec $\trm{id} = \trm{predId~\bot~tail}$).
Nous justifions ce comportement à l'aide de la \autoref{fig:revertRenameId-mintuple}.

\begin{figure}[!ht]
  \subfloat[Génération d'une opération \emph{insert} dépendante causalement d'une opération \emph{rename}]{
    \begin{minipage}{\linewidth}
      \centering
      \resizebox{\columnwidth}{!}{
        \begin{tikzpicture}
            \path
                node {\textbf{C}}
                ++(0:0.5 * \widthletter) node[epoch] (S1C-left) {\epoch{0}}
                ++(0:1.05 * \widthoriginepoch) node[letter,
                          label={below:{\id{k}{D0}{0}} }
                              ] {W}
                ++(0:\widthletter) node[letter,
                          label={below:{\id{n}{C0}{0}} }
                              ] {O}
                ++(0:\widthletter) node[letter,
                          label={below:{\id{o}{D1}{0}} }
                              ] (S1C-right) {D}
                ++(0:3 * \widthblock) node[epoch] (S2C-left) {\epoch{C1}}
                ++(0:1.3 * \widthepoch) node[block, fill=mydarkblue,
                          label={below:{\color{mydarkblueid}\id{k}{C1}{0..2}} }
                              ] (S2C-right) {WOD}
                ++(0:4 * \widthblock) node[epoch] (S3C-left) {\epoch{C1}}
                ++(0:1.3 * \widthepoch) node[block, fill=mydarkblue,
                          label={below:{\color{mydarkblueid}\id{k}{C1}{0..1}} }
                              ] {WO}
                ++(0:\widthblock) node[letter, fill=mylightblue,
                          label={above:{\color{mylightblue!20!mydarkblueid}\id{k}{C1}{1}\id{n}{C0}{0}\id{e}{D2}{0}} }
                              ] {L}
                ++(0:\widthletter) node[letter, fill=mydarkblue,
                          label={below:{\color{mydarkblueid}\id{k}{C1}{2}} }
                              ] (S3C-right) {D}
                ++(0:3 * \widthblock) node[epoch] (S4C-left) {\epoch{C1}}
                ++(0:1.3 * \widthepoch) node[block, fill=mydarkblue,
                          label={below:{\color{mydarkblueid}\id{k}{C1}{0..1}} }
                              ] {WO}
                ++(0:\widthblock) node[letter,
                          label={above:{\id{k}{C1}{1}\id{i}{C2}{0}} }
                              ] {R}
                ++(0:\widthletter) node[letter, fill=mylightblue,
                          label={below:{\color{mylightblue!20!mydarkblueid}\id{k}{C1}{1}\id{n}{C0}{0}\id{e}{D2}{0}} }
                              ] {L}
                ++(0:\widthletter) node[letter, fill=mydarkblue,
                          label={above:{\color{mydarkblueid}\id{k}{C1}{2}} }
                              ] (S4C-right) {D};

            \path
                ++(270:3) node {\textbf{D}}

                ++(0:0.5 * \widthletter) node[epoch] (S1D-left) {\epoch{0}}
                ++(0:1.05 * \widthoriginepoch) node[letter,
                          label={below:{\id{k}{D0}{0}} }
                              ] {W}
                ++(0:\widthletter) node[letter,
                          label={below:{\id{n}{C0}{0}} }
                              ] {O}
                ++(0:\widthletter) node[letter,
                          label={below:{\id{o}{D1}{0}} }
                              ] (S1D-right) {D}

                ++(0:3 * \widthblock) node[epoch] (S2D-left) {\epoch{0}}
                ++(0:1.05 * \widthoriginepoch) node[letter,
                          label={below:{\id{k}{D0}{0}} }
                              ] {W}
                ++(0:\widthletter) node[letter,
                          label={above:{\id{n}{C0}{0}} }
                              ] {O}
                ++(0:\widthletter) node[letter, fill=mylightorange,
                          label={below:{\color{mylightorange}\id{n}{C0}{0}\id{e}{D2}{0}} }
                              ] {L}
                ++(0:\widthletter) node[letter,
                          label={above:{\id{o}{D1}{0}} }
                              ] (S2D-right) {D}

                ++(0:4 * \widthblock) node[epoch] (S3D-left) {\epoch{D3}}
                ++(0:1.34 * \widthepoch) node[block, fill=mydarkpurple,
                          label={below:{\color{mydarkpurpleid}\id{k}{D3}{0..3}} }
                              ] (S3D-right) {WOLD};


            \draw[->, thick] (S1C-right) -- node[above, align=center]{\emph{rename to \epoch{C1}}} (S2C-left);
            \draw[dotted] (S2C-right) -- (S3C-left);
            \draw[->, thick] (S3C-right) -- node[above, align=center]{\emph{insert "R"}\\ \emph{between}\\ \emph{"O" and "L"}} (S4C-left);

            \draw[->, thick] (S1D-right) -- node[below, align=center]{\emph{insert "L"}\\ \emph{between}\\ \emph{"O" and "D"}} (S2D-left);
            \draw[->, thick] (S2D-right) -- node[below, align=center]{\emph{rename to \epoch{D3}}} (S3D-left);


            \draw[dashed, ->, thick, shorten >= 3] (S2D-right.east) -- node[right, xshift=5pt, align=center]{\emph{insert "L" at} {\color{mylightorange}\id{n}{C0}{0}\id{e}{D2}{0}}} (S3C-left.west);
        \end{tikzpicture}
        }
        \label{fig:revertRenameId-mintuple-setup}
    \end{minipage}}
  \hfil
  \subfloat[Annulation de l'opération \emph{rename} précédente au profit d'une opération \emph{rename} concurrente]{
    \begin{minipage}{\linewidth}
      \centering
      \resizebox{\columnwidth}{!}{
        \begin{tikzpicture}
            \path
                node {\textbf{C}}
                ++(0:0.5 * \widthletter) node[epoch] (S4C-left) {\epoch{C1}}
                ++(0:1.3 * \widthepoch) node[block, fill=mydarkblue,
                          label={below:{\color{mydarkblueid}\id{k}{C1}{0..1}} }
                              ] {WO}
                ++(0:\widthblock) node[letter,
                          label={above:{\id{k}{C1}{1}\id{i}{C2}{0}} }
                              ] {R}
                ++(0:\widthletter) node[letter, fill=mylightblue,
                          label={below:{\color{mylightblue!20!mydarkblueid}\id{k}{C1}{1}\id{n}{C0}{0}\id{e}{D2}{0}} }
                              ] {L}
                ++(0:\widthletter) node[letter, fill=mydarkblue,
                          label={above:{\color{mydarkblueid}\id{k}{C1}{2}} }
                              ] (S4C-right) {D}
                ++(0:2 * \widthblock) node[point] (between-S4C-S5C) {}
                ++(0:3 * \widthletter) node[epoch] (S5C-left) {\epoch{0}}
                ++(0:1.05 * \widthoriginepoch) node[letter,
                          label={below:{\id{k}{D0}{0}} }
                              ] {W}
                ++(0:\widthletter) node[letter,
                          label={below:{\id{n}{C0}{0}} }
                              ] {O}
                ++(0:\widthletter) node[letter, fill=mydarkorange,
                          label={above:{\color{mydarkorange}\id{n}{C0}{0}$\bot$\id{i}{C2}{0}} }
                              ] {R}
                ++(0:\widthletter) node[letter, fill=mylightorange,
                          label={below:{\color{mylightorange}\id{n}{C0}{0}\id{e}{D2}{0}} }
                              ] {L}
                ++(0:\widthletter) node[letter,
                          label={above:{\id{o}{D1}{0}} }
                              ] (S5C-right) {D}
                ++(0:2 * \widthblock) node[epoch] (S6C-left) {\epoch{D3}}
                ++(0:1.34 * \widthepoch) node[block, fill=mydarkpurple,
                          label={below:{\color{mydarkpurpleid}\id{k}{D3}{0..1}} }
                              ] {WO}
                ++(0:\widthblock) node[letter,
                          label={above:{\id{k}{D3}{1}\id{n}{C0}{0}$\bot$\id{i}{C2}{0}} }
                              ] {R}
                ++(0:\widthletter) node[block, fill=mydarkpurple,
                          label={below:{\color{mydarkpurpleid}\id{k}{D3}{2..3}} }
                              ] {LD};

            \path
                ++(270:3) node {\textbf{D}}

                ++(0:0.5 * \widthletter) node[epoch] (S3D-left) {\epoch{D3}}
                ++(0:1.34 * \widthepoch) node[block, fill=mydarkpurple,
                          label={below:{\color{mydarkpurpleid}\id{k}{D3}{0..3}} }
                              ] (S3D-right) {WOLD};

            \draw[dotted] (S4C-right) -- (between-S4C-S5C) (S5C-right) -- (S6C-left);
            \draw[->, loosely dash dot, thick, shorten >= 1] (between-S4C-S5C) -- node[above, align=center]{\emph{revert to \epoch{0}}} (S5C-left);

            \draw[->, dashed, thick] (S3D-right.east) -- node[right, xshift=5pt, align=center]{\emph{rename to \epoch{D3}}} (between-S4C-S5C);
            \draw[->, dashed, thick, shorten >= 3] (between-S4C-S5C) edge[bend right] (S6C-left.west);
        \end{tikzpicture}
        }
        \label{fig:revertRenameId-mintuple-revert}
    \end{minipage}}
  \caption{Annulation d'une opération \emph{rename} intégrée précèdemment en présence d'un identifiant inséré causalement après}
  \label{fig:revertRenameId-mintuple}
\end{figure}

Dans la \autoref{fig:revertRenameId-mintuple}, les noeuds C et D répliquent une même séquence contenant les éléments "WOD".
Dans la \autoref{fig:revertRenameId-mintuple-setup}, le noeud C commence par renommer son état.
En concurrence, le noeud D insère l'élément "L" entre les éléments "O" et "D".
L'opération \emph{insert} correspondante est livrée au noeud C, qui l'intègre en suivant le comportement défini en \autoref{sec:ops-concurrent-to-rename}.
Le noeud C procède ensuite à l'insertion de l'élément "R" entre les éléments "O" et "L".
Cette insertion dépend donc causalement de l'opération \emph{rename} effectuée précédemment par C.
En parallèle, le noeud D effectue un renommage de son état.
Cette opération \emph{rename} est donc concurrente à l'opération \emph{rename} générée précédemment par C.

Dans la \autoref{fig:revertRenameId-mintuple-revert}, l'opération \emph{rename} de D est livrée au noeud C.
L'époque introduite par cette opération étant prioritaire par rapport à l'époque actuelle de C (\epoch{C1} \lepoch \epoch{D3}), le noeud C procède à l'annulation de son opération \emph{rename}.

L'identifiant qui nous intéresse ici est l'identifiant inséré causalement après l'opération \emph{rename} annulée : \id{k}{C1}{1}\id{i}{C2}{0}.
Cet identifiant est compris entre les identifiants suivants :
\[k^{C1}_{1} <_{id} k^{C1}_{1}i^{C2}_{0} <_{id} k^{C1}_{1}n^{C0}_{0}e^{D2}_{0}\]
D'après les règles présentées précédemment :
\begin{itemize}
  \item \id{k}{C1}{1} est transformé en \id{n}{C0}{0} (cas \ref{item:revert-rename-1}).
  \item \id{k}{C1}{1}\id{n}{C0}{0}\id{e}{D2}{0} est transformé en \id{n}{C0}{0}\id{e}{D2}{0} (cas \ref{item:revert-rename-2}).
\end{itemize}
Nous devons générer un identifiant $\trm{id}$ à partir de \id{k}{C1}{1}\id{i}{C2}{0} tel que :
\[n^{C0}_{0} <_{id} \trm{id} <_{id} n^{C0}_{0}e^{D2}_{0}\]

Utiliser $\trm{predId}$ (\id{n}{C0}{0}) en tant que préfixe de $\trm{id}$ nous permet de garantir que \id{n}{C0}{0} $\lid$ $\trm{id}$.
Cependant, appliquer la même stratégie que pour le cas \ref{item:revert-rename-2} pour générer $\trm{id}$ transgresserait la \autoref{prop:order}.
En effet, nous obtiendrions $\trm{id} = $ \id{n}{C0}{0}\id{i}{C2}{0}, or \id{n}{C0}{0}\id{i}{C2}{0} $\nless_{id}$ \id{n}{C0}{0}\id{e}{D2}{0}.

Ainsi, nous devons choisir un autre préfixe dans cette situation, notamment pour garantir que l'identifiant résultant sera plus petit que les identifiants suivants.
C'est pour cela que nous introduisons $MIN\_TUPLE$.
En concaténant $\trm{predId}$ et le tuple minimal, nous obtenons un préfixe nous permettant à la fois de garantir que \id{n}{C0}{0} $\lid$ $\trm{id}$ et que $\trm{id}$ $\lid$ \id{n}{C0}{0}\id{e}{D2}{0}.
Nous obtenons donc $\trm{id} = $ \id{n}{C0}{0}$\bot$\id{i}{C2}{0}, ce qui respecte la \autoref{prop:order}.

Finalement, le dernier sous-cas est le pendant du sous-cas précédent et se produit lorsque nous avons $\trm{succId} < \trm{tail}$.
Nous avons alors :
\[\trm{newId} \in ]\trm{newPredId~succId}, \trm{newSuccId}[\]
La stratégie pour gérer ce cas est similaire et consiste à ajouter un préfixe pour créer l'ordre souhaité.
Pour générer ce préfixe, \textsc{revertRenameId} utilise  $\trm{predOfSuccId}$ et $MAX\_TUPLE$.
$\trm{predOfSuccId}$ est obtenu en décrémentant le dernier offset de $\trm{succId}$.
Ainsi, pour préserver l'ordre souhaité, \textsc{revertRenameId} renvoie $\trm{id}$ avec $\trm{id} = \trm{predOfSuccId~\top~tail}$.

% Une fois que le noeud A a converti son état à un état équivalent à l'époque \epoch{0} en utilisant \textsc{revertRenameId}, il peut appliquer \textsc{renameId} pour calculer l'état correspondant à \epoch{B2}.

Comme pour l'\autoref{alg:renameId}, l'\autoref{alg:revertRenameId} ne présente seulement que le cas principal de \textsc{revertRenameId}.
Il s'agit du cas où l'identifiant à restaurer appartient à l'intervalle des identifiants renommés $\trm{newFirstId}$ \leqid $\trm{id}$ \leqid $\trm{newLastId}$).
Les fonctions pour gérer les cas restants sont présentées dans l'\autoref{app:revert-rename-id}.

Notons que \textsc{renameId} et \textsc{revertRenameId} ne sont pas des fonctions réciproques.
\textsc{revertRenameId} restaure à leur valeur initiale les identifiants insérés causalement avant ou de manière concurrente à l'opération \emph{rename}.
Par contre, \textsc{renameId} ne fait pas de même pour les identifiants insérés causalement après l'opération \emph{rename}.
Rejouer une opération \emph{rename} précédemment annulée altère donc ces identifiants.
Cette modification peut entraîner une divergence entre les noeuds, puis qu'un même élément sera désigné par des identifiants différents.

Ce problème est toutefois évité dans notre système grâce à la relation \emph{priority} utilisée.
Puisque la relation \emph{priority} est définie en utilisant l'ordre lexicographique sur le chemin des époques dans l'\emph{arbre des époques}, les noeuds se déplacent seulement vers l'époque la plus à droite de l'\emph{arbre des époques} lorsqu'ils changent d'époque.
Les noeuds évitent donc d'aller et revenir entre deux mêmes époques, et donc d'annuler et rejouer les opérations \emph{rename} correspondantes.
