\label{sec:reverting-rename-ops}

À présent, nous développons le scénario présenté dans la \autoref{fig:conflicting-rename-operations}.
Dans la \autoref{fig:revertRenameId}, le noeud A reçoit l'opération $\trm{rename}$ du noeud B.
Cette opération est concurrente à l'opération $\trm{rename}$ que le noeud A a appliqué précédemment.
D'après la relation \emph{priority} proposée, le noeud A sélectionne l'époque introduite \epoch{B3} comme l'époque cible (\epoch{A2} \lepoch \epoch{B3}).
Mais pour pouvoir renommer son état vers l'époque \epoch{B3}, il doit au préalable faire revenir son état courant de l'époque \epoch{A2} à un état équivalent à l'époque \epoch{0}.
Nous devons définir un mécanisme permettant aux noeuds d'annuler les effets d'une opération $\trm{rename}$ appliquée précédemment.

\begin{figure}[!ht]
  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
        \newcommand\nodeh[1]{
            node[letter, label=#1:{$\betterid{i}{B1}{0}$}] {H}
        }
        \newcommand\nodee[1]{
            node[letter, fill=\colorblockone, label=#1:{\coloridone$\betterid{i}{B1}{0}\betterid{f}{A1}{0}$}] {E}
        }
        \newcommand\nodelo[1]{
            node[block, label=#1:{$\betterid{i}{B1}{1..2}$}] {LO}
        }
        \newcommand\renhelo[1]{
            node[block, fill=\colorblocktwo, label=#1:{\coloridtwo$\betterid{i}{A2}{0..3}$}] {HELO}
        }
        \newcommand\nodel[1]{
            node[letter, fill=\colorblockthree,label=#1:{\coloridthree$\betterid{i}{B1}{0}\betterid{m}{B2}{0}$}] {L}
        }
        \newcommand\renhe[1]{
            node[block, fill=\colorblocktwo, label=#1:{\coloridtwo$\betterid{i}{A2}{0..1}$}] {HE}
        }
        \newcommand\renl[1]{
            node[letter, fill=\colorblockfour, label=#1:{\coloridfour$\betterid{i}{A2}{1}\betterid{i}{B1}{0}\betterid{m}{B2}{0}$}] {L}
        }
        \newcommand\renlo[1]{
            node[block, fill=\colorblocktwo, label=#1:{\coloridtwo$\betterid{i}{A2}{2..3}$}] {LO}
        }
        \newcommand\renhello[1]{
            node[block, fill=\colorblockfive, label=#1:{\coloridfive$\betterid{i}{B3}{0..4}$}] {HELLO}
        }

        \newcommand\initialstate[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{0}}
                ++(0:1.05 * \widthoriginepoch) \nodeh{-#3}
                ++(0:\widthletter) \nodee{#3}
                ++(0:\widthletter) \nodelo{-#3};
        }

        \newcommand\ren[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{A2}}
                ++(0:1.3 * \widthepoch) \renhelo{-#3};
        }

        \newcommand\insl[3]{
            \path
            #1
            ++#2
            ++(0:0.5)
            ++(#3:0.5) node[epoch] {\epoch{0}}
            ++(0:1.05 * \widthoriginepoch) \nodeh{-#3}
            ++(0:\widthletter) \nodee{#3}
            ++(0:\widthletter) \nodel{-#3}
            ++(0:\widthletter) \nodelo{#3};
        }

        \newcommand\recvrenl[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{A2}}
                ++(0:1.3 * \widthepoch) \renhe{-#3}
                ++(0:\widthblock) \renl{#3}
                ++(0:\widthletter) \renlo{-#3};
        }
        \newcommand\finalstatea[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{A2}}
                ++(0:1.3 * \widthepoch) \renhe{-#3}
                ++(0:\widthblock) \renl{#3}
                ++(0:\widthletter) \renlo{-#3}
                ++(0:\widthblock) node (eA2-right) {}
                ++(0:1.5) node[epoch] (e0-left) {\epoch{0}}
                ++(0:1.05 * \widthoriginepoch) \nodeh{-#3}
                ++(0:\widthletter) \nodee{#3}
                ++(0:\widthletter) \nodel{-#3}
                ++(0:\widthletter) \nodelo{#3}
                ++(0:\widthblock) node (e0-right) {}
                ++(0:1.5) node[epoch] (eB3-left) {\epoch{B3}}
                ++(0:1.3 * \widthepoch) \renhello{#3};

                \draw[->, loosely dash dot, shorten >= 1] (eA2-right) --  node[above, align=center]{\emph{revert}\\ \emph{to} \epoch{0}} (e0-left);
                \draw[->, loosely dash dot, shorten >= 1] (e0-right) --  node[above, align=center]{$\trm{rename}$\\ \emph{to} \epoch{B3}} (eB3-left);
        }
        \newcommand\finalstateb[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{B3}}
                ++(0:1.3 * \widthepoch) \renhello{#3};
        }

        \newcommand\offseta{ (90:0.7) }
        \newcommand\offsetb{ (-90:0.7) }

        \path
            node {\textbf{A}}
            ++(0:0.5) node (a) {}
            +(0:26) node (a-end) {}
            +(0:1) node[point] (a-initial) {}
            +(0:5) node[point] (a-recv-ins-l) {}
            +(0:12) node[point] (a-recv-ren-B3) {}
            +(0:25) node (a-final) {};

        \ren{(a-initial)}{\offseta}{90};
        \recvrenl{(a-recv-ins-l)}{\offseta}{90};
        \finalstatea{(a-recv-ren-B3)}{\offseta}{90};

        \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
        \draw[->, thick] (a-initial) --  (a-recv-ins-l) -- (a-recv-ren-B3) -- (a-final);

        \path
            ++(270:3) node {\textbf{B}}
            ++(0:0.5) node (b) {}
            +(0:26) node (b-end) {}
            +(0:1) node[point, label={[xshift=20pt]10:{$\trm{ins}(\betterepoch{0}, {\coloridthree\betterid{i}{B1}{0}\betterid{m}{B2}{0}},L)$}}] (b-initial) {}
            +(0:8) node[point, label=170:{$\trm{ren}()$}, label={[xshift=30pt]10:{$\trm{ren}(\betterepoch{0}, B,3)$}}] (b-ren-B3) {}
            +(0:25) node (b-final) {};


        \insl{(b-initial)}{\offsetb}{-90};
        \finalstateb{(b-ren-B3)}{\offsetb}{-90};

        \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
        \draw[->, thick] (b-initial) --  (b-ren-B3) -- (b-final);

        \draw[->, dashed, shorten >= 1] (b-initial) -- (a-recv-ins-l);
        \draw[->, dashed, shorten >= 1] (b-ren-B3) -- (a-recv-ren-B3);
    \end{tikzpicture}
  }
  \caption{Annulation d'une opération $\trm{rename}$ intégrée précèdemment en présence d'un identifiant inséré en concurrence}
  \label{fig:revertRenameId}
\end{figure}

C'est précisément le but de \texttt{revertRenameId}, qui associe les identifiants de l'époque \emph{enfant} aux identifiants correspondant dans l'époque \emph{parente}.
Nous décrivons cette fonction dans l'\autoref{alg:revertRenameId}.

\begin{algorithm}[!ht]
  \footnotesize
  \begin{algorithmic}[1]
    \Function{revertRenameId}{newId $\in \mathbb{I}$, renamedIds $\in \trm{Array}\langle \mathbb{I} \rangle$, nodeId $\in \mathbb{N}$, nodeSeq $\in \mathbb{N}$}{: $\mathbb{I}$}

        \Statex
        \State $[\text{id}_0, \text{id}_1, \cdots, \text{id}_{n-2}, \text{id}_{n-1}] \leftarrow \text{renamedIds}$
        \State $\text{firstId} \gets \text{id}_0$
        \State $\text{lastId} \gets \text{id}_{n - 1}$
        \State $\langle \text{pos}, \_, \_, \_ \rangle \oplus \text{\_} \leftarrow \text{firstId}$
        \State $\text{newFirstId} \gets \newFirstId$
        \State $\text{newLastId} \gets \newLastId$
        \Statex
        \If{$\text{newId} \lid \text{newFirstId}$}
          \State \Return revRenIdLessThanNewFirstId(newId, firstId, newFirstId)
        \ElsIf{$\text{newId} = \langle \text{pos}, \text{nodeId}, \text{nodeSeq}, \_ \rangle$}
            \label{alg:revertRenameId-in-former-state}
            \Statex \Comment newId obtained through \autoref{alg:renameId}, line \ref{alg:renameId-id-in-renamedids-end}
            \State $\langle \_,\_,\_,i \rangle \leftarrow \text{newId}$
            \State \Return $\text{id}_i$ \label{alg:revertRenameId-case-i}
        \ElsIf{$\text{newLastId} \lid \text{newId}$}
            \State \Return revRenIdGreaterThanNewLastId(newId, lastId)
        \Else
            \Statex \Comment $\text{newId} = \newlogootsplituple{i} \oplus \text{tail}$
            \State \Return revRenIdfromPredId(newId, renamedIds, $i$)
        \EndIf
    \EndFunction
    \Statex
    \Function{revRenIdfromPredId}{newId $\in \mathbb{I}$, renamedIds $\in \trm{Array}\langle \mathbb{I} \rangle$, index $\in \mathbb{N}$}{: $\mathbb{I}$}
        \Statex
        \State $[\text{id}_0, \text{id}_1, \cdots, \text{id}_{n-2}, \text{id}_{n-1}] \leftarrow \text{renamedIds}$
        \State $\langle \_,\_,\_, \text{offset} \rangle \oplus \text{tail} \leftarrow \text{newId}$ \label{alg:revertRenameId-offset}
        \State $\text{predId} \gets \text{id}_{\text{offset}}$ \label{alg:revertRenameId-predId}
        \State $\text{succId} \gets \text{id}_{\text{offset}+1}$ \label{alg:revertRenameId-succId}
        \Statex
        \If{$\text{tail} \lid \text{predId}$}
            \Statex \Comment newId has been inserted causally after the $\trm{rename}$ op
            \State \Return $\text{predId} \oplus \bott \oplus \text{tail}$ \Comment \commentbott \label{alg:revertRenameId-case-iii}
        \ElsIf{$\text{succId} \lid \text{tail}$}
            \Statex \Comment newId has been inserted causally after the $\trm{rename}$ op
            \State $\text{prefix} \oplus \logootsplituple{j} \oplus \_ \leftarrow \text{succId}$
            \State $\text{predOfSuccId} \gets \text{prefix} \oplus \langle \text{pos}_j,\text{nodeId}_j,\text{nodeSeq}_j,\text{offset}_{j} - 1 \rangle$
            \State \Return $\text{predOfSuccId} \oplus \topt \oplus \text{tail}$ \Comment \commenttopt
        \Else
            \State \Return tail \label{alg:revertRenameId-case-ii}
        \EndIf
    \EndFunction
  \end{algorithmic}
  \caption{Fonctions principales pour annuler le renommage appliqué précèdemment à un identifiant}
  \label{alg:revertRenameId}
\end{algorithm}

Les objectifs de \texttt{revertRenameId} sont les suivants :
\begin{enumerate}
  \item \label{item:revert-rename-1}
    Restaurer à leur ancienne valeur les identifiants générés causalement avant l'opération $\trm{rename}$ annulée, \ie les identifiants appartenant à l'ancien état de l'opération (\eg $\betterid{i}{A2}{1} \rightarrow \betterid{i}{B1}{0}\betterid{f}{A1}{0}$ dans la \autoref{fig:revertRenameId}).
    Ce cas revient à annuler l'effet du cas \ref{item:renameId-id-in-former-state} de \texttt{renameId} (cf. page \pageref{item:renameId-id-in-former-state}).
  \item \label{item:revert-rename-2}
    Restaurer à leur ancienne valeur les identifiants générés de manière concurrente à l'opération $\trm{rename}$ annulée, \ie les identifiants n'appartenant pas à l'ancien état de l'opération (\eg $\betterid{i}{A2}{1}\betterid{i}{B1}{0}\betterid{m}{B2}{0} \rightarrow \betterid{i}{B1}{0}\betterid{m}{B2}{0}$ dans la figure \autoref{fig:revertRenameId}).
    Ce cas revient à annuler l'effet du cas \ref{item:renameId-id-not-in-former-state} de \texttt{renameId} (cf. page \pageref{item:renameId-id-in-former-state}).
  \item \label{item:revert-rename-3}
    Assigner de nouveaux identifiants respectant l'ordre souhaité aux éléments qui ont été insérés causalement après l'opération $\trm{rename}$ annulée, \ie les identifiants générés de façon postérieur à l'opération par le biais d'opérations $\trm{insert}$ non-concurrentes à cette dernière.
    Ce dernier cas n'est pas illustré dans la \autoref{fig:revertRenameId}.
    Ainsi, nous introduirons un nouvel exemple à l'aide de la \autoref{fig:revertRenameId-mintuple} pour le présenter.
\end{enumerate}

Pour déterminer dans quel cas nous nous trouvons pour un identifiant donné, \texttt{revertRenameId} effectue un filtrage par motif sur la valeur de l'identifiant.

\subsubsection{Annuler l'effet du renommage sur un identifiant généré causalement avant l'opération $\trm{rename}$}

\label{sec:reverting-rename-ops-id-in-former-state}

Pour déterminer si l'identifiant donné $\trm{newId}$\footnotemark a été obtenu via le renommage d'un identifiant $\trm{id}$\footnotemark[\value{footnote}] appartenant à l'ancien état de l'opération à annuler, il convient de se rappeler le résultat de \texttt{renameId} pour ces derniers.
\footnotetext{Nous appelons $\trm{newX}$ les identifiants dans l'époque résultant de l'application d'une opération $\trm{rename}$, tandis que $\trm{X}$ décrit leur équivalent à l'époque initiale.}
Comme présenté précédemment \cf{sec:renameId-id-in-former-state}, \texttt{renameId} retourne pour des identifiants appartenant à l'ancien état des identifiants de la forme suivante :
\[ \langle \trm{pos},\trm{nodeId},\trm{nodeSeq},\trm{offset} \rangle \]
où :
\begin{enumerate}
    \item $\trm{pos}$ est la valeur du champ $\trm{pos}$ du premier identifiant appartenant à l'ancien état.
    \item $\trm{nodeId}$ est l'identifiant du noeud qui a généré l'opération \emph{rename}.
    \item $\trm{nodeSeq}$ est le numéro de séquence du noeud qui a généré l'opération \emph{rename}.
    \item $\trm{offset}$ est l'index de l'identifiant renommé dans l'ancien état.
\end{enumerate}
Ainsi, \texttt{revertRenameId} détermine que $\trm{newId}$ a été obtenu via le renommage d'un identifiant appartenant à l'ancien état lorsqu'il présente ce motif ($\betterid{i}{A2}{offset}$ dans la \autoref{fig:revertRenameId}, ligne \ref{alg:revertRenameId-in-former-state} de \autoref{alg:revertRenameId}).

Dans ce cas, \texttt{revertRenameId} utilise simplement la valeur de $\trm{offset}$ de $\trm{newId}$ pour retrouver $\trm{id}$ dans l'\emph{ancien état}.
Par exemple, pour annuler l'effet du renommage sur l'identifiant $\betterid{i}{A2}{0}$ dans la \autoref{fig:revertRenameId} et ainsi retrouver sa valeur précédente, \texttt{revertRenameId} utilise l'offset de l'identifiant (0) pour retrouver l'identifiant à cet index dans l'ancien état ($[\betterid{i}{B1}{0},\betterid{i}{B1}{0}\betterid{f}{A1}{0},\betterid{i}{B1}{1},\betterid{i}{B1}{2}]$).
De cette manière, $\betterid{i}{A2}{0}$ est restauré à son ancienne valeur : $\betterid{i}{B1}{0}$ (ligne \ref{alg:revertRenameId-case-i}).

\subsubsection{Annuler l'effet du renommage sur un identifiant généré en concurrence de l'opération $\trm{rename}$}

\label{sec:reverting-rename-ops-id-inserted-concurrently}

De manière similaire au cas précédent, il convient tout d'abord de déterminer si l'identifiant donné $\trm{newId}$ est le résultat du renommage d'un identifiant généré en concurrence de l'opération $\trm{rename}$.
Pour cela, rappelons le comportement adopté par \texttt{renameId} dans ce cas de figure.
Lorsque l'identifiant à renommer a été généré en concurrence, l'algorithme a recours à la fonction \texttt{renIdFromPredId}.
Cette fonction recherche le prédécesseur $\trm{predId}$ (\eg $\betterid{i}{B1}{0}\betterid{f}{A1}{0}$) de l'identifiant donné $\trm{id}$ (\eg $\betterid{i}{B1}{0}\betterid{m}{B2}{0}$) dans l'\emph{ancien état}, renomme $\trm{predId}$ pour obtenir $\trm{newPredId}$ ($\betterid{i}{A2}{1}$) et finalement renvoie la concaténation de $\trm{newPredId}$ avec $\trm{id}$ ($\betterid{i}{A2}{1}\betterid{i}{B1}{0}\betterid{m}{B2}{0}$, cf. \autoref{sec:renameId-id-not-in-former-state}, page \pageref{sec:renameId-id-not-in-former-state}).

Ainsi, les identifiants générés en concurrence de l'opération $\trm{rename}$ présentent dans la nouvelle époque le motif $\trm{newPredId}~\trm{tail}$ avec :
\begin{enumerate}
    \item $\trm{newPredId}$ un identifiant issu du renommage d'un identifiant appartenant à l'\emph{ancien état}, à l'exception du dernier (\eg $\betterid{i}{A2}{0},\cdots,\betterid{i}{A2}{2}$ dans la \autoref{fig:revertRenameId}).
    \item $\trm{tail}$ un identifiant tel que $\trm{tail} \in ]\trm{predId}, \trm{succId}[$.
\end{enumerate}
\texttt{revertRenameId} peut donc déterminer si l'identifiant donné $\trm{newId}$ résulte du renommage d'un identifiant généré en concurrence de l'opération $\trm{rename}$ en vérifiant s'il présente ce motif.

Cette vérification est effectuée dans \texttt{revRenIdFromPredId}.
L'algorithme décompose $\trm{newId}$ (\eg $\betterid{i}{A2}{1}\betterid{i}{B1}{0}\betterid{m}{B2}{0}$) en deux parties : son premier tuple $\trm{newPredId}$ ($\betterid{i}{A2}{1}$) et sa $\trm{tail}$ ($\betterid{i}{B1}{0}\betterid{m}{B2}{0}$).
Il lit alors l'\emph{offset} (1) de $\trm{newPredId}$ (ligne \ref{alg:revertRenameId-offset}).
Comme indiqué précédemment, cet \emph{offset} correspond à l'index de $\trm{predId}$ dans l'\emph{ancien état} ($[\betterid{i}{B1}{0},\betterid{i}{B1}{0}\betterid{f}{A1}{0},\betterid{i}{B1}{1},\betterid{i}{B1}{2}]$).
Ceci permet de récupérer $\trm{predId}$ ($\betterid{i}{B1}{0}\betterid{f}{A1}{0}$, ligne \ref{alg:revertRenameId-predId}) ainsi que $\trm{succId}$ ($\betterid{i}{B1}{1}$, ligne \ref{alg:revertRenameId-succId}).
Dès lors, il ne reste plus qu'à comparer $\trm{tail}$ à ces deux valeurs (ligne \ref{alg:revertRenameId-case-ii}) pour valider que $\trm{tail} \in ]\trm{predId},\trm{succId}[$.
Cette vérification effectuée, l'algorithme peut dès lors retourner la valeur $\trm{tail}$ ($\betterid{i}{B1}{0}\betterid{m}{B2}{0}$) pour annuler l'effet du renommage tout en satisfaisant nos contraintes, \ie préserver l'ordre souhaité et restaurer à sa valeur initiale l'identifiant.

\subsubsection{Annuler l'effet du renommage sur un identifiant généré causalement après l'opération $\trm{rename}$}

\label{sec:reverting-rename-ops-id-inserted-causally-after}

Les identifiants générés causalement après l'opération $\trm{rename}$ se distinguent des cas décrits précédemment, \ie les identifiants appartenant à l'\emph{ancien état} ou généré en concurrence de l'opération $\trm{rename}$.
Contrairement à ces derniers, les identifiants générés causalement après l'opération $\trm{rename}$ ne possèdent pas de valeurs correspondantes dans l'époque \emph{parente}.

Cette spécifité réduit les contraintes que doit satisfaire \texttt{revertRenameId} pour ces identifiants.
Ainsi, \texttt{revertRenameId} peut retourner un identifiant arbitraire pour un $\trm{newId}$ donné, tant que la valeur de l'identifiant retourné satisfait la contrainte d'unicité \cf{prop:unicity} et de préservation de l'ordre avec les autres identifiants \cf{prop:order}.
Pour illustrer ce cas, nous introduisons un nouvel exemple via la \autoref{fig:revertRenameId-causal}.

\begin{figure}[!ht]
    \subfloat[Mise en place de l'exemple]{
      \begin{minipage}{\linewidth}
        \centering
        \resizebox{\columnwidth}{!}{
          \begin{tikzpicture}
              \newcommand\nodew[1]{
                  node[letter, label=#1:{$\betterid{g}{C1}{0}$}] {W}
              }
              \newcommand\nodeo[1]{
                  node[letter, fill=\colorblockone, label=#1:{\coloridone$\betterid{k}{D1}{0}$}] {O}
              }
              \newcommand\noder[1]{
                  node[letter, label=#1:{$\betterid{n}{C2}{0}$}] {R}
              }
              \newcommand\noded[1]{
                node[letter, label=#1:{$\betterid{v}{D2}{0}$}] {D}
              }
              \newcommand\renword[1]{
                  node[block, fill=\colorblocktwo, label=#1:{\coloridtwo$\betterid{g}{C3}{0..2}$}] {WORD}
              }
              \newcommand\renwor[1]{
                  node[block, fill=\colorblocktwo, label=#1:{\coloridtwo$\betterid{g}{C3}{0..2}$}] {WOR}
              }
              \newcommand\renl[1]{
                  node[letter, fill=\colorblockfour, label=#1:{\coloridfour$\betterid{g}{C3}{2}\betterid{t}{D3}{0}$}] {L}
              }
              \newcommand\rend[1]{
                  node[letter, fill=\colorblocktwo, label=#1:{\coloridtwo$\betterid{g}{C3}{3}$}] {D}
              }
              \newcommand\nodel[1]{
                  node[letter, fill=\colorblockthree, label=#1:{\coloridthree$\betterid{t}{D3}{0}$}] {L}
              }

              \newcommand\initialstate[3]{
                  \path
                      #1
                      ++#2
                      ++(0:0.5)
                      ++(#3:0.5) node[epoch] {\epoch{0}}
                      ++(0:1.05 * \widthoriginepoch) \nodew{-#3}
                      ++(0:\widthletter) \nodeo{#3}
                      ++(0:\widthletter) \noder{-#3}
                      ++(0:\widthletter) \noded{#3};
              }

              \newcommand\renc[3]{
                  \path
                      #1
                      ++#2
                      ++(0:0.5)
                      ++(#3:0.5) node[epoch] {\epoch{C3}}
                      ++(0:1.3 * \widthepoch) \renword{-#3};
              }

              \newcommand\recvrenl[3]{
                  \path
                      #1
                      ++#2
                      ++(0:0.5)
                      ++(#3:0.5) node[epoch] {\epoch{C3}}
                      ++(0:1.3 * \widthepoch) \renwor{-#3}
                      ++(0:1.07 * \widthblock) \renl{#3}
                      ++(0:\widthletter) \rend{-#3};
              }

              \newcommand\insl[3]{
                  \path
                      #1
                      ++#2
                      ++(0:0.5)
                      ++(#3:0.5) node[epoch] {\epoch{0}}
                      ++(0:1.05 * \widthoriginepoch) \nodew{-#3}
                      ++(0:\widthletter) \nodeo{#3}
                      ++(0:\widthletter) \noder{-#3}
                      ++(0:\widthletter) \nodel{#3}
                      ++(0:\widthletter) \noded{#3};
              }

              \newcommand\offsetc{ (90:0.7) }
              \newcommand\offsetd{ (-90:0.7) }

              \path
                  node {\textbf{C}}
                  ++(0:0.5) node (c) {}
                  +(0:23) node (c-end) {}
                  +(0:1) node[point] (c-initial) {}
                  +(0:8) node[point, label=-170:{$\trm{ren}()$}, label={[xshift=0pt]-10:{$\trm{ren}(\betterepoch{0}, C,3)$}}] (c-ren-C3) {}
                  +(0:17) node[point] (c-recv-ins-l) {}
                  +(0:22) node (c-final) {};

              \initialstate{(c-initial)}{\offsetc}{90};
              \renc{(c-ren-C3)}{\offsetc}{90};
              \recvrenl{(c-recv-ins-l)}{\offsetc}{90};

              \draw[dotted] (c) -- (c-initial) (c-final) -- (c-end);
              \draw[->, thick] (c-initial) --  (c-ren-C3) -- (c-recv-ins-l) -- (c-final);

              \path
                  ++(270:3) node {\textbf{D}}
                  ++(0:0.5) node (d) {}
                  +(0:23) node (d-end) {}
                  +(0:1) node[point] (d-initial) {}
                  +(0:8) node[point, label=170:{$\trm{ins}(R \prec L \prec D)$}, label={[xshift=50pt]10:{$\trm{ins}(\betterepoch{0}, {\coloridthree\betterid{t}{D3}{0}},L)$}}] (d-ins-l) {}
                  +(0:22) node (d-final) {};

              \initialstate{(d-initial)}{\offsetd}{-90};
              \insl{(d-ins-l)}{\offsetd}{-90};

              \draw[dotted] (d) -- (d-initial) (d-final) -- (d-end);
              \draw[->, thick] (d-initial) -- (d-ins-l) -- (d-final);

              \draw[->, dashed, shorten >= 1] (d-ins-l) -- (c-recv-ins-l);
          \end{tikzpicture}
          }
          \label{fig:revertRenameId-causal-setup-1}
      \end{minipage}}
    \hfil
    \subfloat[Génération d'opérations $\trm{insert}$ postérieures à l'opération $\trm{rename}$]{
      \begin{minipage}{\linewidth}
        \centering
        \resizebox{\columnwidth}{!}{
            \begin{tikzpicture}
                \newcommand\nodew[1]{
                    node[letter, label=#1:{$\betterid{g}{C1}{0}$}] {W}
                }
                \newcommand\nodeo[1]{
                    node[letter, fill=\colorblockone, label=#1:{\coloridone$\betterid{k}{D1}{0}$}] {O}
                }
                \newcommand\noder[1]{
                    node[letter, label=#1:{$\betterid{n}{C2}{0}$}] {R}
                }
                \newcommand\noded[1]{
                node[letter, label=#1:{$\betterid{v}{D2}{0}$}] {D}
                }
                \newcommand\renword[1]{
                    node[block, fill=\colorblocktwo, label=#1:{\coloridtwo$\betterid{g}{C3}{0..2}$}] {WORD}
                }
                \newcommand\renwor[1]{
                    node[block, fill=\colorblocktwo, label=#1:{\coloridtwo$\betterid{g}{C3}{0..2}$}] {WOR}
                }
                \newcommand\renl[1]{
                    node[letter, fill=\colorblockfour, label=#1:{\coloridfour$\betterid{g}{C3}{2}\betterid{t}{D3}{0}$}] {L}
                }
                \newcommand\rend[1]{
                    node[letter, fill=\colorblocktwo, label=#1:{\coloridtwo$\betterid{g}{C3}{3}$}] {D}
                }
                \newcommand\renx[1]{
                    node[letter, label=#1:{$\betterid{g}{C3}{2}\betterid{e}{C4}{0}$}] {X}
                }
                \newcommand\reny[1]{
                    node[letter, label=#1:{$\betterid{g}{C3}{2}\betterid{u}{C5}{0}$}] {Y}
                }
                \newcommand\nodel[1]{
                    node[letter, fill=\colorblockthree, label=#1:{\coloridthree$\betterid{t}{D3}{0}$}] {L}
                }
                \newcommand\renworld[1]{
                    node[block, fill=\colorblockfive, label=#1:{\coloridfive$\betterid{k}{D4}{0..4}$}] {WORLD}
                }

                \newcommand\initialstatec[3]{
                    \path
                        #1
                        ++#2
                        ++(0:0.5)
                        ++(#3:0.5) node[epoch] {\epoch{C3}}
                        ++(0:1.3 * \widthepoch) \renwor{-#3}
                        ++(0:1.07 * \widthblock) \renl{#3}
                        ++(0:\widthletter) \rend{-#3};
                }

                \newcommand\insx[3]{
                    \path
                        #1
                        ++#2
                        ++(0:0.5)
                        ++(#3:0.5) node[epoch] {\epoch{C2}}
                        ++(0:1.3 * \widthepoch) \renwor{-#3}
                        ++(0:1.07 * \widthblock) \renx{#3}
                        ++(0:\widthletter) \renl{-#3}
                        ++(0:\widthletter) \rend{#3};
                }

                \newcommand\insy[3]{
                    \path
                        #1
                        ++#2
                        ++(0:0.5)
                        ++(#3:0.5) node[epoch] {\epoch{C2}}
                        ++(0:1.3 * \widthepoch) \renwor{-#3}
                        ++(0:1.07 * \widthblock) \renx{#3}
                        ++(0:\widthletter) \renl{-#3}
                        ++(0:\widthletter) \reny{#3}
                        ++(0:\widthletter) \rend{-#3};
                }

                \newcommand\insl[3]{
                    \path
                        #1
                        ++#2
                        ++(0:0.5)
                        ++(#3:0.5) node[epoch] {\epoch{0}}
                        ++(0:1.05 * \widthoriginepoch) \nodew{-#3}
                        ++(0:\widthletter) \nodeo{#3}
                        ++(0:\widthletter) \noder{-#3}
                        ++(0:\widthletter) \nodel{#3}
                        ++(0:\widthletter) \noded{#3};
                }

                \newcommand\rendworld[3]{
                    \path
                        #1
                        ++#2
                        ++(0:0.5)
                        ++(#3:0.5) node[epoch] {\epoch{D4}}
                        ++(0:1.3 * \widthepoch) \renworld{-#3};
                }

                \newcommand\offsetc{ (90:0.7) }
                \newcommand\offsetd{ (-90:0.7) }

                \path
                    node {\textbf{C}}
                    ++(0:0.5) node (c) {}
                    +(0:23) node (c-end) {}
                    +(0:1) node[point] (c-initial) {}
                    +(0:8) node[point, label=-170:{$\trm{ins}(R \prec X \prec L)$}, label={[xshift=0pt]-10:{$\trm{ins}(\betterepoch{C3}, \betterid{g}{C3}{2}\betterid{e}{C4}{0},X)$}}] (c-ins-x) {}
                    +(0:17)  node[point, label=-170:{$\trm{ins}(L \prec Y \prec D)$}, label={[xshift=0pt]-10:{$\trm{ins}(\betterepoch{C3}, \betterid{g}{C3}{2}\betterid{u}{C5}{0},X)$}}] (c-ins-y) {}
                    +(0:22) node (c-final) {};

                \initialstatec{(c-initial)}{\offsetc}{90};
                \insx{(c-ins-x)}{\offsetc}{90};
                \insy{(c-ins-y)}{\offsetc}{90};

                \draw[dotted] (c) -- (c-initial) (c-final) -- (c-end);
                \draw[->, thick] (c-initial) --  (c-ins-x) -- (c-ins-y) -- (c-final);

                \path
                    ++(270:3) node {\textbf{D}}
                    ++(0:0.5) node (d) {}
                    +(0:23) node (d-end) {}
                    +(0:1) node[point] (d-initial) {}
                    +(0:17) node[point, label=170:{$\trm{ren}()$}, label={[xshift=0pt]10:{$\trm{ren}(\betterepoch{0}, D,4)$}}] (d-ren-d4) {}
                    +(0:22) node (d-final) {};

                \insl{(d-initial)}{\offsetd}{-90};
                \rendworld{(d-ren-d4)}{\offsetd}{-90};

                \draw[dotted] (d) -- (d-initial) (d-final) -- (d-end);
                \draw[->, thick] (d-initial) -- (d-ren-d4) -- (d-final);
            \end{tikzpicture}
            }
            \label{fig:revertRenameId-causal-setup-2}
      \end{minipage}}
    \hfil
    \subfloat[Annulation de l'opération $\trm{rename}$ précédente au profit d'une opération $\trm{rename}$ concurrente]{
      \begin{minipage}{\linewidth}
    \centering
    \resizebox{\columnwidth}{!}{
        \begin{tikzpicture}
            \newcommand\nodew[1]{
                node[letter, label=#1:{$\betterid{g}{C1}{0}$}] {W}
            }
            \newcommand\nodeo[1]{
                node[letter, fill=\colorblockone, label=#1:{\coloridone$\betterid{k}{D1}{0}$}] {O}
            }
            \newcommand\noder[1]{
                node[letter, label=#1:{$\betterid{n}{C2}{0}$}] {R}
            }
            \newcommand\noded[1]{
            node[letter, label=#1:{$\betterid{v}{D2}{0}$}] {D}
            }
            \newcommand\renword[1]{
                node[block, fill=\colorblocktwo, label=#1:{\coloridtwo$\betterid{g}{C3}{0..2}$}] {WORD}
            }
            \newcommand\renwor[1]{
                node[block, fill=\colorblocktwo, label=#1:{\coloridtwo$\betterid{g}{C3}{0..2}$}] {WOR}
            }
            \newcommand\renl[1]{
                node[letter, fill=\colorblockfour, label=#1:{\coloridfour$\betterid{g}{C3}{2}\betterid{t}{D3}{0}$}] {L}
            }
            \newcommand\rend[1]{
                node[letter, fill=\colorblocktwo, label=#1:{\coloridtwo$\betterid{g}{C3}{3}$}] {D}
            }
            \newcommand\renx[1]{
                node[letter, label=#1:{$\betterid{g}{C3}{2}\betterid{e}{C4}{0}$}] {X}
            }
            \newcommand\reny[1]{
                node[letter, label=#1:{$\betterid{g}{C3}{2}\betterid{u}{C5}{0}$}] {Y}
            }
            \newcommand\nodel[1]{
                node[letter, fill=\colorblockthree, label=#1:{\coloridthree$\betterid{t}{D3}{0}$}] {L}
            }
            \newcommand\renworld[1]{
                node[block, fill=\colorblockfive, label=#1:{\coloridfive$\betterid{k}{D4}{0..4}$}] {WORLD}
            }
            \newcommand\nodex[1]{
                node[letter, fill=\colorblockone, label=#1:{\coloridone$\betterid{n}{C2}{0}\bott\betterid{e}{C4}{0}$}] {X}
            }
            \newcommand\nodey[1]{
                node[letter, fill=\colorblockone, label=#1:{\coloridone$\betterid{u}{C5}{0}$}] {Y}
            }
            \newcommand\rendwor[1]{
                node[block, fill=\colorblockfive, label=#1:{\coloridfive$\betterid{k}{D4}{0..2}$}] {WOR}
            }
            \newcommand\rendx[1]{
                node[letter, fill=\colorblockfour, label=#1:{\coloridfour$\betterid{k}{D4}{2}\bott\betterid{e}{C4}{0}$}] {X}
            }
            \newcommand\rendl[1]{
                node[letter, fill=\colorblockfive, label=#1:{\coloridfive$\betterid{k}{D4}{3}$}] {L}
            }
            \newcommand\rendy[1]{
                node[letter, fill=\colorblockfour, label=#1:{\coloridfour$\betterid{k}{D4}{3}\betterid{u}{C5}{0}$}] {X}
            }
            \newcommand\rendd[1]{
                node[letter, fill=\colorblockfive, label=#1:{\coloridfive$\betterid{k}{D4}{4}$}] {D}
            }

            \newcommand\insxy[3]{
                \path
                    #1
                    ++#2
                    ++(0:0.5)
                    ++(#3:0.5) node[epoch] {\epoch{C2}}
                    ++(0:1.3 * \widthepoch) \renwor{-#3}
                    ++(0:1.07 * \widthblock) \renx{#3}
                    ++(0:\widthletter) \renl{-#3}
                    ++(0:\widthletter) \reny{#3}
                    ++(0:\widthletter) \rend{-#3};
            }

            \newcommand\finalstatea[3]{
                \path
                    #1
                    ++#2
                    ++(0:0.5)
                    ++(#3:0.5) node[epoch] {\epoch{C2}}
                    ++(0:1.3 * \widthepoch) \renwor{-#3}
                    ++(0:1.07 * \widthblock) \renx{#3}
                    ++(0:\widthletter) \renl{-#3}
                    ++(0:\widthletter) \reny{#3}
                    ++(0:\widthletter) \rend{-#3}
                    ++(0:\widthletter) node (eC2-right) {}
                    ++(0:1.5) node[epoch] (e0-left) {\epoch{0}}
                    ++(0:1.05 * \widthoriginepoch) \nodew{-#3}
                    ++(0:\widthletter) \nodeo{#3}
                    ++(0:\widthletter) \noder{-#3}
                    ++(0:\widthletter) \nodex{#3}
                    ++(0:\widthletter) \nodel{-#3}
                    ++(0:\widthletter) \nodey{#3}
                    ++(0:\widthletter) \noded{-#3}
                    ++(0:\widthletter) node (e0-right) {}
                    ++(0:1.5) node[epoch] (eD4-left) {\epoch{B3}}
                    ++(0:1.3 * \widthepoch) \rendwor{#3}
                    ++(0:1.07 * \widthblock) \rendx{-#3}
                    ++(0:\widthletter) \rendl{#3}
                    ++(0:\widthletter) \rendy{-#3}
                    ++(0:\widthletter) \rendd{#3};

                    \draw[->, loosely dash dot, shorten >= 1] (eC2-right) --  node[above, align=center]{\emph{revert}\\ \emph{to} \epoch{0}} (e0-left);
                    \draw[->, loosely dash dot, shorten >= 1] (e0-right) --  node[above, align=center]{$\trm{rename}$\\ \emph{to} \epoch{B3}} (eD4-left);
            }

            \newcommand\insl[3]{
                \path
                    #1
                    ++#2
                    ++(0:0.5)
                    ++(#3:0.5) node[epoch] {\epoch{0}}
                    ++(0:1.05 * \widthoriginepoch) \nodew{-#3}
                    ++(0:\widthletter) \nodeo{#3}
                    ++(0:\widthletter) \noder{-#3}
                    ++(0:\widthletter) \nodel{#3}
                    ++(0:\widthletter) \noded{#3};
            }

            \newcommand\rendworld[3]{
                \path
                    #1
                    ++#2
                    ++(0:0.5)
                    ++(#3:0.5) node[epoch] {\epoch{D4}}
                    ++(0:1.3 * \widthepoch) \renworld{-#3};
            }

            \newcommand\offsetc{ (90:0.7) }
            \newcommand\offsetd{ (-90:0.7) }

            \path
                node {\textbf{C}}
                ++(0:0.5) node (c) {}
                +(0:29) node (c-end) {}
                +(0:1) node[point] (c-initial) {}
                +(0:8) node[point] (c-recv-ren-d4) {}
                +(0:28) node (c-final) {};

            \insxy{(c-initial)}{\offsetc}{90};
            \finalstatea{(c-recv-ren-d4)}{\offsetc}{90};

            \draw[dotted] (c) -- (c-initial) (c-final) -- (c-end);
            \draw[->, thick] (c-initial) --  (c-recv-ren-d4) -- (c-final);

            \path
                ++(270:3) node {\textbf{D}}
                ++(0:0.5) node (d) {}
                +(0:29) node (d-end) {}
                +(0:1) node[point] (d-initial) {}
                +(0:28) node (d-final) {};

            \rendworld{(d-initial)}{\offsetd}{-90};

            \draw[dotted] (d) -- (d-initial) (d-final) -- (d-end);
            \draw[->, thick] (d-initial) -- (d-final);

            \draw[->, dashed, shorten >= 1] (d-initial) -- (c-recv-ren-d4);
        \end{tikzpicture}
        }
        \label{fig:revertRenameId-causal-revert}
      \end{minipage}}
    \caption{Annulation d'une opération $\trm{rename}$ intégrée précèdemment en présence d'identifiants insérés postérieurement}
    \label{fig:revertRenameId-causal}
\end{figure}

Dans cet exemple, les noeuds C et D répliquent une même séquence contenant les éléments "WORD".
Dans la \autoref{fig:revertRenameId-causal-setup-1}, le noeud C commence par renommer son état.
En concurrence, le noeud D insère l'élément "L" entre les éléments "R" et "D".
L'opération $\trm{insert}$ correspondante est livrée au noeud C, qui l'intègre en suivant le comportement présenté dans la \autoref{sec:ops-concurrent-to-rename}.

Dans la \autoref{fig:revertRenameId-causal-setup-2}, le noeud C procède à l'insertion de l'élément "X" entre les éléments "R" et "L", puis à l'insertion de l'élément "Y" entre les éléments "L" et "D".
Ces opérations $\trm{insert}$ dépendent donc causalement de l'opération $\trm{rename}$ effectuée précédemment par C.
En parallèle, le noeud D effectue un renommage de son état.

Dans la \autoref{fig:revertRenameId-causal-revert}, l'opération $\trm{rename}$ correspondante est livrée au noeud C.
L'époque $\betterepoch{D4}$ introduite par cette opération est prioritaire par rapport à l'époque courante $\betterepoch{C3}$ du noeud C, le noeud C procède donc au renommage de son état vers l'époque $\betterepoch{D4}$.

Pour cela, le noeud C calcule l'état équivalent de son état courant à l'époque $\betterepoch{0}$ grâce à \texttt{revertRenameId}.
Nous nous intéressons ici à la manière dont cet algorithme procède pour les identifiants $\betterid{g}{C3}{2}\betterid{e}{C4}{0}$ et $\betterid{g}{C3}{2}\betterid{u}{C5}{0}$.

Nous distinguons deux catégories d'identifiants générés causalement après l'opération $\trm{rename}$ :
\begin{enumerate}
    \item \label{item:id-causal-rename-unknown}
        Les identifiants dont la valeur ne permet pas de déterminer leur moment de génération par rapport à l'opération $\trm{rename}$ (\eg $\betterid{g}{C3}{2}\betterid{u}{C5}{0}$), \ie la valeur ne permet de déterminer si l'identifiant a été inséré en concurrence de l'opération $\trm{rename}$ ou de façon postérieure à cette dernière.
    \item \label{item:id-causal-rename-determined}
        Les identifiants dont la valeur indique qu'ils ont été généré de façon postérieure à l'opération $\trm{rename}$ (\eg $\betterid{g}{C3}{2}\betterid{e}{C4}{0}$).
\end{enumerate}
Nous présentons ci-dessous comment \texttt{revertRenameId} gère chacun de ces cas.

\paragraph{Cas \ref{item:id-causal-rename-unknown}}

Comme indiqué précédemment, \texttt{revertRenameId} vérifie pour un identifiant donné $\trm{newId}$ (\eg $\betterid{g}{C3}{2}\betterid{u}{C5}{0}$) si sa $\trm{tail}$ ($\betterid{u}{C5}{0}$), \ie son ou ses tuples à l'exception du premier, est comprise entre son $\trm{predId}$ et $\trm{succId}$.
Dans le cas de $\betterid{g}{C3}{2}\betterid{u}{C5}{0}$, nous avons respectivement $\betterid{n}{C2}{0}$ et $\betterid{v}{D2}{0}$ comme $\trm{predId}$ et $\trm{succId}$ (les identifiants d'indices 2 et 3 dans l'\emph{ancien état} $[\betterid{g}{C1}{0},\betterid{k}{D1}{0},\betterid{n}{C2}{0},\betterid{v}{D2}{0}]$).
Nous avons donc $\trm{tail} \in ]\trm{predId},\trm{succId}[$.

Ce cas de figure est le même que celui présenté dans \autoref{sec:reverting-rename-ops-id-inserted-concurrently}.
Dans certains cas, il n'est donc pas possible de distinguer un identifiant inséré de manière postérieur à l'opération $\trm{rename}$ d'un identifiant inséré de manière concurrente à cette dernière, à moins d'ajouter une métadonnée.

Cependant, il n'est pas nécessaire de différencier ces deux cas : nous pouvons annuler l'effet de l'opération $\trm{rename}$ sur l'identifiant inséré par la suite de la même manière que nous annulons l'effet de l'opération $\trm{rename}$ sur les identifiants insérés en concurrence, \ie en retournant la valeur $\trm{tail}$.
En effet, cette méthode nous permet de préserver la relation d'ordre de ces identifiants ($\betterid{g}{C3}{2}\betterid{u}{C5}{0}$) avec les autres identifiants existants ($\betterid{g}{C3}{2}$, $\betterid{g}{C3}{2}\betterid{t}{D3}{0}$ et $\betterid{g}{C3}{3}$), de l'époque enfant ($\betterepoch{C2}$) à l'époque parent ($\betterepoch{0}$).

Pour $\betterid{g}{C3}{2}\betterid{u}{C5}{0}$, \texttt{revertRenameId} retourne la valeur $\betterid{u}{C5}{0}$.
\texttt{revertRenameId} retourne pour les identifiants $\betterid{g}{C3}{2}$ et $\betterid{g}{C3}{3}$ des éléments "R" et "D" leur valeur d'origine, $\betterid{n}{C2}{0}$ et $\betterid{v}{D2}{0}$ (\autoref{sec:reverting-rename-ops-id-in-former-state}).
Pour l'identifiant $\betterid{g}{C3}{2}\betterid{t}{D3}{0}$ de l'élément "L", \texttt{revertRenameId} retourne $\betterid{t}{D3}{0}$ (\autoref{sec:reverting-rename-ops-id-inserted-concurrently}).
Ainsi, l'annulation de l'effet de l'opération $\trm{rename}$ préserve à $\betterepoch{0}$ l'ordre des éléments $R \prec L \prec Y \prec D$ puisque nous avons :
\[ \betterid{n}{C2}{0} \lid \betterid{t}{D3}{0} \lid \betterid{u}{C5}{0} \lid \betterid{v}{D2}{0}\]

% Il convient de noter que le filtre présenté ci-dessus pour détecter les identifiants générés en concurrence à l'opération $\trm{rename}$ présente des cas de faux-positifs.
% En effet, bien qu'il permette de détecter les identifiants insérés en concurrence à l'opération $\trm{rename}$, il englobe aussi une partie des identifiants insérés causalement après cette dernière.
% Pour illustrer ce point, reprenons l'exemple illustré par la \autoref{fig:revertRenameId}.
% Avant la réception de l'opération $\trm{rename}$ générée par le noeud B, considérons que le noeud A procède à l'insertion d'un nouvel élément entre les élément "L" et "L".
% Le noeud A génère alors un nouvel identifiant $\trm{newId}$ : $\betterid{i}{A2}{1}\betterid{i}{B1}{0}\betterid{t}{A3}{0}$.
% Ce dernier respecte notre contrainte d'ordre suivante :
% \[ \betterid{i}{A2}{1}\betterid{i}{B1}{0}\betterid{m}{B2}{0} \lid \betterid{i}{A2}{1}\betterid{i}{B1}{0}\betterid{t}{A3}{0} \lid \betterid{i}{A2}{2} \]

% Lors de l'annulation de l'effet de l'opération $\trm{rename}$, de manière identique à précédemment, \texttt{revertRenameId} décompose cet identifiant en $\trm{newPredId}$ ($\betterid{i}{A2}{1}$) et en $\trm{tail}$ ($\betterid{i}{B1}{0}\betterid{t}{A3}{0}$), détermine les valeurs de $\trm{predId}$ ($\betterid{i}{B1}{0}\betterid{f}{A1}{0}$) et $\trm{succId}$ ($\betterid{i}{B1}{1}$) et vérifie que $\trm{tail} \in ]\trm{predId},\trm{succId}[$.
% Ainsi, \texttt{revertRenameId} retourne la valeur de $\trm{tail}$ : $\betterid{i}{B1}{0}\betterid{t}{A3}{0}$.

% Cette valeur de retour satisfait notre seule contrainte portant sur cet identifiant, \ie la propriété de préservation de l'ordre \cf{prop:order}.
% En effet, elle préserve l'ordre existant entre les identifiants de l'époque \emph{fille} à l'époque \emph{parente}, que ça soit $\trm{predId}$, $\trm{succId}$ ou les autres identifiants renommés à l'aide de cette même stratégie (\eg $\betterid{i}{B1}{0}\betterid{m}{B2}{0} \lid \betterid{i}{B1}{0}\betterid{t}{A3}{0} \lid \betterid{i}{B1}{1}$).

% Le second sous-cas correspond au cas où nous avons $\trm{tail} < \trm{predId}$.
% $\trm{newId}$ ne peut avoir été inséré que causalement après l'opération $\trm{rename}$ (\ie le cas \ref{item:revert-rename-3}).
% Nous avons alors :
% \[\trm{newId} \in ]\trm{newPredId}, \trm{newPredId~predId}[\]
% Puisque $\trm{newId}$ a été inséré causalement après l'opération $\trm{rename}$, il n'existe pas de contrainte sur la valeur à retourner autre que la préservation de l'ordre \cf{prop:order}.
% Pour gérer ce cas, nous introduisons deux nouveaux tuples exclusifs au mécanisme de renommage : $\trm{minTuple}$ et $\trm{maxTuple}$, notés respectivement $\bott$ et $\topt$.
% Ils sont respectivement le tuple minimal et maximal utilisables pour générer des identifiants\footnote{Concrètement, il s'agit de tuples ayant pour $\trm{pos}$ des valeurs respectivement inférieure et supérieure à l'ensemble des valeurs de $\trm{pos}$ utilisables lors de la génération d'un nouvel identifiant.}.
% En utilisant $\trm{minTuple}$, \texttt{revertRenameId} est capable de renvoyer une valeur pour $\trm{id}$ adaptée à l'ordre souhaité (avec $\trm{id} = \trm{predId~\bott~tail}$, ligne \ref{alg:revertRenameId-case-iii}).
% Nous justifions ce comportement à l'aide de la \autoref{fig:revertRenameId-mintuple}.

% Dans la \autoref{fig:revertRenameId-mintuple-revert}, l'opération $\trm{rename}$ de D est livrée au noeud C.
% L'époque introduite par cette opération étant prioritaire par rapport à l'époque actuelle de C (\epoch{C2} \lepoch \epoch{D4}), le noeud C procède à l'annulation de son opération $\trm{rename}$.\\

% L'identifiant qui nous intéresse ici est l'identifiant inséré causalement après l'opération $\trm{rename}$ annulée : \id{k}{C2}{1}\id{i}{C3}{0}.
% Cet identifiant est compris entre les identifiants suivants :
% \[k^{C2}_{1} <_{id} k^{C2}_{1}i^{C3}_{0} <_{id} k^{C2}_{1}n^{C1}_{0}e^{D3}_{0}\]
% D'après les règles présentées précédemment :
% \begin{itemize}
%   \item \id{k}{C2}{1} est transformé en \id{n}{C1}{0} (cas \ref{item:revert-rename-1}, ligne \ref{alg:revertRenameId-case-i}).
%   \item \id{k}{C2}{1}\id{n}{C1}{0}\id{e}{D3}{0} est transformé en \id{n}{C1}{0}\id{e}{D3}{0} (cas \ref{item:revert-rename-2}, ligne \ref{alg:revertRenameId-case-ii}).
% \end{itemize}
% Nous devons générer un identifiant $\trm{id}$ à partir de \id{k}{C2}{1}\id{i}{C3}{0} tel que :
% \[n^{C1}_{0} <_{id} \trm{id} <_{id} n^{C1}_{0}e^{D3}_{0}\]

% Utiliser $\trm{predId}$ (\id{n}{C1}{0}) en tant que préfixe de $\trm{id}$ nous permet de garantir que \id{n}{C1}{0} $\lid$ $\trm{id}$.
% Cependant, appliquer la même stratégie que pour le cas \ref{item:revert-rename-2} pour générer $\trm{id}$ transgresserait la propriété de préservation de l'ordre.
% En effet, nous obtiendrions $\trm{id} = $ \id{n}{C1}{0}\id{i}{C3}{0}, or \id{n}{C1}{0}\id{i}{C3}{0} $\nless_{id}$ \id{n}{C1}{0}\id{e}{D3}{0}.

% Ainsi, nous devons choisir un autre préfixe dans cette situation, notamment pour garantir que l'identifiant résultant sera plus petit que les identifiants suivants.
% C'est pour cela que nous introduisons $\trm{minTuple}$.
% En concaténant $\trm{predId}$ et le tuple minimal, nous obtenons un préfixe nous permettant à la fois de garantir que \id{n}{C1}{0} $\lid$ $\trm{id}$ et que $\trm{id}$ $\lid$ \id{n}{C1}{0}\id{e}{D3}{0}.
% Nous obtenons donc $\trm{id} = $ \id{n}{C1}{0}$\bott$\id{i}{C3}{0}, qui respecte l'ordre souhaité.\\

% Finalement, le dernier sous-cas est le pendant du sous-cas précédent et se produit lorsque nous avons $\trm{succId} < \trm{tail}$.
% Nous avons alors :
% \[\trm{newId} \in ]\trm{newPredId~succId}, \trm{newSuccId}[\]
% La stratégie pour gérer ce cas est similaire et consiste à ajouter un préfixe pour créer l'ordre souhaité.
% Pour générer ce préfixe, \texttt{revertRenameId} utilise  $\trm{predOfSuccId}$ et $\trm{maxTuple}$.
% $\trm{predOfSuccId}$ est obtenu en décrémentant le dernier offset de $\trm{succId}$.
% Ainsi, pour préserver l'ordre souhaité, \texttt{revertRenameId} renvoie $\trm{id}$ avec $\trm{id} = \trm{predOfSuccId~\topt~tail}$.

% Une fois que le noeud A a converti son état à un état équivalent à l'époque \epoch{0} en utilisant \texttt{revertRenameId}, il peut appliquer \texttt{renameId} pour calculer l'état correspondant à \epoch{B3}.

\subsubsection{Notes additionnelles}

Comme pour l'\autoref{alg:renameId}, l'\autoref{alg:revertRenameId} ne présente seulement que le cas principal de \texttt{revertRenameId}.
Il s'agit du cas où l'identifiant à restaurer appartient à l'intervalle des identifiants renommés $\trm{newFirstId}$ \leqid $\trm{id}$ \leqid $\trm{newLastId}$).
Les fonctions pour gérer les cas restants sont présentées dans l'\autoref{app:revert-rename-id}.\\

Notons que \texttt{renameId} et \texttt{revertRenameId} ne sont pas des fonctions réciproques.
\texttt{revertRenameId} restaure à leur valeur initiale les identifiants insérés causalement avant ou de manière concurrente à l'opération $\trm{rename}$.
Par contre, \texttt{renameId} ne fait pas de même pour les identifiants insérés causalement après l'opération $\trm{rename}$.
Rejouer une opération $\trm{rename}$ précédemment annulée altère donc ces identifiants.
Cette modification peut entraîner une divergence entre les noeuds, puis qu'un même élément sera désigné par des identifiants différents.

Ce problème est toutefois évité dans notre système grâce à la relation \emph{priority} utilisée.
Puisque la relation \emph{priority} est définie en utilisant l'ordre lexicographique sur le chemin des époques dans l'\emph{arbre des époques}, les noeuds se déplacent seulement vers l'époque la plus à droite de l'\emph{arbre des époques} lorsqu'ils changent d'époque.
Les noeuds évitent donc d'aller et revenir entre deux mêmes époques, et donc d'annuler et rejouer les opérations $\trm{rename}$ correspondantes.
