\label{sec:def-rename-op}

L'objectif de l'opération $\trm{rename}$ est de réassigner de nouveaux identifiants aux éléments de la séquence répliquée sans modifier son contenu.
Puisque les identifiants sont des métadonnées utilisées par la structure de données uniquement afin de résoudre les conflits, les utilisateurs ignorent leur existence.
Les opérations $\trm{rename}$ sont donc des opérations systèmes : elles sont émises et appliquées par les noeuds en coulisses, sans aucune intervention des utilisateurs.

Afin de garantir le respect du modèle de cohérence \ac{SEC}, nous définissons plusieurs propriétés de sécurité que l'opération $\trm{rename}$ doit respecter.
Ces propriétés sont inspirées principalement par celles proposées dans \cite{zawirski:hal-01248197}.

\begin{property}(Déterminisme)
  Les opérations $\trm{rename}$ sont intégrées par les noeuds sans aucune coordination.
  Pour assurer que l'ensemble des noeuds atteigne un état équivalent à terme, une opération $\trm{rename}$ donnée doit toujours générer le même nouvel identifiant à partir de l'identifiant courant.
\end{property}

\begin{property}(Préservation de l'intention de l'utilisateur)
  \label{prop:rename-op-intention-preservation}
  Bien que l'opération $\trm{rename}$ n'incarne pas elle-même une intention de l'utilisateur, elle ne doit pas entrer en conflit avec les modifications des utilisateurs.
  Notamment, les opérations $\trm{rename}$ ne doivent pas annuler ou altérer le résultat d'opérations $\trm{insert}$ et $\trm{remove}$ du point de vue des utilisateurs.
\end{property}

\begin{property}(Séquence bien formée)
  La séquence répliquée doit être bien formée.
  Appliquée une opération $\trm{rename}$ sur une séquence bien formée doit produire une nouvelle séquence bien formée.
  Une séquence bien formée doit respecter les propriétés suivantes :
  \begin{itemize}[noitemsep]
    \item[~]
    \begin{subproperty}(Préservation de l'unicité)
      Chaque identifiant doit être unique.
      Donc, pour une opération $\trm{rename}$ donnée, chaque identifiant doit être associé à un nouvel identifiant unique.
    \end{subproperty}
    \item[~]
    \begin{subproperty}(Préservation de l'ordre)
      \label{prop:order}
      Les éléments de la séquence doivent être ordonnés en fonction de leur identifiants.
      L'ordre existant entre les identifiants initiaux doit donc être préservé par l'opération $\trm{rename}$.
    \end{subproperty}
  \end{itemize}
\end{property}

\begin{property}(Commutativité avec les opérations concurrentes)
  \label{prop:commutativity}
  Les opérations concurrentes peuvent être livrées dans des ordres différents à chaque noeud.
  Afin de garantir la convergence des réplicas, l'ordre d'application d'un ensemble d'opérations concurrentes ne doit pas avoir d'impact sur l'état obtenu.
  L'opération $\trm{rename}$ doit donc être commutative avec n'importe quelle opération concurrente.
\end{property}

La \autoref{prop:commutativity} est particulièrement difficile à assurer.
Cette difficulté est dûe au fait que les opérations $\trm{rename}$ modifient les identifiants assignés aux éléments.
Cependant, les autres opérations telles que les opérations $\trm{insert}$ et $\trm{remove}$ reposent sur ces identifiants pour spécifier où insérer les éléments ou lesquels supprimer.
Les opérations $\trm{rename}$ sont donc intrinséquement incompatibles avec les opérations $\trm{insert}$ et $\trm{remove}$ concurrentes.
De la même manière, des opérations $\trm{rename}$ concurrentes peuvent réassigner des identifiants différents à des mêmes éléments.
Les opérations $\trm{rename}$ concurrentes ne sont donc pas commutatives.
Par conséquent, il est nécessaire de concevoir et d'utiliser des méthodes de résolution de conflits pour assurer la \autoref{prop:commutativity}.

Dans un souci de simplicité, la présentation de l'opération $\trm{rename}$ est divisée en deux parties.
Dans le \autoref{sec:centralised-rls}, nous présentons l'opération $\trm{rename}$ proposée avec l'hypothèse qu'aucune opération $\trm{rename}$ concurrente ne peut être générée.
Cette hypothèse nous permet de nous concentrer sur le fonctionnement de l'opération $\trm{rename}$ elle-même ainsi que sur la gestion des opérations $\trm{insert}$ et $\trm{remove}$ concurrentes.
Ensuite, dans le \autoref{sec:distributed-rls}, nous supprimons cette hypothèse.
Nous présentons alors notre approche pour gérer les scénarios avec des opérations $\trm{rename}$ concurrentes.
