\label{sec:integration-time-standard-ops}

Nous avons ensuite comparé l'évolution du temps d'intégration des opérations standards, \ie les opérations $\trm{insert}$ et $\trm{remove}$\footnote{Puisque les opérations $\trm{insert}$ et $\trm{remove}$ partagent la même complexité en temps \cf{sec:validation-time-complexity}, nous avons seulement utilisé des opérations $\trm{insert}$ dans nos benchmarks.}, sur des documents LogootSplit et RenamableLogootSplit.
Puisque nous nous intéressons au surcoût introduit par le mécanisme de renommage, \ie par le système d'époques et le renommage éventuel d'identifiants, nous ne mesurons uniquement que le temps d'intégration des opérations, \ie le temps mis par la séquence répliquée pour appliquer une modification donnée.
La \autoref{fig:evolution-integration-time-insert} présente les résultats obtenus.

\begin{figure}[!ht]
  \centering
  \subfloat[Modifications locales]{
      \includegraphics[width=0.7\columnwidth]{img/integration-time-boxplot-local-operations-without-outliers.pdf}
      \label{fig:evolution-integration-time-local-insert}}
  \hfil
  \subfloat[Modifications distantes]{
      \includegraphics[width=0.7\columnwidth]{img/integration-time-boxplot-remote-operations-without-outliers.pdf}
      \label{fig:evolution-integration-time-remote-insert}}
  \caption{Temps d'intégration des opérations standards}
  \label{fig:evolution-integration-time-insert}
\end{figure}

Les complexités en temps des algorithmes d'intégration des opérations étant différentes selon que l'opération soit \emph{locale} ou \emph{distante}, \ie soit issue du noeud lui-même ou provenant d'un autre noeud \cf{sec:validation-time-complexity}, nous distinguons les temps obtenus selon ce paramètre.
Ainsi, nous représentons l'évolution du temps d'intégration des opérations \emph{locales} et \emph{distantes} dans les figures \ref{fig:evolution-integration-time-local-insert} et \ref{fig:evolution-integration-time-remote-insert} respectivement.

De la même manière que dans la \autoref{fig:evolution-document-size}, les barres grises délimitent quand des opérations $\trm{rename}$ sont effectuées.
Les boxplots oranges correspondent aux temps d'intégration sur des documents LogootSplit, les boxplots bleues sur des documents RenamableLogootSplit.
Bien que les temps d'intégration soient initialement équivalents, les temps d'intégration sur des documents RenamableLogootSplit sont ensuite réduits par rapport à ceux de LogootSplit une fois que des opérations $\trm{rename}$ ont été intégrées.
Cette amélioration s'explique par le fait que l'opération $\trm{rename}$ optimise la représentation interne de la séquence (\ie elle réduit le nombre de blocs stockés dans l'arbre AVL).

Dans le cadre des opérations distantes, nous avons mesuré des temps d'intégration spécifiques à RenamableLogootSplit : le temps d'intégration d'opérations distantes provenant d'époques \emph{parentes} et d'époques \emph{soeurs}, respectivement affiché sous la forme de boxplots blanches et rouges dans la \autoref{fig:evolution-integration-time-remote-insert}.

Les opérations distantes provenant d'époques \emph{parentes} sont des opérations générées de manière concurrente à l'opération $\trm{rename}$ mais appliquées après cette dernière.
Puisque l'opération doit être transformée au préalable en utilisant \texttt{renameId}, nous observons un surcoût computationnel par rapport aux autres opérations.
Mais ce surcoût est compensé par l'optimisation de la représentation interne de la séquence effectuée par l'opération $\trm{rename}$.

Concernant les opérations provenant d'époques \emph{soeurs}, nous observons de nouveau un surcoût puisque les noeuds doivent tout d'abord annuler les effets de l'opération $\trm{rename}$ concurrente en utilisant \texttt{revertRenameId}.
À cause de cette étape supplémentaire, les performances de RenamableLogootSplit pour ces opérations sont comparables à celles de LogootSplit.

Pour récapituler, les fonctions de transformation ajoutent un surcoût aux temps d'intégration des opérations concurrentes aux opérations $\trm{rename}$.
Malgré ce surcoût, RenamableLogootSplit offre de meilleures performances que LogootSplit pour intégrer ces opérations grâce aux réductions de la taille de l'état effectuées par les opérations $\trm{rename}$.
Cependant, cette affirmation n'est vraie que tant que la distance entre l'époque de génération de l'opération et l'époque courante du noeud reste limitée, puisque les performances de RenamableLogootSplit dépendent linéairement de cette dernière \cf{tab:time-complexity-operations}.
Néanmoins, ce surcoût ne concerne que les opérations concurrentes aux opérations $\trm{rename}$.
Il ne concerne pas la majorité des opérations, \ie les opérations générées entre deux séries d'opérations $\trm{rename}$.
Ces opérations, elles, ne souffrent d'aucun surcoût tout en bénéficiant des réductions de taille de l'état.
