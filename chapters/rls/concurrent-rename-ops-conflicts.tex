Nous considérons à présent les scénarios avec des opérations $\trm{rename}$ concurrentes.
\autoref{fig:conflicting-rename-operations} développe le scénario décrit précédemment dans la \autoref{fig:concurrent-insert-rename-fixed}.

\begin{figure}[!ht]
  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
        \newcommand\nodeh[1]{
            node[letter, label=#1:{$\betterid{i}{B0}{0}$}] {H}
        }
        \newcommand\nodee[1]{
            node[letter, label=#1:{$\betterid{i}{B0}{0}\betterid{f}{A0}{0}$}] {E}
        }
        \newcommand\nodelo[1]{
            node[block, label=#1:{$\betterid{i}{B0}{1..2}$}] {LO}
        }
        \newcommand\renhelo[1]{
            node[block, label=#1:{$\betterid{i}{A1}{0..3}$}] {HELO}
        }
        \newcommand\nodel[1]{
            node[letter, label=#1:{$\betterid{i}{B0}{0}\betterid{m}{B1}{0}$}] {L}
        }
        \newcommand\renhe[1]{
            node[block, label=#1:{$\betterid{i}{A1}{0..1}$}] {HE}
        }
        \newcommand\renl[1]{
            node[letter, label=#1:{$\betterid{i}{A1}{1}\betterid{i}{B0}{0}\betterid{m}{B1}{0}$}] {L}
        }
        \newcommand\renlo[1]{
            node[block, label=#1:{$\betterid{i}{A1}{2..3}$}] {LO}
        }
        \newcommand\renhello[1]{
            node[block, label=#1:{$\betterid{i}{B2}{0..4}$}] {HELLO}
        }

        \newcommand\initialstate[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{0}}
                ++(0:1.05 * \widthoriginepoch) \nodeh{-#3}
                ++(0:\widthletter) \nodee{#3}
                ++(0:\widthletter) \nodelo{-#3};
        }

        \newcommand\ren[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{A1}}
                ++(0:1.3 * \widthepoch) \renhelo{-#3};
        }

        \newcommand\insl[3]{
            \path
            #1
            ++#2
            ++(0:0.5)
            ++(#3:0.5) node[epoch] {\epoch{0}}
            ++(0:1.05 * \widthoriginepoch) \nodeh{-#3}
            ++(0:\widthletter) \nodee{#3}
            ++(0:\widthletter) \nodel{-#3}
            ++(0:\widthletter) \nodelo{#3};
        }

        \newcommand\finalstatea[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{A1}}
                ++(0:1.3 * \widthepoch) \renhe{-#3}
                ++(0:\widthblock) \renl{#3}
                ++(0:\widthletter) \renlo{-#3};
        }
        \newcommand\finalstateb[3]{
            \path
                #1
                ++#2
                ++(0:0.5)
                ++(#3:0.5) node[epoch] {\epoch{B2}}
                ++(0:1.3 * \widthepoch) \renhello{#3};
        }

        \newcommand\offseta{ (90:0.7) }
        \newcommand\offsetb{ (-90:0.7) }

        \path
            node {\textbf{A}}
            ++(0:0.5) node (a) {}
            +(0:22) node (a-end) {}
            +(0:2) node[point] (a-initial) {}
            +(0:8) node[point, label=-170:{$\trm{ren}()$}, label={[xshift=0pt]-10:{$\trm{ren}(\betterepoch{0}, A,1)$}}] (a-ren-a1) {}
            +(0:16) node[point] (a-recv-ins-l) {}
            +(0:20) node (a-final) {};

        \initialstate{(a-initial)}{\offseta}{90};
        \ren{(a-ren-a1)}{\offseta}{90};
        \finalstatea{(a-recv-ins-l)}{\offseta}{90};

        \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
        \draw[->, thick] (a-initial) --  (a-ren-a1) -- (a-recv-ins-l) -- (a-final);

        \path
            ++(270:3) node {\textbf{B}}
            ++(0:0.5) node (b) {}
            +(0:22) node (b-end) {}
            +(0:2) node[point] (b-initial) {}
            +(0:8) node[point, label=170:{$\trm{ins}(E \prec L \prec O)$}, label={[xshift=45pt]10:{$\trm{ins}(\betterepoch{0}, \betterid{i}{B0}{0}\betterid{m}{B1}{0},L)$}}] (b-ins-l) {}
            +(0:16) node[point, label=170:{$\trm{ren}()$}, label={[xshift=0pt]10:{$\trm{ren}(\betterepoch{0}, B,2)$}}] (b-ren-b2) {}
            +(0:20) node (b-final) {};


        \initialstate{(b-initial)}{\offsetb}{-90};
        \insl{(b-ins-l)}{\offsetb}{-90};
        \finalstateb{(b-ren-b2)}{\offsetb}{-90};

        \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
        \draw[->, thick] (b-initial) --  (b-ins-l) -- (b-ren-b2) -- (b-final);

        \draw[->, dashed, shorten >= 1] (b-ins-l) -- (a-recv-ins-l);

    \end{tikzpicture}
  }
  \caption{Opérations $\trm{rename}$ concurrentes menant à des états divergents}
  \label{fig:conflicting-rename-operations}
\end{figure}

Après avoir diffusé son opération $\trm{insert}$, le noeud B effectue une opération $\trm{rename}$ sur son état.
Cette opération réassigne à chaque élément un nouvel identifiant à partir de l'identifiant du premier élément de la séquence (\id{i}{B0}{0}), de l'identifiant du noeud (\textbf{B}) et de son numéro de séquence courant (2).
Cette opération introduit aussi une nouvelle époque : \epoch{B2}.
Puisque l'opération $\trm{rename}$ de A n'a pas encore été livrée au noeud B à ce moment, les deux opérations $\trm{rename}$ sont concurrentes.

Puisque des époques concurrentes sont générées, les époques forment désormais un \emph{arbre des époques}.
Nous représentons dans la \autoref{fig:epoch-tree} l'\emph{arbre des époques} que les noeuds obtiennent une fois qu'ils se sont synchronisés à terme.
Les époques sont representées sous la forme de noeuds de l'arbre et la relation \emph{parent-enfant} entre elles est illustrée sous la forme de flèches noires.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[scale=0.8,every node/.style={scale=0.8}]
      \path
          node[op] (e0) {\epoch{0}}
          ++(270:1.5)
          ++(180:0.95) node[op] (eA1) {\epoch{A1}};
      \path
          ++(270:1.5)
          ++(0:0.95) node[op] (eB2) {\epoch{B2}};

      \draw[thick, ->] (e0) -- (eA1);
      \draw[thick, ->] (e0) -- (eB2);
  \end{tikzpicture}
  \caption{\emph{Arbre des époques} correspondant au scénario décrit dans la \autoref{fig:conflicting-rename-operations}}
  \label{fig:epoch-tree}
\end{figure}

À l'issue du scénario décrit dans la \autoref{fig:conflicting-rename-operations}, les noeuds A et B sont respectivement aux époques \epoch{A1} et \epoch{B2}.
Pour converger, tous les noeuds devraient atteindre la même époque à terme.
Cependant, la fonction \textsc{renameId} décrite dans l'\autoref{alg:renameId} permet seulement aux noeuds de progresser d'une époque \emph{parente} à une de ses époques \emph{enfants}.
Le noeud A (resp. B) est donc dans l'incapacité de progresser vers l'époque du noeud B (resp. A).
Il est donc nécessaire de faire évoluer notre mécanisme de renommage pour sortir de cette impasse.

Tout d'abord, les noeuds doivent se mettre d'accord sur une époque commune de l'\emph{arbre des époques} comme époque cible.
Afin d'éviter des problèmes de performance dûs à une coordination synchrone, les noeuds doivent sélectionner cette époque de manière non-coordonnée, \ie en utilisant seulement les données présentes dans l'\emph{arbre des époques}.
Nous présentons un tel mécanisme dans la \autoref{sec:priority}.

Ensuite, les noeuds doivent se déplacer à travers l'\emph{arbre des époques} afin d'atteindre l'époque cible.
La fonction \textsc{renameId} permet déjà aux noeuds de descendre dans l'arbre.
Les cas restants à gérer sont ceux où les noeuds se trouvent actuellement à une époque \emph{soeur} ou \emph{cousine} de l'époque cible.
Dans ces cas, les noeuds doivent être capable de remonter dans l'\emph{arbre des époques} pour retourner au \ac{LCA} de l'époque courante et l'époque cible.
Ce déplacement est en fait similaire à l'annulation de l'effet des opérations $\trm{rename}$ précédemment appliquées.
Nous proposons un algorithme, \textsc{revertRenameId}, qui remplit cet objectif dans la \autoref{sec:reverting-rename-ops}.
