La seconde contrainte que le modèle de livraison doit respecter spécifie qu'une opération $\trm{remove}$ doit être livrée après les opérations $\trm{insert}$ insérant les éléments concernés.

Pour cela, le module de livraison ajoute un ensemble \emph{Deps} à chaque opération $\trm{remove}$ avant de la diffuser :

\begin{definition}[Deps]
  \emph{Deps} est un ensemble d'opérations.
  Il représente l'ensemble des opérations dont dépend l'opération $\trm{remove}$ et qui doivent donc être livrées au préalable.
\end{definition}

Plusieurs structures de données sont adaptées pour représenter les dépendances de l'opération $\trm{remove}$.
Dans le cadre de MUTE, nous avons choisi d'utiliser un ensemble de dots : pour chaque élément supprimé par l'opération $\trm{remove}$, nous identifions le noeud l'ayant inséré et nous ajoutons le dot correspondant à l'opération la plus récente de ce noeud à l'ensemble des dépendances.
Cette approche nous permet de limiter à un dot par élément supprimé le surcoût en métadonnées des dépendances et de les calculer en un temps linéaire par rapport au nombre d'éléments supprimés.
Nous illustrons le calcul et l'utilisation des dépendances de l'opération $\trm{remove}$ à l'aide de la \autoref{fig:causal-remove-delivery}.\\

\begin{figure}[!ht]
  \subfloat[Exécution avec livraison dans le désordre d'une insertion et de sa suppression]{
      \begin{minipage}{\linewidth}
          \centering
          \resizebox{\columnwidth}{!}{
            \begin{tikzpicture}
              \newcommand\initialstate[3]{
                \path
                  #1
                  ++#2
                  ++(0:0.5) node[epoch] {\epoch{0}}
                  ++(0:1.05 * \widthoriginepoch) node[block, label=#3:{$\betterid{p}{A1}{0..3}$}] {WOLD};
              }

              \newcommand\insr[3]{
                \path
                  #1
                  ++#2
                  ++(0:0.5) node[epoch] {\epoch{0}}
                  ++(0:1.05 * \widthoriginepoch) node[block, label=#3:{$\betterid{p}{A1}{0..1}$}] {WO}
                  ++(0:\widthblock) node[letter, fill=\colorblockone, label=-#3:{$\coloridone\betterid{p}{A1}{1}\betterid{m}{A2}{0}$}] {R}
                  ++(0:\widthletter)  node[block, label=#3:{$\betterid{p}{A1}{2..3}$}] {LD};
              }

              \newcommand\rmvr[3]{
                \path
                  #1
                  ++#2
                  ++(0:0.5) node[epoch] {\epoch{0}}
                  ++(0:1.05 * \widthoriginepoch) node[block, label=#3:{$\betterid{p}{A1}{0..1}$}] {WO}
                  ++(0:\widthblock)  node[block, label=#3:{$\betterid{p}{A1}{2..3}$}] {LD};
              }

              \newcommand\offseta{ (90:1.2) }
              \newcommand\offsetb{ (270:1.2) }

              \path
                node {\textbf{A}}
                ++(0:0.5) node (a) {}
                +(0:24) node (a-end) {}
                +(0:1) node[point] (a-initial) {}
                +(0:6) node[point, label=-170:{$\trm{ins}(O \prec R \prec K)$}, label={[xshift=6em]-10:{$\trm{ins}(\betterepoch{0},{\coloridone\betterid{p}{A1}{1}\betterid{m}{A2}{0}},R)$}}] (a-ins-r) {}
                +(0:16) node[point] (a-recv-rmv-r) {}
                +(0:19) node (a-last-display) {}
                +(0:23) node (a-final) {};

              \initialstate{(a-initial)}{\offseta}{90};
              \insr{(a-ins-r)}{\offseta}{90};
              \rmvr{(a-last-display)}{\offseta}{90};

              \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
              \draw[->, thick] (a-initial) --  (a-ins-r) -- (a-recv-rmv-r) -- (a-final);

              \path
                ++(270:3) node {\textbf{B}}
                ++(0:0.5) node (b) {}
                +(0:24) node (b-end) {}
                +(0:1) node[point] (b-initial) {}
                +(0:8) node[point] (b-recv-ins-r) {}
                +(0:14) node[point, label=170:{$\trm{rmv}(R)$}, label={[xshift=1em]10:{$\trm{rmv}(\betterepoch{0},{\coloridone\betterid{p}{A1}{1}\betterid{m}{A2}{0}})$}}] (b-rmv-r) {}
                +(0:19) node (b-last-display) {}
                +(0:23) node (b-final) {};

              \initialstate{(b-initial)}{\offsetb}{-90};
              \insr{(b-recv-ins-r)}{\offsetb}{-90};
              \rmvr{(b-last-display)}{\offsetb}{-90};

              \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
              \draw[->, thick] (b-initial) --  (b-recv-ins-r) -- (b-rmv-r) -- (b-final);

              \path
                ++(270:6) node {\textbf{C}}
                ++(0:0.5) node (c) {}
                +(0:24) node (c-end) {}
                +(0:1) node[point] (c-initial) {}
                +(0:16) node[point] (c-recv-rmv-r) {}
                +(0:19) node[point] (c-recv-ins-r) {}
                +(0:23) node (c-final) {};

              \initialstate{(c-initial)}{\offsetb}{-90};
              \initialstate{(c-recv-rmv-r)}{\offsetb}{-90};
              \initialstate{(c-recv-ins-r)}{\offsetb}{-90};

              \draw[dotted] (c) -- (c-initial) (c-final) -- (c-end);
              \draw[->, thick] (c-initial) --  (c-recv-rmv-r) -- (c-recv-ins-r) -- (c-final);

              \draw[->, dashed, shorten >= 1] (a-ins-r) -- (b-recv-ins-r);
              \draw[->, dashed, shorten >= 1] (a-ins-r) -- (c-recv-ins-r);
              \draw[->, dashed, shorten >= 1] (b-rmv-r) -- (a-recv-rmv-r);
              \draw[->, dashed, shorten >= 1] (b-rmv-r) -- (c-recv-rmv-r);
            \end{tikzpicture}
            \label{fig:causal-remove-delivery-rls}
          }
          \end{minipage}
        }
        \hfil
  \subfloat[État et comportement du module de livraison au cours de l'exécution décrite en \autoref{fig:causal-remove-delivery-rls}]{
    \begin{minipage}{\linewidth}
      \centering
      \resizebox{\columnwidth}{!}{
        \begin{tikzpicture}
          \path
            node {\textbf{A}}
            ++(0:0.5) node (a) {}
            +(0:24) node (a-end) {}
            +(0:1) node[point, label=above right:{$\langle A:4 \rangle$}] (a-initial) {}
            +(0:6) node[point, label=-170:{\emph{tag as} $a_5$}, label=10:{$\langle A:5 \rangle$}] (a-ins-r) {}
            +(0:16) node[point,label={[xshift=-10pt]-170:{\emph{deliver} $b_1$}}, label=10:{$\langle A:5,B:1 \rangle$}] (a-recv-rmv-r) {}
            +(0:19) node (a-last-display) {}
            +(0:23) node (a-final) {};

          \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
          \draw[->, thick] (a-initial) --  (a-ins-r) -- (a-recv-rmv-r) -- (a-final);

          \path
            ++(270:3) node {\textbf{B}}
            ++(0:0.5) node (b) {}
            +(0:24) node (b-end) {}
            +(0:1) node[point, label=-10:{$\langle A:4 \rangle$}] (b-initial) {}
            +(0:8) node[point, label={[xshift=-10pt]170:{\emph{deliver} $a_5$}}, label=-10:{$\langle A:5 \rangle$}] (b-recv-ins-r) {}
            +(0:14) node[point, label=170:{\emph{tag as} $b_1$}, label={[xshift=10pt]-10:{$\langle A:5,B:1 \rangle$}}] (b-rmv-r) {}
            +(0:19) node (b-last-display) {}
            +(0:23) node (b-final) {};

          \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
          \draw[->, thick] (b-initial) --  (b-recv-ins-r) -- (b-rmv-r) -- (b-final);

          \path
            ++(270:6) node {\textbf{C}}
            ++(0:0.5) node (c) {}
            +(0:24) node (c-end) {}
            +(0:1) node[point, label=-10:{$\langle A:4 \rangle$}] (c-initial) {}
            +(0:16) node[point, label={[xshift=-10pt]170:{\emph{postpone} $b_1$}}, label=-90:{$\langle A:4 \rangle$}] (c-recv-rmv-r) {}
            +(0:19) node[point,label={[xshift=0pt,yshift=10pt]90:{\emph{deliver} $a_5$}}, label=-10:{$\langle A:5 \rangle$}] (c-recv-ins-r) {}
            +(0:22) node[point,label={[xshift=0pt]90:{\emph{deliver} $b_1$}}, label=-10:{$\langle A:5,B:1 \rangle$}] (c-recv-rmv-r-2) {}
            +(0:23) node (c-final) {};

          \draw[dotted] (c) -- (c-initial) (c-final) -- (c-end);
          \draw[->, thick] (c-initial) --  (c-recv-rmv-r) -- (c-recv-ins-r) -- (c-recv-rmv-r-2) -- (c-final);

          \draw[->, dashed, shorten >= 1] (a-ins-r) -- (b-recv-ins-r);
          \draw[->, dashed, shorten >= 1] (a-ins-r) -- (c-recv-ins-r);
          \draw[->, dashed, shorten >= 1] (b-rmv-r) edge node[right] {$\{\trm{deps}: \langle A:5 \rangle\}$}  (a-recv-rmv-r);
          \draw[->, dashed, shorten >= 1] (b-rmv-r) edge node[left] {$\{\trm{deps}: \langle A:5 \rangle\}$} (c-recv-rmv-r);

          \draw[->, dotted, thick, shorten >= 1] (c-recv-rmv-r) edge[bend right] (c-recv-rmv-r-2);
        \end{tikzpicture}
        \label{fig:causal-remove-sync}
      }
      \end{minipage}
    }
  \caption{Gestion de la livraison des opérations $\trm{remove}$ après les opérations $\trm{insert}$ correspondantes}
  \label{fig:causal-remove-delivery}
\end{figure}

Dans cet exemple, trois noeuds A, B et C répliquent et éditent collaborativement une séquence.
Les trois noeuds partagent le même état initial : une séquence contenant les éléments "WOLD" et un vecteur de versions $\langle A:4 \rangle$.

Le noeud A insère l'élément "L" entre les éléments "R" et "D".
Cet élément se voit attribué l'identifiant \id{p}{A1}{1}\id{m}{A2}{0}.
L'opération correspondante $a_5$ est diffusée aux autres noeuds.

À la réception de cette dernière, le noeud B supprime l'élément "L" nouvellement inséré et génère l'opération $b_1$ correspondante.
Comme indiqué précédemment, l'opération $b_1$ étant une opération $\trm{remove}$, le module de livraison calcule ses dépendances avant de la diffuser.
Pour chaque élément supprimé ("L"), le module de livraison récupère l'identifiant de l'élément (\id{p}{A1}{1}\id{m}{A2}{0}) et en extrait l'identifiant du noeud qui l'a inséré (A).
Le module ajoute alors le dot de l'opération la plus récente reçue de ce noeud ($\langle A:5 \rangle$) à l'ensemble des dépendances de l'opération.
L'opération est ensuite diffusée.

À la réception de l'opération $b_1$, le noeud A vérifie s'il possède l'ensemble des dépendances de l'opération.
Le noeud A ayant déjà intégré l'opération $a_5$, le module de livraison livre l'opération $b_1$ au \ac{CRDT}.

À l'inverse, lorsque le noeud C reçoit l'opération $b_1$, il n'a pas encore reçu l'opération $a_5$.
L'opération $b_1$ est alors mise en attente.
À la réception de l'opération $a_5$, celle-ci est livrée.
Le module de livraison ré-évalue alors le cas de l'opération $b_1$ et détermine qu'elle peut à présent être livrée.\\

Il est à noter que notre approche pour générer l'ensemble des dépendances est une approximation.
En effet, nous ajoutons les dots des opérations les plus récentes des auteurs des éléments supprimés.
Nous n'ajoutons pas les dots des opérations qui ont spécifiquement inséré les éléments supprimés.
Pour cela, il serait nécessaire de parcourir le journal des opérations à la recherche des opérations $\trm{insert}$ correspondantes.
Cette méthode serait plus coûteuse, sa complexité dépendant du nombre d'opérations dans le journal des opérations, et incompatible avec un mécanisme tronquant le journal des opérations en utilisant la stabilité causale.
Notre approche introduit un potentiel délai dans la livraison d'une opération $\trm{remove}$ par rapport à une livraison utilisant ses dépendances exactes, puisqu'elle va reposer sur des opérations plus récentes et potentiellement encore inconnues par le noeud.
Mais il s'agit là aussi d'un compromis que nous jugeons acceptable entre le surcoût du mécanisme de livraison et l'expérience utilisateur.
