Ce premier exemple, représenté par la \autoref{fig:why-exactly-once-delivery}, a pour but d'illustrer la nécessité de la propriété de livraison en \emph{exactement un exemplaire} des opérations.

\begin{figure}[!ht]

  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
      \newcommand\initialstate[3]{
        \path
          #1
          ++#2
          ++(0:0.5) node[block, label=#3:{$\betterid{p}{A1}{1..4}$}] {ABCD};
      }

      \newcommand\insx[3]{
        \path
          #1
          ++#2
          ++(0:0.5) node[block, label=#3:{$\betterid{p}{A1}{1..2}$}] {AB}
          ++(0:\widthblock) node[letter, fill=ucl2orange, label=-#3:{$\color{ucl1orange}\betterid{p}{A1}{2}\betterid{m}{A2}{1}$}] {X}
          ++(0:\widthletter)  node[block, label=#3:{$\betterid{p}{A1}{3..4}$}] {CD};
      }

      \newcommand\rmvx[3]{
        \path
          #1
          ++#2
          ++(0:0.5) node[block, label=#3:{$\betterid{p}{A1}{1..2}$}] {AB}
          ++(0:\widthblock)  node[block, label=#3:{$\betterid{p}{A1}{3..4}$}] {CD};
      }

      \newcommand\offseta{ (90:1.2) }
      \newcommand\offsetb{ (270:1.2) }

      \path
        node {\textbf{A}}
        ++(0:0.5) node (a) {}
        +(0:24) node (a-end) {}
        +(0:1) node[point] (a-initial) {}
        +(0:6) node[point, label=-170:{$\trm{ins}(B \prec X \prec C)$}, label={[xshift=6em]-10:{$\trm{ins}({\color{ucl1orange}\betterid{p}{A1}{2}\betterid{m}{A2}{1}},X)$}}] (a-ins-x) {}
        +(0:16) node[point] (a-recv-rmv-x) {}
        +(0:23) node (a-final) {};

      \initialstate{(a-initial)}{\offseta}{90};
      \insx{(a-ins-x)}{\offseta}{90};
      \rmvx{(a-recv-rmv-x)}{\offseta}{90};

      \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
      \draw[->, thick] (a-initial) --  (a-ins-x) -- (a-recv-rmv-x) -- (a-final);

      \path
        ++(270:3) node {\textbf{B}}
        ++(0:0.5) node (b) {}
        +(0:24) node (b-end) {}
        +(0:1) node[point] (b-initial) {}
        +(0:8) node[point] (b-recv-ins-x) {}
        +(0:14) node[point, label=170:{$\trm{rmv}(X)$}, label={[xshift=1em]10:{$\trm{rmv}({\color{ucl1orange}\betterid{p}{A1}{2}\betterid{m}{A2}{1}})$}}] (b-rmv-x) {}
        +(0:21) node[point] (b-recv-ins-x-2) {}
        +(0:23) node (b-final) {};

      \initialstate{(b-initial)}{\offsetb}{-90};
      \insx{(b-recv-ins-x)}{\offsetb}{-90};
      \rmvx{(b-rmv-x)}{\offsetb}{-90};
      \insx{(b-recv-ins-x-2)}{\offsetb}{-90};

      \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
      \draw[->, thick] (b-initial) --  (b-recv-ins-x) -- (b-rmv-x) -- (b-recv-ins-x-2) -- (b-final);

      \draw[->, dashed, shorten >= 1] (a-ins-x) -- (b-recv-ins-x);
      \draw[->, dashed, shorten >= 1] (b-rmv-x) -- (a-recv-rmv-x);
      \draw[->, dashed, shorten >= 1] (a-ins-x) -- (b-recv-ins-x-2);
    \end{tikzpicture}
  }
  \caption{Résurgence d'un élément supprimé suite à la relivraison de son opération $\trm{ins}$}
  \label{fig:why-exactly-once-delivery}
\end{figure}

Dans cet exemple, deux noeuds A et B répliquent et éditent collaborativement une séquence.
La séquence répliquée contient initialement les éléments "ABCD", qui sont associés à l'intervalle d'identifiants $\betterid{p}{A1}{1..4}$.

Le noeud A commence par insérer l'élément "X" dans la séquence entre les éléments "B" et "C".
A intègre l'opération résultante, $\trm{ins}(\betterid{p}{A1}{2}\betterid{m}{A2}{1},X)$ puis la diffuse au noeud B.

À la réception de l'opération $\trm{ins}$, le noeud B l'intègre à son état.
Puis il supprime dans la foulée l'élément "X" nouvellement inséré.
B intègre l'opération $\trm{rmv}(\betterid{p}{A1}{2}\betterid{m}{A2}{1})$ puis l'envoie au noeud A.

Le noeud A intègre l'opération $\trm{rmv}$, ce qui a pour effet de supprimer l'élément "X" associé à l'identifiant $\betterid{p}{A1}{2}\betterid{m}{A2}{1}$.
Il obtient alors un état équivalent à celui du noeud B.

Cependant, l'opération $\trm{ins}$ insérant l'élément "X" à la position $\betterid{p}{A1}{2}\betterid{m}{A2}{1}$ est de nouveau délivrée au noeud B.
De multiples raisons peuvent être à l'origine de cette nouvelle livraison : perte du message d'\emph{acknowledgment}, utilisation d'un protocole de diffusion épidémique des messages, déclenchement du mécanisme d'anti-entropie en concurrence...
Le noeud B ré-intègre alors l'opération $\trm{ins}$, ce qui fait revenir l'élément "X" et l'identifiant associé.
L'état du noeud B diverge désormais de celui-ci du noeud A.

Pour se prémunir de ce type de scénarios, LogootSplit requiert que la couche de livraison des messages assure une livraison en exactement un exemplaire des opérations.
Cette contrainte permet d'éviter que d'anciens éléments et identifiants ressurgissent après leur suppression chez certains noeuds uniquement à cause d'une livraison multiple de l'opération $\trm{ins}$ correspondante.
