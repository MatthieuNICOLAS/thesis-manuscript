\label{sec:etat-art-crdts-intro}

Afin d'offrir une haute disponibilité à leurs clients et afin d'accroître leur tolérance aux pannes \cite{2016-trade-offs-replicated-systems-guerraoui}, les systèmes distribués peuvent adopter le paradigme de la réplication optimiste \cite{2005-optimistic-replication-saito}.
Ce paradigme consiste à ce que chaque noeud composant le système possède une copie de la donnée répliquée.
Chaque noeud possède le droit de la consulter et de la modifier, sans coordination préalable avec les autres noeuds.
Les noeuds peuvent alors temporairement diverger, \ie posséder des états différents.
Un mécanisme de synchronisation leur permet ensuite de partager leurs modifications respectives et d'obtenir de nouveau des états équivalent, \ie de converger à terme \cite{10.1145/224057.224070}.

Pour permettre aux noeuds de converger, les protocoles de réplication optimiste ordonnent généralement les évènements se produisant dans le système distribué.
Pour les ordonner, la littérature repose généralement sur la relation de causalité entre les évènements, qui est définie par la relation \hb \cite{1978-happen-before-lamport}.
Nous l'adaptons ci-dessous à notre contexte, en ne considérant que les modifications\footnote{Nous utilisons le terme \emph{modifications} pour désigner les \emph{opérations de modifications} des types abstraits de données afin d'éviter une confusion avec le terme \emph{opération} introduit ultérieurement.} effectuées et celles intégrées :

\begin{definition}[Relation \hb]
  \label{def:happens-before}
  La relation \hb indique qu'une modification $m_1$ a eu lieu avant une modification $m_2$, notée $m_1 \rightarrow m_2$, si et seulement si une des conditions suivantes est satisfaite :
  \begin{enumerate}
    \item $m_1$ a été effectuée avant $m_2$ sur le même noeud.
    \item $m_1$ a été intégrée par le noeud auteur\footnote{Nous dénotons par le terme \emph{auteur} le noeud à l'origine d'une modification.} de $m_2$ avant qu'il n'effectue $m_2$.
    \item Il existe une modification $m$ telle que $m_1 \rightarrow m \land m \rightarrow m_2$.
  \end{enumerate}
\end{definition}

Dans le cadre d'un système distribué, nous notons que la relation \hb ne permet pas d'établir un ordre total entre les modifications.
En effet, deux modifications $m_1$ et $m_2$ peuvent être effectuées en parallèle par deux noeuds différents, sans avoir connaissance de la modification de leur pair respectif.
De telles modifications sont alors dites \emph{concurrentes} :

\begin{definition}[Concurrence]
  Deux modifications $m_1$ et $m_2$ sont concurrentes, noté $m_1 \parallel m_2$, si et seulement si $m_1 \nrightarrow m_2 \land m_2 \nrightarrow m_1$.
\end{definition}

Lorsque les modifications possibles sur un type de données sont commutatives, l'intégration des modifications effectuées par les autres noeuds, même concurrentes, ne nécessite aucun mécanisme particulier.
Cependant, les modifications permises par un type de données ne sont généralement pas commutatives car de sémantiques contraires, \eg l'ajout et la suppression d'un élément dans une Collection.
Ainsi, une exécution distribuée peut mener à la génération de modifications concurrentes non commutatives.
Nous parlons alors de conflits.

Avant d'illustrer notre propos avec un exemple, nous introduisons la spécification algébrique du type Ensemble dans la \autoref{fig:spec-set} sur laquelle nous nous basons.

\begin{figure}[!ht]

  \centering
  % \resizebox{0.35\columnwidth}{!}{
    \begin{tabular}{llll}
      \textbf{payload} \\
      $S \in \trm{Set}\langle \elt \rangle$ & & & \\
      \\
      \textbf{constructor} \\
      $\trm{empty}$ & : &                       & $\longrightarrow S$   \\
      \\
      \textbf{mutators} \\
      $\trm{add}$ & : & $S \times \elt$ & $\longrightarrow S$   \\
      $\trm{remove}$ & : & $S \times \elt$          & $\longrightarrow S$   \\
      \\
      \textbf{queries} \\
      $\trm{length}$ & : & $S$                   & $\longrightarrow \nat$   \\
      $\trm{read}$  & : & $S$                   & $\longrightarrow S$ \\
    \end{tabular}
  % }
  \caption{Spécification algébrique du type abstrait usuel Ensemble}
  \label{fig:spec-set}
\end{figure}

Un Ensemble est une collection dynamique non-ordonnée d'éléments de type $E$.
Cette spécification définit que ce type dispose d'un constructeur, $\trm{empty}$, permettant de générer un ensemble vide.

La spécification définit deux modifications sur l'ensemble :
\begin{enumerate}
  \item $\trm{add}(s,e)$, qui permet d'ajouter un élément donné $e$ à un ensemble $s$.
    Cette modification renvoie un nouvel ensemble construit de la manière suivante :
    \begin{equation*}
      \trm{add}(s,e) = s \cup \set{e}
    \end{equation*}
  \item $\trm{remove}(s,e)$, abrégée en $\trm{rmv}$ dans nos figures, qui permet de retirer un élément donné $e$ d'un ensemble $s$.
    Cette modification renvoie un nouvel ensemble construit de la manière suivante :
    \begin{equation*}
      \trm{remove}(s,e) = s~\backslash \set{e}
    \end{equation*}
\end{enumerate}

Elle définit aussi deux observateurs :
\begin{enumerate}
  \item $\trm{length}(s)$, qui permet de récupérer le nombre d'éléments présents dans un ensemble $s$.
  \item $\trm{read}(s)$, qui permet de consulter l'état d'ensemble $s$.
    Dans le cadre de nos exemples, nous considérons qu'une consultation de l'état est effectuée de manière implicite à l'aide de $\trm{read}$ après chaque modification
    \footnote{Cette hypothèse nous permettra de préciser le modèle de cohérence assuré par le système \cite{10.1145/2578855.2535848} en fonction des valeurs observées.}.
\end{enumerate}

Dans le cadre de ce manuscrit, nous travaillons sur des ensembles de caractères.
Cette restriction du domaine se fait sans perte en généralité.
En se basant sur cette spécification, nous présentons dans la \autoref{fig:set-conflict} un scénario où des noeuds effectuent en concurrence des modifications provoquant un conflit.

\begin{figure}[!ht]

  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
      \path
          node {\textbf{A}}
          ++(0:0.5) node (a) {}
          +(0:21) node (a-end) {}
          +(0:2) node[point, label=above right:{$\{a\}$}] (a-initial) {}
          +(0:7) node[point, label=above right:{$\{\}$}, label=below left:{$\trm{rmv}(a)$}] (a-removes) {}
          +(0:12) node[point, label=above right:{$\{a\}$}, label=below left:{$\trm{add}(a)$}] (a-add) {}
          +(0:19) node[point, label=above right:{$?$}] (a-conflicts) {};

      \draw[dotted] (a) -- (a-initial) (a-conflicts) -- (a-end);
      \draw[->, thick] (a-initial) --  (a-removes) -- (a-add) -- (a-conflicts);

      \path
          ++(270:3) node {\textbf{B}}
          ++(0:0.5) node (b) {}
          +(0:21) node (b-end) {}
          +(0:2) node[point, label=below right:{$\{a\}$}] (b-initial) {}
          +(0:15.5) node[point, label=below right:{$\{\}$}, label=above left:{$\trm{rmv}(a)$}] (b-removes) {}
          +(0:19) node[point, label=below right:{$?$}] (b-conflicts) {};

      \draw[dotted] (b) -- (b-initial) (b-conflicts) -- (b-end);
      \draw[->, thick] (b-initial) --  (b-removes) -- (b-conflicts);

      \draw[->, dashed, shorten >= 1] (a-add) edge node[above right, near start] {\emph{sync}} (b-conflicts);
      \draw[->, dashed, shorten >= 1] (b-removes) edge node[below right, near start, xshift=-10pt, yshift=-7pt] {\emph{sync}} (a-conflicts);
    \end{tikzpicture}
  }
  \caption{Modifications concurrentes d'un Ensemble répliqué provoquant un conflit suite à l'ajout et la suppression d'un même élément}
  \label{fig:set-conflict}
\end{figure}

Dans cet exemple, deux noeuds A et B répliquent et partagent une même structure de données de type Ensemble.
Les deux noeuds possèdent le même état initial : $\{a\}$.
Le noeud A retire l'élément $a$ de l'ensemble, en procédant à la modification $\trm{remove}(a)$.
Puis, le noeud A ré-ajoute l'élément $a$ dans l'ensemble via la modification $\trm{add}(a)$.
En concurrence, le noeud B retire lui aussi l'élément $a$ de l'ensemble.
Les deux noeuds se synchronisent ensuite.

À l'issue de ce scénario, l'état à produire n'est pas trivial : le noeud A a exprimé son intention d'ajouter l'élément $a$ à l'ensemble, tandis que le noeud B a exprimé son intention contraire de retirer l'élément $a$ de ce même ensemble.
Ainsi, les états $\{a\}$ et $\{\}$ semblent tous les deux corrects et légitimes dans cette situation.
Il est néanmoins primordial que les noeuds choisissent et convergent vers un même état pour leur permettre de poursuivre leur collaboration.
Pour ce faire, il est nécessaire de mettre en place un mécanisme de résolution de conflits, potentiellement automatique.

Les \acfp{CRDT} \cite{shapiro_2011_crdt, 2018-crdts-perguica-baquero-shapiro, 2018-crdts-overview-preguica} répondent à ce besoin.

\begin{definition}[\acl{CRDT}]
  Les \acp{CRDT} sont de nouvelles spécifications des types de données existants, \eg l'Ensemble ou la Séquence.
  Ces nouvelles spécifications sont conçues pour être utilisées dans des systèmes distribués adoptant la réplication optimiste.
  Ainsi, elles offrent les deux propriétés suivantes :

  \begin{enumerate}
    \item Les \acp{CRDT} peuvent être modifiés sans coordination avec les autres noeuds.
    \item Les \acp{CRDT} garantissent la \emph{cohérence forte à terme} \cite{shapiro_2011_crdt}.
  \end{enumerate}
\end{definition}

\begin{definition}[Cohérence forte à terme]
  \label{def:sec}
  La cohérence forte à terme est une propriété de sûreté indiquant que l'ensemble des noeuds d'un système ayant intégrés le même ensemble de modifications obtiendront des états équivalents, sans échange de message supplémentaire.
\end{definition}

Pour offrir la propriété de \emph{cohérence forte à terme}, la spécification des \acp{CRDT} reposent sur la théorie des treillis \cite{2002-intro-lattices-order-davey} :

\begin{definition}[Spécification des \acp{CRDT}]
  \label{def:spec-crdts}
  Les \acp{CRDT} sont spécifiés de la manière suivante :
  \begin{enumerate}
    \item Les différents états possibles d'un \ac{CRDT} forment un sup-demi-treillis, possédant une relation d'ordre partiel $\leq$.
    \item Les modifications génèrent par inflation un nouvel état supérieur ou égal à l'état original d'après $\leq$.
    \item \label{item:lub} Il existe une fonction de fusion qui, pour toute paire d'états, génère l'état minimal supérieur d'après $\leq$ aux deux états fusionnés.
    Nous parlons alors de borne supérieure ou de \ac{LUB} pour catégoriser l'état résultant de cette fusion.
  \end{enumerate}
\end{definition}


Malgré leur spécification différente, les \acp{CRDT} partagent la même sémantique, \ie le même comportement, et la même interface que les types séquentiels\footnotemark \  correspondants du point de vue des utilisateur-rices.
\footnotetext{Nous dénotons comme \emph{types séquentiels} les spécifications usuelles des types de données supposant une exécution séquentielle de leurs modifications.}
Ainsi, les \acp{CRDT} partagent le comportement des types séquentiels dans le cadre d'exécutions séquentielles.
Cependant, ils définissent aussi une sémantique additionnelle pour chaque type de conflit ne pouvant se produire que dans le cadre d'une exécution distribuée.

Plusieurs sémantiques valides peuvent être proposées pour résoudre un type de conflit.
Un \ac{CRDT} se doit donc de préciser quelle sémantique il choisit.

L'autre aspect définissant un \ac{CRDT} donné est le modèle qu'il adopte pour propager les modifications.
Au fil des années, la littérature a établi et défini plusieurs modèles dit de synchronisation, chacun ayant ses propres besoins et avantages.
De fait, plusieurs \acp{CRDT} peuvent être proposés pour un même type donné en fonction du modèle de synchronisation choisi.

Ainsi, ce qui définit un \ac{CRDT} est sa ou ses sémantiques en cas de conflits et son modèle de synchronisation.
Dans les prochaines sections, nous présentons les différentes sémantiques possibles pour un type donné, l'Ensemble, en guise d'exemple.
Nous présentons ensuite les différents modèles de synchronisation proposés dans la littérature, et détaillons leurs contraintes et impact sur les \ac{CRDT} les adoptant, toujours en utilisant le même exemple.

\mnnote{TODO: Faire le lien avec les travaux de Burckhardt \cite{10.1145/2535838.2535848} et les MRDTs \cite{10.1145/3360580}}


