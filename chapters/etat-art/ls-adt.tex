En nous basant sur \textcite{2013-logootsplit}, nous proposons une définition du modèle de données de LogootSplit dans la \autoref{fig:ls-spec} :

\begin{figure}[!ht]
  \centering
  % \resizebox{0.35\columnwidth}{!}{
    \begin{tabular}{llll}
      \textbf{payload} \\
      $S \in \trm{Seq}\langle \trm{IdInterval},\trm{Arr}\langle E \rangle, \trm{Bool} \rangle$ \\
      \\
      \textbf{constructor} \\
      $\trm{emp}$ & : &                                                 & $\longrightarrow S$   \\
      \\
      \textbf{prepare} \\
      $\trm{ins}$ & : & $S \times \nat \times \trm{Arr}\langle \elt \rangle \times \mathbb{I} \times \nat^*$   & $\longrightarrow \trm{Id} \times \trm{Arr}\langle \elt \rangle$   \\
      $\trm{rmv}$ & : & $S \times \nat \times \nat$                           & $\longrightarrow \trm{Arr}\langle \trm{IdInterval} \rangle$ \\
      \\
      \textbf{effect} \\
      $\trm{ins}$ & : & $S \times \trm{Id} \times \trm{Arr}\langle \elt \rangle$ & $\longrightarrow S$ \\
      $\trm{rmv}$ & : & $S \times \trm{Arr}\langle \trm{IdInterval} \rangle$  & $\longrightarrow S$ \\
      \\
      \textbf{queries} \\
      $\trm{len}$ & : & $S$                                             & $\longrightarrow \nat$   \\
      $\trm{rd}$  & : & $S$                                             & $\longrightarrow \trm{Arr}\langle \elt \rangle$ \\
    \end{tabular}
  % }
  \caption{Spécification algébrique du type abstrait LogootSplit}
  \label{fig:ls-spec}
\end{figure}

Une séquence LogootSplit est une séquence de blocs.
Concernant les modifications définies sur le type, nous nous inspirons de \cite{baquero2017pure} et les séparons en deux étapes :
\begin{enumerate}
  \item \textbf{prepare}, l'étape qui consiste à générer l'opération correspondant à la modification à partir de l'état courant et de ses éventuels paramètres.
    Cette étape ne modifie pas l'état.
  \item \textbf{effect}, l'étape qui consiste à intégrer l'effet d'une opération générée précédemment, par le noeud lui-même ou un autre.
    Cette étape met à jour l'état à partir des données fournies par l'opération.
\end{enumerate}

La séquence LogootSplit autorise deux types de modifications :
\begin{enumerate}
  \item $\trm{ins}(s, i, \trm{elts}, \trm{nodeId}, \trm{seq})$, qui génère l'opération permettant d'insérer les éléments $\trm{elts}$ dans la séquence $s$ à l'index $i$.
    Cette fonction génère et associe un intervalle d'identifiants aux éléments à insérer en utilisant les valeurs pour $\trm{nodeId}$ et $\trm{seq}$ fournies.
    Elle retourne les données nécessaires pour l'opération $\trm{ins}$, \ie le premier identifiant de l'intervalle d'identifiants alloué et les éléments.
    Par soucis de simplicité, nous noterons cette modification $\trm{ins}(\trm{pred} \prec \trm{elts} \prec \trm{succ})$ et utiliserons l'état courant de la séquence comme valeur pour $s$, l'identifiant du noeud auteur de la modification comme valeur pour $\trm{nodeId}$ et le nombre de blocs que le noeud a créé comme valeur pour $\trm{seq}$ dans nos exemples.
  \item  \emph{rmv(s, i, nbElts)}, qui génère l'opération permettant de supprimer $\trm{nbElts}$ dans la séquence $s$ à partir de l'index $i$.
    Elle retourne les données nécessaires pour l'opération $\trm{rmv}$, \ie les intervalles d'identifiants supprimés.
    Par soucis de simplicité, nous noterons cette modifications $\trm{rmv}(\trm{elts})$ dans nos exemples.
\end{enumerate}

Nous présentons dans la \autoref{fig:ls-example} un exemple d'utilisation de cette séquence répliquée.

\begin{figure}[!ht]

  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
      \newcommand\initialstate[3]{
        \path
          #1
          ++#2
          ++(0:0.5) node[block, label=#3:{$\betterid{i}{B1}{1..4}$}] {HRLO};
      }

      \newcommand\nodeh[1]{
        node[letter, label=#1:{$\betterid{i}{B1}{1}$}] {H}
      }
      \newcommand\blocklo[1]{
        node[block, label=#1:{$\betterid{i}{B1}{3..4}$}] {LO}
      }
      \newcommand\nodee[1]{
        node[letter, fill=ucl2orange, label=#1:{\color{ucl1orange}$\betterid{i}{B1}{1}\betterid{f}{A1}{1}$}] {E}
      }
      \newcommand\blockloexclam[1]{
        node[block, label=#1:{$\betterid{i}{B1}{3..5}$}] {LO!}
      }

      \newcommand\rmvr[3]{
        \path
          #1
          ++#2
          ++(0:0.5) \nodeh{#3}
          ++(0:\widthletter) \blocklo{#3};
      }

      \newcommand\insexclam[3]{
        \path
          #1
          ++#2
          ++(0:0.5) node[block, label=#3:{$\betterid{i}{B1}{1..5}$}] {HRLO!};
      }

      \newcommand\inse[3]{
        \path
          #1
          ++#2
          ++(0:0.5) \nodeh{-#3}
          ++(0:\widthletter) \nodee{#3}
          ++(0:\widthletter) \blocklo{-#3};
      }

      \newcommand\recvrmvr[3]{
        \path
          #1
          ++#2
          ++(0:0.5) \nodeh{#3}
          ++(0:\widthletter) \blockloexclam{#3};
      }

      \newcommand\finalstate[3]{
        \path
          #1
          ++#2
          ++(0:0.5) \nodeh{-#3}
          ++(0:\widthletter) \nodee{#3}
          ++(0:\widthletter) \blockloexclam{-#3};
      }

      \newcommand\offseta{ (90:1.2) }
      \newcommand\offsetb{ (270:1.2) }

      \path
        node {\textbf{A}}
        ++(0:0.5) node (a) {}
        +(0:25) node (a-end) {}
        +(0:2) node[point] (a-initial) {}
        +(0:5) node[point, label=-170:{$\trm{rmv}(R)$}, label={[xshift=3em]-10:{$\trm{rmv}(\betterid{i}{B1}{2})$}}] (a-rmv-r) {}
        +(0:12) node[point, label=-170:{$\trm{ins}(H \prec E \prec L)$}, label={[xshift=2em]-10:{$\trm{ins}({\color{ucl1orange}\betterid{i}{B1}{1}\betterid{f}{A1}{1}},E)$}}] (a-ins-e) {}
        +(0:18) node[point] (a-recv-ins-exc) {}
        +(0:23) node (a-final) {};

      \initialstate{(a-initial)}{\offseta}{90};
      \rmvr{(a-rmv-r)}{\offseta}{90};
      \inse{(a-ins-e)}{\offseta}{90};
      \finalstate{(a-recv-ins-exc)}{\offseta}{90};

      \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
      \draw[->, thick] (a-initial) --  (a-rmv-r) --  (a-ins-e) -- (a-recv-ins-exc) -- (a-final);

      \path
        ++(270:3) node {\textbf{B}}
        ++(0:0.5) node (b) {}
        +(0:25) node (b-end) {}
        +(0:2) node[point] (b-initial) {}
        +(0:5) node[point, label=170:{$\trm{ins}(O \prec !)$}, label={[xshift=5em]10:{$\trm{ins}(\betterid{i}{B1}{5},!)$}}] (b-ins-exc) {}
        +(0:12) node[point] (b-recv-rmv-r) {}
        +(0:18) node[point] (b-recv-ins-e) {}
        +(0:23) node (b-final) {};

      \initialstate{(b-initial)}{\offsetb}{-90};
      \insexclam{(b-ins-exc)}{\offsetb}{-90};
      \recvrmvr{(b-recv-rmv-r)}{\offsetb}{-90};
      \finalstate{(b-recv-ins-e)}{\offsetb}{-90};

      \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
      \draw[->, thick] (b-initial) --  (b-ins-exc) -- (b-recv-rmv-r) -- (b-recv-ins-e) -- (b-final);

      \draw[->, dashed, shorten >= 1] (a-rmv-r) -- (b-recv-rmv-r);
      \draw[->, dashed, shorten >= 1] (a-ins-e) -- (b-recv-ins-e);
      \draw[->, dashed, shorten >= 1] (b-ins-exc) -- (a-recv-ins-exc);
    \end{tikzpicture}
  }
  \caption{Modifications concurrentes d'une séquence répliquée LogootSplit}
  \label{fig:ls-example}
\end{figure}

Dans cet exemple, deux noeuds A et B répliquent et éditent collaborativement un document texte en utilisant LogootSplit.
Ils partagent initialement le même état : une séquence composée d'un seul bloc associant les identifiants $\betterid{i}{B1}{1..4}$ aux éléments "HRLO".
Les noeuds se mettent ensuite à éditer le document.

Le noeud A commence par supprimer l'élément "R" de la séquence.
LogootSplit génère l'opération $\trm{rmv}$ correspondante en utilisant l'identifiant de l'élément supprimé : $\betterid{i}{B1}{2}$.
Cette opération est intégrée à sa copie locale et envoyée au noeud B pour qu'il intègre cette modification à son tour.

Le noeud A insère ensuite l'élément "E" dans la séquence entre les éléments "H" et "L".
Le noeud A doit alors générer un identifiant $\trm{id}$ à associer à ce nouvel élément respectant la contrainte suivante :
\begin{equation*}
  \betterid{i}{B1}{1} \lid \trm{id} \lid \betterid{i}{B1}{3}
\end{equation*}
L'espace des identifiants de taille 1 étant saturé entre ces deux identifiants, A génère $\trm{id}$ en reprenant le premier tuple de l'identifiant du prédecesseur et en y concaténant un nouveau tuple : $\trm{id} = \betterid{i}{B1}{1} \oplus \betterid{f}{A1}{1}$.
LogootSplit génère l'opération $\trm{ins}$ correspondante, indiquant l'élément à insérer et sa position grâce à son identifiant.
Il intègre cette opération et la diffuse sur le réseau.

En parallèle, le noeud B insère l'élément "!" en fin de la séquence.
Comme le noeud B est l'auteur du bloc $\betterid{i}{B1}{1..4}$, il peut y ajouter de nouveaux éléments.
B associe donc l'identifiant $\betterid{i}{B1}{5}$ à l'élément "!" pour l'ajouter au bloc existant.
Il génère l'opération $\trm{ins}$ correspondante, l'intègre puis la diffuse.

Les noeuds se synchronisent ensuite.
Le noeud A reçoit l'opération $\trm{ins}(\betterid{i}{B1}{5},L)$.
Le noeud A détermine que cet élément doit être inséré à la fin de la séquence, puisque $\betterid{i}{B1}{4} \lid \betterid{i}{B1}{5}$.
Ces deux identifiants étant contigus, il ajoute cet élément au bloc existant.

De son côté, le noeud B reçoit tout d'abord l'opération $\trm{rmv}(\betterid{i}{B1}{2})$.
Le noeud B supprime donc l'élément correspondant de son état, "R".

Il reçoit ensuite l'opération $\trm{ins}(\betterid{i}{B1}{1}\betterid{f}{A1}{1},E)$.
Le noeud B insère cet élément entre les éléments "H" et "L", puisqu'on a :
\begin{equation*}
  \betterid{i}{B1}{1} \lid \betterid{i}{B1}{1}\betterid{f}{A1}{1} \lid \betterid{i}{B1}{3}
\end{equation*}

L'intention de chaque noeud est donc préservée et les copies convergent.
