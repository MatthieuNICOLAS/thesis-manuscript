\documentclass[12pt]{thesul}
%----------------------------------------------------------------------
%                               Packages
%----------------------------------------------------------------------
\usepackage{acronym} % \ac[p], \acl[p], \acs[p], \acf[p]
\usepackage{biblatex}
\bibliography{biblio.bib}
\usepackage{csquotes}
\usepackage[inline]{enumitem}
\usepackage[french]{minitoc}

\usepackage{color}
\AtBeginDocument{
\definecolor{pdfurlcolor}{rgb}{0,0,0}
\definecolor{pdfcitecolor}{rgb}{0,0,0}
\definecolor{pdflinkcolor}{rgb}{0,0,0}
\definecolor{light}{gray}{.85}
\definecolor{vlight}{gray}{.95}
\definecolor{darkgreen}{RGB}{77,172,38}
\definecolor{darkblue}{RGB}{5,113,176}
\definecolor{mydarkblue}{RGB}{116,173,209}
\definecolor{mydarkblueid}{RGB}{83,154,198}
\definecolor{mylightblue}{RGB}{171,217,233}
\definecolor{mydarkorange}{RGB}{244,109,67}
\definecolor{mylightorange}{RGB}{252,153,54}
\definecolor{mydarkred}{RGB}{215,48,39}
\definecolor{mydarkpurple}{RGB}{140,107,177}
\definecolor{mydarkpurpleid}{RGB}{136,86,167}
}

\usepackage{amssymb}
\usepackage{amsmath}
\interdisplaylinepenalty=2500
\newtheorem{definition}{Définition}
\newtheorem{myrule}{Règle}
\newtheorem{property}{Propriété}
\newtheorem{subproperty}{Propriété}[property]

\usepackage{algpseudocode}

\usepackage{hyperref}
\hypersetup{hidelinks}

\usepackage[draft,inline,nomargin,index]{fixme}
\fxsetup{theme=color,mode=multiuser,inlineface=\itshape,envface=\itshape}
\FXRegisterAuthor{go}{ago}{Gerald}
\FXRegisterAuthor{mn}{amn}{Matthieu}

\usepackage{tikz} % \begin{tikzpicture} \end{tikzpicture}
\usetikzlibrary{calc}
\usetikzlibrary{shapes.misc}

\usepackage[caption=false,font=footnotesize,labelfont=sf,textfont=sf]{subfig}

% Commands
%---------
\newcommand{\eg}{e.g. }
\newcommand{\ie}{c.-à-d. }

\newcommand{\headerparagraph}[1]{\textbf{\emph{#1}}\quad}

\newcommand{\inbb}[1]{\in \mathbb{#1}}
\newcommand{\mathlist}[2]{\set{#1_i \in #2}_{i \inbb{N}}}
\newcommand{\new}{\textbf{new}}
\newcommand{\trm}[1]{\mathit{#1}}
\newcommand{\set}[1]{\left\{#1\right\}} % set brace notation

\newcommand{\id}[3]{$\trm{#1}^{\trm{#2}}_{\trm{#3}}$}
\newcommand{\epoch}[1]{$\varepsilon_{#1}$}

\newcommand{\widthletter}{2em}
\newcommand{\widthblock}{3em}
\newcommand{\widthoriginepoch}{1.65em}
\newcommand{\widthepoch}{1.8em}

% Tikz styles
\tikzset{
    common/.style={anchor=west, draw, rectangle, minimum height=6mm},
    letter/.style={common, minimum width=\widthletter},
    block/.style={common, minimum width=\widthblock},
    epoch/.style={letter, rounded rectangle, rounded rectangle east arc=0pt, minimum width=\widthepoch},
    point/.style={insert path={ node[scale=5*sqrt(\pgflinewidth)]{.} }},
    op/.style={draw, circle, minimum size=2.7em},
    causalop/.style={op, double=white, inner sep=2pt},
    gc-rule-1/.style={dashed, thick, darkblue},
    gc-rule-2/.style={densely dotted, thick, darkgreen},
    cross/.style={
        path picture={
            \draw[mydarkred, very thick]
                (path picture bounding box.south east)--(path picture bounding box.north west)
                (path picture bounding box.south west)--(path picture bounding box.north east);
        }
    }
}


%-------------------------------------------------------------------
%                             Marges
%-------------------------------------------------------------------

% pour positionner les vraies marges:
%\SetRealMargins{1mm}{1mm}

%-------------------------------------------------------------------
%                             En-têtes
%-------------------------------------------------------------------

% Les en-têtes: quelques exemples
%\UppercaseHeadings
%\UnderlineHeadings
%\newcommand\bfheadings[1]{{\bf #1}}
%\FormatHeadingsWith{\bfheadings}
%\FormatHeadingsWith{\uppercase}
%\FormatHeadingsWith{\underline}
\newcommand\upun[1]{\uppercase{\underline{\underline{#1}}}}
\FormatHeadingsWith\upun

\newcommand\itheadings[1]{\textit{#1}}
\FormatHeadingsWith{\itheadings}

% pour avoir un trait sous l'en-tete:
\setlength{\HeadRuleWidth}{0.4pt}

%-------------------------------------------------------------------
%                         Les références
%-------------------------------------------------------------------

\NoChapterNumberInRef
\NoChapterPrefix

%-------------------------------------------------------------------
%                           Brouillons
%-------------------------------------------------------------------

% ceci ajoute une marque « brouillon » et la date
\ThesisDraft

%-------------------------------------------------------------------
%                   Pour collecter un glossaire et un index
%-------------------------------------------------------------------

\makeglossary
\makeindex

%-------------------------------------------------------------------
%                           Acronymes
%-------------------------------------------------------------------

% Acronyms
% --------
% \input{assets/acronyms.tex}
\acrodef{ADT}[ADT]{Abstract Data Type}
\acrodefplural{ADT}[ADTs]{Abstract Data Types}
\acrodef{CRDT}[CRDT]{Conflict-free Replicated Data Type}
\acrodefplural{CRDT}[CRDTs]{Conflict-free Replicated Data Types}
\acrodef{JIT}[JIT]{Just-In-Time}
\acrodef{LCA}[PPAC]{Plus Petit Ancêtre Commun}
\acrodef{OT}[OT]{Operational Transformation}
\acrodefplural{OT}[OT]{Operational Transformations}
\acrodef{P2P}[P2P]{Pair-à-Pair}
\acrodef{SEC}[SEC]{Cohérence forte à terme}

%-------------------------------------------------------------------
%                           Couleurs
%-------------------------------------------------------------------

% \input{assets/colours.tex}

%-------------------------------------------------------------------
%                     Global custom tikz commands
%-------------------------------------------------------------------

% \input{assets/tikz_presets.tex}

\begin{document}


      \OddHead={{\leftmark\rightmark}{\hfil\slshape\rightmark}}
      \EvenHead={{\leftmark}{{\slshape\leftmark}\hfil}}
      \OddFoot={\hfil\thepage}
      \EvenFoot={\thepage\hfil}
      \pagestyle{ThesisHeadingsII}


%-------------------------------------------------------------------
%                          Encadrements
%-------------------------------------------------------------------

% encadre les chapitres dans la table des matières:
% (ces commandes doivent figurer apres \begin{document}

\FrameChaptersInToc
%\FramePartsInToc


%-------------------------------------------------------------------
%            Réinitialisation de la numérotation des chapitres
%-------------------------------------------------------------------

% Si la commande suivante est présente,
% elle doit figurer APRÈS \begin{document}
% et avant la première commande \part
\ResetChaptersAtParts

%-------------------------------------------------------------------
%               mini-tables des matières par chapitre
%-------------------------------------------------------------------

% préparer les mini-tables des matières par chapitre.
% (commande de minitoc.sty)
\dominitoc

%-------------------------------------------------------------------
%                         Page de titre:
%-------------------------------------------------------------------

\ThesisTitle{Ré-identification efficace dans les types de données répliquées sans conflit (CRDTs)}
\ThesisDate{TODO: Définir une date}
\ThesisAuthor{Matthieu Nicolas}

% Type de la these
\ThesisUL
% Jury:

% (ne pas mettre de \\ apres la dernière entree)

% Exemple de création d'une nouvelle catégorie dans le jury:

\NewJuryCategory{family}{\it Membre de la famille :}
                        {\it Membres de la famille :}

\family={Mon frère\\Ma sœur}

\def\blanc{\hspace*{1cm}}

\President    = {Stephan Merz}
\Rapporteurs  = {Le rapporteur 1&de Paris\\
                 Le rapporteur 2\\
                 \blanc suite&taratata\\
                 Le rapporteur 3}
\Examinateurs = {L'examinateur 1&d'ici\\
                 L'examinateur 2}
%\Invites=       {}

% Création de la page de titre:
\MakeThesisTitlePage

%-------------------------------------------------------------------


%-------------------------------------------------------------------
%                          remerciements
%-------------------------------------------------------------------

%\DontFrameThisInToc
\begin{ThesisAcknowledgments}
Les remerciements.
\end{ThesisAcknowledgments}

%-------------------------------------------------------------------
%                            dédicace
%-------------------------------------------------------------------

\begin{ThesisDedication}
Je dédie cette thèse\\
à ma machine.\\
Oui, à Pandore,\\
qui fut la première de toutes.
\end{ThesisDedication}


%-------------------------------------------------------------------
%                  écriture de `Chapitre' et `Partie'
%                      dans la table des matières
%-------------------------------------------------------------------

\WritePartLabelInToc
\WriteChapterLabelInToc

%-------------------------------------------------------------------
%                        table des matières
%-------------------------------------------------------------------

\tableofcontents

%-------------------------------------------------------------------
%              Exemple d'utilisation de \SpecialSection
%-------------------------------------------------------------------
%\SpecialSection{Introduction générale}

\DontWriteThisInToc
\listoffigures

\mainmatter
\NumberThisInToc
\chapter*{Introduction}
\minitoc
\section{Contexte}
\section{Questions de recherche}
\section{Contributions}
\section{Plan du manuscrit}
% \input{assets/intro}

% \NumberThisInToc
% \chapter*{Problématique}
% \minitoc
% \input{assets/chapter_problematic}

\NumberThisInToc
\chapter{État de l'art}
\minitoc
\section{Transformées opérationnelles}
\section{Séquences répliquées sans conflits}
\subsection{Types de données répliquées sans conflits}
\subsubsection{Principes}

\begin{itemize}
  \item Nouvelles spécifications des types de données existants
  \item Structures conçues pour être répliquées au sein d'un système
  \item Et être modifiées sans coordination par ses différents noeuds
  \item Doivent donc supporter de nouveaux scénarios uniquement possible dans des exécutions parallèles
  \item Et définir une sémantique pour ces scénarios inédits
  \begin{itemize}
    \item Exemple du Registre avec LWW-Register et MV-Register ?
  \end{itemize}
  \item Pour gérer ces scénarios, intègrent un mécanisme de résolution de conflits directement au sein de leur spécification
  \item Garantissent la cohérence forte à terme
\end{itemize}

\subsubsection{Familles de types de données répliquées sans conflits}

\begin{itemize}
  \item Une catégorisation des CRDTs a été proposée
  \item Propose de répartir les CRDTs en différentes familles en fonction de la méthode de synchronisation utilisée
  \item Chacune de ces méthodes de synchronisation implique des contraintes sur la couche réseau du système et entraîne des répercussions sur la structure de données elle-même
  \item Types de données répliquées sans conflits à base d'états \cite{shapiro_2011_crdt, shapiro:inria-00555588}
  \begin{itemize}
    \item Les noeuds partagent leur état de manière périodique
    \item Une fonction \emph{merge} permet aux noeuds de fusionner leur état courant avec un autre état reçu
    \item Aucune hypothèse sur la partie réseau autre que les noeuds arrivent à communiquer à terme
    \item Pas un problème si états perdus, les prochains intégreront les informations de ces derniers
    \item Pas un problème si états reçus dans le désordre, la fonction \emph{merge} est commutative
    \item Pas un problème si états reçus plusieurs fois, \emph{merge} est idempotent
    \item Mais nécessite de conserver au sein de la structure de données assez d'informations pour proposer une telle fonction de \emph{merge}
    \item Par exemple, besoin de conserver une trace des éléments supprimés pour empêcher leur réapparition suite à une fusion d'états
    \item \mnnote{TODO: Ajouter forces, faiblesses et cas d'utilisation de cette approche}
  \end{itemize}
  \item Types de données répliquées sans conflits à base d'opérations \cite{shapiro_2011_crdt, shapiro:inria-00555588, 10.1145/2596631.2596632, baquero2017pure}
  \begin{itemize}
    \item Les noeuds partagent uniquement des opérations représentant leurs modifications
    \item Une modification peut se formaliser en deux étapes
    \item \emph{prepare}, qui permet de générer une opération correspondant à une modification
    \item \emph{effect}, qui permet d'appliquer l'effet de la modification à un état
    \item Les opérations concurrentes doivent être commutatives pour assurer la convergence
    \item Mais pas de contraintes sur les opérations causalement liées
    \item Pas de contraintes non plus sur l'idempotence des opérations
    \item Nécessite donc généralement d'ajouter une couche \emph{livraison} pour faire le lien entre le réseau et le CRDT
    \item Permet d'attacher des informations de causalité aux opérations locales avant de les envoyer
    \item Permet de ré-ordonner et filtrer les opérations distantes reçues avant de les fournir au CRDT
    \item Besoin d'un mécanisme d'anti-entropie \cite{10.1109/TSE.1983.236733} pour assurer que l'ensemble des noeuds observent l'ensemble des opérations et ainsi garantir la convergence
    \item Permet de lisser la consommation réseau
    \item Offre des temps d'intégration et de propagation des modifications rapides
    \item Mais accumule des métadonnées puisque les noeuds doivent conserver les opérations passées pour permettre à un nouveau noeud de rejoindre la collaboration et de se synchroniser
    \item Possible de tronquer le log des opérations en se basant sur la stabilité causale \cite{10.1007/978-3-662-43352-2_11} afin de limiter cette accumulation de métadonnées
  \end{itemize}
  \item Types de données répliquées sans conflits à base de différences \cite{almeida2015delta, Almeida_2018}
\end{itemize}

\subsubsection{Adoption dans la littérature et l'industrie}

\begin{itemize}
  \item Conception et développement de librairies mettant à disposition des développeurs d'applications des types de données composés \cite{Nicolaescu2015Yjs, Nicolaescu2016YATA, yjsimplem, jsoncrdt2017, automerge}
  \item Conception de langages de programmation intégrant des CRDTs comme types primitifs, destinés au développement d'applications distribuées \cite{Meiklejohn2015Lasp2, DePorre2020cscript}
  \item Conception et implémentation de bases de données distribuées, relationnelles ou non, privilégiant la disponibilité et la minimisation de la latence à l'aide des CRDTs \cite{RiakKV, AntidoteDB, Anna2021, Concordant, yu:hal-02983557}
  \item Conception d'un nouveau paradigme d'applications, Local-First Software, dont une des fondations est les CRDTs \cite{localfirstsoftware2019, pushpin2020}
  \item Éditeurs collaboratifs temps réel à large échelle et offrant de nouveaux scénarios de collaboration grâce aux CRDTs \cite{Nedelec2016CRATE, MUTE2017}
\end{itemize}

\subsection{Approches pour les séquences répliquées sans conflits}
\subsubsection{Approche à pierres tombales}

\begin{itemize}
  \item WOOT \cite{oster:inria-00108523, Weiss_2007, ahmednacer:inria-00629503}
  \item RGA \cite{ROH2011354}
  \item RGASplit \cite{briot:hal-01343941}
\end{itemize}

\subsubsection{Approche à identifiants densément ordonnés}

\begin{itemize}
  \item Treedoc \cite{5158449}
  \item Logoot \cite{WeissICDCS09, weiss:hal-00450416}
\end{itemize}

\section{LogootSplit}
\subsection{Identifiants}
\subsubsection{Composition}
\subsubsection{Stratégie d'allocation}
\subsection{Aggrégation dynamique d'élements en blocs}
\subsection{Limites}
\section{Mitigation du surcoût des séquences répliquées sans conflits}
\subsection{Core-Nebula}
\subsection{LSEQ}

\mnnote{Serait intéressant d'avoir une implémentation combinant LogootSplit et LSEQ pour vérifier si les contraintes sur la création de blocs dans LogootSplit ne "sabotent" pas la croissance polylogarithmique des identifiants de LSEQ}

\section{Synthèse}

% \include{assets/chapter_soa_ergm}

\NumberThisInToc
\chapter{Présentation de l'approche}
\minitoc

Nous proposons un nouveau \ac{CRDT} pour la \emph{Sequence} appartenant à l'approche des identifiants densément ordonnées : RenamableLogootSplit \cite{nicolas:hal-01932552,nicolas:hal-02526724}.
Cette structure de données permet aux pairs d'insérer et de supprimer des éléments au sein d'une séquence répliquée.
Nous introduisons une opération de renommage qui permet de
\begin{enumerate*}
  \item réassigner des identifiants plus courts aux différents éléments de la séquence
  \item fusionner les blocs composant la séquence.
\end{enumerate*}
Ces deux actions permettent à l'opération de renommage de produire un nouvel état minimisant son surcoût en métadonnées.

\section{Modèle du système}

Le système est composé d'un ensemble dynamique de noeuds, les noeuds pouvant rejoindre puis quitter la collaboration tout au long de sa durée.
Les noeuds collaborent afin de construire et maintenir une séquence à l'aide de RenamableLogootSplit.
Chaque noeud possède une copie de la séquence et peut l'éditer sans se coordonner avec les autres.
Les modifications des noeuds prennent la forme d'opérations qui sont appliquées immédiatement à leur copie locale.
Les opérations sont ensuite transmises de manière asynchrone aux autres noeudds pour qu'ils puissent à leur tour appliquer les modifications à leur copie.

Les noeuds communiquement par l'intermédiaire d'un réseau \ac{P2P}.
Ce réseau est non-fiable : les messages peuvent être perdus, ré-ordonnés ou même livrés à plusieurs reprises.
Le réseau peut aussi être sujet à des partitions, qui séparent alors les noeuds en des sous-groupes disjoints.
Afin de compenser les limitations du réseau, les noeuds reposent sur une couche de livraison de messages.

Puisque RenamableLogootSplit est une extension de LogootSplit, il partage les mêmes contraintes sur la livraison de messages.
La couche de livraison de messages sert donc à livrer les messages à l'application exactement une fois.
La couche de livraison de messages a aussi pour tâche de garantir la livraison des opérations de suppression après les opérations d'insertion correspondantes.
Aucune autre contrainte n'existe sur l'ordre de livraison des opérations.
Finalement, la couche de livraison intègre aussi un mécanisme d'anti-entropie \cite{10.1109/TSE.1983.236733}.
Ce mécanisme permet aux noeuds de se synchroniser par paires, en détectant et ré-échangeant les messages perdus.

\section{Définition de l'opération de renommage}
\subsection{Objectifs}
\subsection{Propriétés}
\subsection{Contraintes} % Non-bloquante, performante (pour un utilisateur)

\NumberThisInToc
\chapter{Renommage dans un système centralisé}
\minitoc
\section{RenamableLogootSplit}
\subsection{Opération de renommage proposée}

Notre opération de renommage permet à RenamableLogootSplit de réduire le surcoût en métadonnées des séquences répliquées.
Pour ce faire, elle réassigne des identifiants arbitraires aux éléments de la séquence.

\begin{figure}[t!]
  \centering
  \subfloat[Selecting the new identifier of the first element]{
      \begin{minipage}{\linewidth}
          \centering
          \begin{tikzpicture}
              \path
                  node {\textbf{A}}
                  to ++(0:\widthletter) node[letter, label=below:{\id{i}{B0}{0}}] {H}
                  to ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{A0}{0}}] {E}
                  to ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{1..2}}] (LO) {LO}
                  to ++(0:4 * \widthletter) node[letter, fill=mydarkblue, label=below:{\color{mydarkblueid}\id{i}{A1}{0}}] (H) {H};

              \draw[->, thick] (LO) -- node[below, align=center]{\emph{rename}} (H);
          \end{tikzpicture}
          \label{fig:renaming-first-id}
      \end{minipage}}
  \hfil
  \subfloat[Selecting the new identifiers of the remaining ones]{
      \begin{minipage}{\linewidth}
          \centering
          \begin{tikzpicture}
              \path
                  node {\textbf{A}}
                  to ++(0:\widthletter) node[letter, label=below:{\id{i}{B0}{0}}] {H}
                  to ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{A0}{0}}] {E}
                  to ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{1..2}}] (LO) {LO}
                  to ++(0:4 * \widthletter) node[letter, fill=mydarkblue, label=below:{\color{mydarkblueid}\id{i}{A1}{0}}] (H) {H}
                  to ++(0:\widthletter) node[letter, fill=mydarkblue, label=below:{\color{mydarkblueid}\id{i}{A1}{1}}] {E}
                  to ++(0:\widthletter) node[letter, fill=mydarkblue, label=below:{\color{mydarkblueid}\id{i}{A1}{2}}] {L}
                  to ++(0:\widthletter) node[letter, fill=mydarkblue, label=below:{\color{mydarkblueid}\id{i}{A1}{3}}] {O};

                  \draw[->, thick] (LO) -- node[below, align=center]{\emph{rename}} (H);
              \end{tikzpicture}
          \label{fig:renaming-second-id}
      \end{minipage}}
  \hfil
  \subfloat[Final state obtained]{
      \begin{minipage}{\linewidth}
          \centering
          \begin{tikzpicture}
              \path
                  node {\textbf{A}}
                  to ++(0:\widthletter) node[letter, label=below:{\id{i}{B0}{0}}] {H}
                  to ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{A0}{0}}] {E}
                  to ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{1..2}}] (LO) {LO}
                  to ++(0:4 * \widthletter) node[block, fill=mydarkblue, label=below:{\color{mydarkblueid}\id{i}{A1}{0..3}}] (HELO) {HELO};

              \draw[->, thick] (LO) -- node[below, align=center]{\emph{rename}} (HELO);
          \end{tikzpicture}
          \label{fig:renaming-final-state}
      \end{minipage}}
  \caption{Renaming the sequence on node \emph{A}}
  \label{fig:renaming}
\end{figure}

Son comportement est illustré dans la \autoref{fig:renaming}.
Dans cet exemple, le noeud A initie une opération \emph{rename} sur son état local.
Tout d'abord, le noeud A réutilise l'identifiant du premier élément de la séquence (\id{i}{B0}{0}) mais en le modifiant avec son propre identifiant de noeud (\textbf{A}) et numéro de séquence actuel (\emph{1}).
De plus, son offset est mis à 0.
Le noeud A réassigne l'identifiant résultant (\id{i}{A1}{0}) au premier élément de la séquence, comme décrit dans \autoref{fig:renaming-first-id}.
Ensuite, le noeud A dérive des identifiants contigus pour tous les éléments restants en incrémentant de manière successive l'offset (\id{i}{A1}{1}, \id{i}{A1}{2}, \id{i}{A1}{3}), comme présenté dans \autoref{fig:renaming-second-id}.
Comme nous assignons des identifiants consécutifs à tous les éléments de la séquence, nous pouvons au final aggréger ces éléments en un seul bloc, comme illustré en \autoref{fig:renaming-final-state}.
Ceci permet aux noeuds de bénéficier au mieux de la fonctionnalité des blocs et de minimiser le surcoût en métadonnés de l'état résultat.

Pour converger, les autres noeuds doivent renommer leur état de manière identique.
Cependant, ils ne peuvent pas simplement remplacer leur état courant par l'état généré par le renommage.
En effet, ils peuvent avoir modifié en concurrence leur état.
Afin de ne pas perdre ces modifications, les noeuds doivent traiter l'opération \emph{rename} eux-mêmes.
Pour ce faire, le noeud qui a généré l'opération \emph{rename} diffuse son \emph{ancien état} aux autres.
En utilisant cet état, les autres noeuds calculent le nouvel identifiant de chaque identifiant renommé.
Concernant les identifiants insérés de manière concurrente au renommage, nous expliquons dans \autoref{sec:ops-concurrent-to-rename} comment les noeuds peuvent les renommer de manière déterministe.

\subsection{Gestion des opérations concurrentes au renommage}

\label{sec:ops-concurrent-to-rename}

Après avoir appliqué des opérations \emph{rename} sur leur état local, les noeuds peuvent recevoir des opérations concurrentes.
La \autoref{fig:concurrent-insert-rename-inconsistent} illustre de tels cas.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}
      \path
          node {\textbf{A}}
          to ++(0:\widthletter) node[letter, label=below:{\id{i}{B0}{0}}] {H}
          to ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{\,A0}{0}}] {E}
          to ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{1..2}}] (S0A-right) {LO}
          to ++(0:5 * \widthletter) node[block, fill=mydarkblue,
                  label={below:{\color{mydarkblueid}\id{i}{A1}{0..3}} }
                      ] (S1A) {HELO}
          to ++(0:8 * \widthletter) node[block, fill=mydarkblue,
                  label={below:{\color{mydarkblueid}\id{i}{A1}{0..3}} }
                      ] (S2A-left) {HELO}
          to ++(0:1.18 * \widthblock) node[letter, fill=mylightorange, cross,
                  label={above:{\color{mylightorange}\id{i}{B0}{0}\id{m}{B1}{0}} }
                      ] {L};

      \path
          to ++(270:2) node {\textbf{B}}
          to ++(0:\widthletter) node[letter, label=below:{\id{i}{B0}{0}}] {H}
          to ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{\,A0}{0}}] {E}
          to ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{1..2}}] (S0B-right) {LO}
          to ++(0:5 * \widthletter) node[letter, label=below:{\id{i}{B0}{0}}] (S1B-left) {H}
          to ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{\,A0}{0}}] {E}
          to ++(0:\widthletter) node[letter, fill=mylightorange, label=below:{\color{mylightorange}\id{i}{B0}{0}\id{m}{B1}{0}}] {L}
          to ++(0:\widthletter) node[block, label=above:{\id{i}{B0}{1..2}}] (S1B-right) {LO};


      \draw[->, thick] (S0A-right) -- node[above, align=center]{\emph{rename}} (S1A);
      \draw[dotted] (S1A) -- (S2A-left);
      \draw[->, thick] (S0B-right) -- node[below, align=center]{\emph{insert "l"}\\\emph{between}\\\emph{"e" and "l"}} (S1B-left);
      \draw[dashed, ->, thick, shorten >= 3] (S1B-right.east) -- node[below right, align=center]{\emph{insert "l" at} {\color{mylightorange}\id{i}{B0}{0}\id{m}{B1}{0}}} (S2A-left.west);

  \end{tikzpicture}
  \caption{Concurrent update leading to inconsistency}
  \label{fig:concurrent-insert-rename-inconsistent}
\end{figure}

Dans cet exemple, le noeud B insère un nouvel élément "L", lui assigne l'identifiant \id{i}{B0}{0}\id{m}{B1}{0} et diffuse cette modification, de manière concurrente à l'opération \emph{rename} décrite dans la \autoref{fig:renaming}.
À la réception de l'opération \emph{insert}, le noeud A ajoute l'élément inséré au sein de sa séquence, en utilisant l'identifiant de l'élément pour déterminer sa position.
Cependant, puisque les identifiants ont été modifiés par l'opération \emph{rename} concurrente, le noeud A insère le nouvel élément à la fin de sa séquence (puisque \id{i}{A1}{3} < \id{i}{B0}{0}\id{m}{B1}{0}) au lieu d'à sa position prévue.
Comme décrit par cet exemple, appliquer naivement les modifications concurrentes provoquerait des anomalies.
Il est donc nécessaire de traiter les opérations concurrentes aux opérations \emph{rename} de manière particulière.

Tout d'abord, les noeuds doivent détecter les opérations concurrentes aux opérations \emph{rename}.
Pour cela, nous utilisons un système basé sur des \emph{époques}.
Initialement, la séquence répliquée débute à l'époque \emph{origine} notée \epoch{0}.
Chaque opération \emph{rename} introduit une nouvelle époque et permet aux noeuds d'y avancer depuis l'époque précédente.
L'époque générée est caractérisée en utilisant l'identifiant du noeud et son numéro de séquence courant au moment de la génération de l'opération \emph{rename}.
Par exemple, l'opération \emph{rename} décrite dans \autoref{fig:concurrent-insert-rename-inconsistent} permet aux noeuds de faire progresser leur état de \epoch{0} à \epoch{A1}.

Au fur et à mesure qu'ils reçoivent des opérations \emph{rename}, les noeuds construisent et maintiennent localement la \emph{chaîne des époques}, une structure de données ordonnant les époques en fonction de leur relation \emph{parent-enfant}.
De plus, les noeuds marquent chaque opération avec leur époque courante au moment de génération de l'opération.
À la réception d'une opération, les noeuds compare l'époque de l'opération à la leur.
Si les époques diffèrent, les noeuds doivent transformer l'opération avant de pouvoir l'appliquer.
Les noeuds déterminent par rapport à quelles opérations \emph{rename} doit être transformée l'opération reçue en calculant le chemin entre l'époque de l'opération et leur époque courante en utilisant la \emph{chaîne des époques}.
Pour ce faire, il est nécessaire d'ajouter la règle suivante aux contraintes existante sur la livraison des opérations : les opérations doivent désormais être livrées après l'opération \emph{rename} qui a introduit leur époque.

Les noeuds utilisent la fonction \textsc{renameId}, décrite dans \autoref{alg:renameId}, pour transformer les opérations \emph{insert} et \emph{remove} par rapport aux opérations \emph{rename}.
Cet algorithme associe les identifiants d'une époque \emph{parente} aux identifiants correspondant dans l'époque \emph{enfant}.
L'idée principale de cet algorithm est de renommer les identifiants inconnus au moment de la génération de l'opération \emph{rename} en utilisant leur prédecesseur.
Un exemple est présenté dans la \autoref{fig:concurrent-insert-rename-fixed}.
Cette figure décrit le même scénario que la \autoref{fig:concurrent-insert-rename-inconsistent}, à l'exception que le noeud A utilises \textsc{renameId} pour renommer les identifiants générés de façon concurrente avant de les insérer dans son état.

\begin{figure}[!ht]
  \footnotesize
  \begin{algorithmic}
      \Function {renameId}{id, renamedIds, nId, nSeq}
          % \State \Comment{$id$ is the id to rename}
          % \State \Comment{$renamedIds$ is the list of ids of the \emph{former state}}
          % \State \Comment{$nId$ is $node~id$ of the node that issued the \emph{rename} op}
          % \State \Comment{$nSeq$ is $node~seq$ of the node that issued the \emph{rename} op}
          \State length $\gets$ renamedIds.length
          \State firstId $\gets$ renamedIds[0]
          \State lastId $\gets$ renamedIds[length - 1]
          \State pos $\gets$ position(firstId)
          \\
          \If{id < firstId}
              \State newFirstId $\gets$ \new~Id(pos, nId, nSeq, 0)
              \State \Return renIdLessThanFirstId(id, newFirstId)
          \ElsIf{id $\in$ renameIds}
              \State index $\gets$ findIndex(id, renamedIds)
              \State \Return \new~Id(pos, nId, nSeq, index)
          \ElsIf{lastId < id}
              \State newLastId $\gets$ \new~Id(pos, nId, nSeq, length - 1)
              \State \Return renIdGreaterThanLastId(id, newLastId)
          \Else
              \State \Return renIdFromPredId(id, renamedIds, pos, nId, nSeq)
          \EndIf
      \EndFunction
      \\
      \Function {renIdFromPredId}{id, renamedIds, pos, nId, nSeq}
          \State index $\gets$ findIndexOfPred(id, renamedIds)
          \State newPredId $\gets$ \new~Id(pos, nId, nSeq, index)
          \\
          \State \Return concat(newPredId, id)
      \EndFunction
  \end{algorithmic}
  \caption{Main functions to rename an identifier}
  \label{alg:renameId}
\end{figure}

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}
      \path
          node {\textbf{A}}
          to ++(0:0.5 * \widthletter) node[epoch] {\epoch{0}}
          to ++(0:1.05 * \widthoriginepoch) node[letter, label=below:{\id{i}{B0}{0}}] {H}
          to ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{\,A0}{0}}] {E}
          to ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{1..2}}] (S0A-right) {LO}
          to ++(0:5 * \widthletter) node[epoch] (S1A-left) {\epoch{A1}}
          to ++(0:1.3 * \widthepoch) node[block, fill=mydarkblue,
                  label={below:{\color{mydarkblueid}\id{i}{A1}{0..3}} }
                      ] (S1A-right) {HELO}
          to ++(0:8 * \widthletter) node[epoch] (S2A-left) {\epoch{A1}}
          to ++(0:1.3 * \widthepoch) node[block, fill=mydarkblue,
                  label={below:{\color{mydarkblueid}\id{i}{A1}{0..1}} }
                      ] {HE}
          to ++(0:\widthblock) node[letter, fill=mylightblue,
                  label={above:{\color{mylightblue!20!mydarkblueid}\id{i}{A1}{1}\id{i}{B0}{0}\id{m}{B1}{0}} }
                      ] {L}
          to ++(0:\widthletter) node[block, fill=mydarkblue,
                  label={below:{\color{mydarkblueid}\id{i}{A1}{2..3}} }
                      ] {LO};

      \path
          to ++(270:2) node {\textbf{B}}
          to ++(0:0.5 * \widthletter) node[epoch] {\epoch{0}}
          to ++(0:1.05 * \widthoriginepoch) node[letter, label=below:{\id{i}{B0}{0}}] {H}
          to ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{\,A0}{0}}] {E}
          to ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{1..2}}] (S0B-right) {LO}
          to ++(0:5 * \widthletter) node[epoch] (S1B-left) {\epoch{0}}
          to ++(0:1.05 * \widthoriginepoch) node[letter, label=below:{\id{i}{B0}{0}}] {H}
          to ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{\,A0}{0}}] {E}
          to ++(0:\widthletter) node[letter, fill=mylightorange, label=below:{\color{mylightorange}\id{i}{B0}{0}\id{m}{B1}{0}}] {L}
          to ++(0:\widthletter) node[block, label=above:{\id{i}{B0}{1..2}}] (S1B-right) {LO};


      \draw[->, thick] (S0A-right) -- node[above, align=center]{\emph{rename to \epoch{A1}}} (S1A-left);
      \draw[dotted] (S1A-right) -- (S2A-left);
      \draw[->, thick] (S0B-right) -- node[below, align=center]{\emph{insert "l"}\\\emph{between}\\\emph{"e" and "l"}} (S1B-left);
      \draw[dashed, ->, thick, shorten >= 3] (S1B-right.east) -- node[below right, align=center]{\emph{insert "l" at} {\color{mylightorange}\id{i}{B0}{0}\id{m}{B1}{0}}} (S2A-left.west);

  \end{tikzpicture}
  \caption{Renaming concurrent update using \textsc{renameId} before applying it to maintain intended order}
  \label{fig:concurrent-insert-rename-fixed}
\end{figure}

L'algorithme procède de la manière suivante.
Tout d'abord, le noeud récupère le prédecesseur de l'identifiant donné \id{i}{B0}{0}\id{m}{B1}{0} dans l'ancien état : \id{i}{B0}{0}\id{f}{A0}{0}.
Ensuite, il calcule l'équivalent de \id{i}{B0}{0}\id{f}{A0}{0} dans l'état renommé : \id{i}{A1}{1}.
Finalement, le noeud A concatène cet identifiant et l'identifiant donné pour générer l'identifiant correspondant l'époque \emph{enfant} : \id{i}{A1}{1}\id{i}{B0}{0}\id{m}{B1}{0}.
En réassignant cet identifiant à l'élément inséré de manière concurrente, le noeud A peut l'insérer à son état tout en préservant l'ordre souhaité.

\textsc{renameId} permet aussi aux noeuds de gérer le cas contraire : intégrer des opérations \emph{rename} distantes sur leur copie locale alors qu'ils ont précédemment intégré des modifications concurrentes.
Ce cas correspond à celui du noeud B dans la \autoref{fig:concurrent-insert-rename-fixed}.
À la réception de l'opération \emph{rename} du noeud A, le noeud B utilise \textsc{renameId} sur chacun des identifiants de son état pour le renommer et atteindre un état équivalent à celui du noeud A.

\autoref{alg:renameId} présente seulement le cas principal de \textsc{renameId}, \ie le cas où l'identifiant à renommer appartient à l'interval des identifiants formant l'ancien état ($\trm{firstId} \leq \trm{id} \leq \trm{lastId}$).
Les fonctions pour gérer les autres cas, \ie les cas où l'identifiant à renommer n'appartient pas à cet interval ($\trm{id} < \trm{firstId}$ ou $\trm{lastId} < \trm{id}$), sont présentées dans \autoref{app:rename-id}.

L'algorithme que nous présentons ici permet aux noeuds de renommer leur état identifiant par identifiant.
Une extension possible est de concevoir \textsc{renameBlock}, une version améliorée qui renomme l'état bloc par bloc.
\textsc{renameBlock} réduirait le temps d'intégration des opérations \emph{rename}, puisque sa complexité temporelle ne dépendrait plus du nombre d'identifiants (\ie du nombre d'éléments) mais du nombre de blocs.
De plus, son exécution réduirait le temps d'intégration des prochaines opérations \emph{rename} puisque le mécanisme de renommage regroupe les éléments en moins de blocs.

\subsection{Processus d'intégration d'une opération}
\subsection{Évolution du modèle de cohérence}

\mnnote{TODO: Revoir si une livraison causale de l'opération \emph{rename} (et non epoch-based) peut avoir un intérêt}

\subsection{Récupération de la mémoire des états précédents}
\section{Validation}
\subsection{Preuve de correction}
\subsection{Complexité temporelle}
\section{Discussion}
\subsection{Stockage des états précédents sur disque}
\subsection{Utilisation de l'opération de renommage comme snapshot}

\begin{itemize}
  \item L'opération de renommage embarque la somme de toutes les opérations passées sous la forme du \emph{former state}
  \item On peut à tout moment re-calculer l'état courant du document à partir de l'opération de renommage primaire, des opérations concurrentes à cette dernière et des opérations générées depuis
  \item Peut utiliser ce principe pour le mécanisme de synchronisation
  \item Lorsqu'un nouveau pair rejoint la collaboration, le noeud avec lequel il se synchronise peut lui fournir uniquement ce sous-ensemble des opérations
  \item De la même manière, on pourrait généraliser l'utilisation de cette méthode de synchronisation
  \item À la réception d'une demande de synchronisation d'un pair présentant un important retard, le noeud peut choisir d'employer cette méthode
  \begin{itemize}
    \item Plutôt que de lui envoyer et de lui faire rejouer l'ensemble des opérations
  \end{itemize}
  \item La question étant de comment procéder pour quantifier ce retard et pour définir le seuil à partir duquel ce retard est considéré comme important
  \item Cette méthode de synchronisation pose néanmoins le problème suivant
  \item Le pair synchronisé de cette manière ne possède qu'une partie du log des opérations
  \item S'il reçoit ensuite une demande de synchronisation d'un autre pair, il est possible qu'il ne puisse y répondre
  \begin{itemize}
    \item Cas où il manque à l'autre pair juste une opération d'avant le renommage (possible si les dépendances causales ne sont pas requises pour intégrer l'opération de renommage)
  \end{itemize}
  \item Dans ce cas, ne peut pas fournir la seule opération manquante au pair qui la demande
  \begin{itemize}
    \item \mnnote{NOTE: Mais dans ce cas, le pair peut tout à fait générer un état courant à jour à partir des infos qu'il possède puisque l'opération qui lui manque est intégrée dans l'opé de renommage}
  \end{itemize}
  \item \mnnote{TODO: Étudier si y a un intérêt à privilégier la synchronisation basée sur l'intégration successive de toutes les opérations quand on a cette méthode de synchronisation par snapshot/checkpoint de possible}
\end{itemize}

\subsection{Compression de l'opération de renommage}
\subsection{Limitation de la taille de l'opération de renommage}
\section{Conclusion}
% \include{assets/chapter_baye_approach}

\NumberThisInToc
\chapter{Renommage dans un système distribué}
\minitoc
\section{RenamableLogootSplit v2}
\subsection{Conflits en cas de renommages concurrents}

Nous considérons à présent les scénarios avec des opérations \emph{rename} concurrentes.
\autoref{fig:conflicting-rename-operations} développe le scénario décrit précédemment dans \autoref{fig:concurrent-insert-rename-fixed}.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}
      \path
          node {\textbf{A}}
          to ++(0:0.5 * \widthletter) node[epoch] {\epoch{0}}
          to ++(0:1.05 * \widthoriginepoch) node[letter, label=below:{\id{i}{B0}{0}}] {H}
          to ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{\,A0}{0}}] {E}
          to ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{1..2}}] (S0A-right) {LO}
          to ++(0:5 * \widthletter) node[epoch] (S1A-left) {\epoch{A1}}
          to ++(0:1.3 * \widthepoch) node[block, fill=mydarkblue,
                  label={below:{\color{mydarkblueid}\id{i}{A1}{0..3}} }
                      ] (S1A-right) {HELO}
          to ++(0:8 * \widthletter) node[epoch] (S2A-left) {\epoch{A1}}
          to ++(0:1.3 * \widthepoch) node[block, fill=mydarkblue,
                  label={below:{\color{mydarkblueid}\id{i}{A1}{0..1}} }
                      ] {HE}
          to ++(0:\widthblock) node[letter, fill=mylightblue,
                  label={above:{\color{mylightblue!20!mydarkblueid}\id{i}{A1}{1}\id{i}{B0}{0}\id{m}{B1}{0}} }
                      ] {L}
          to ++(0:\widthletter) node[block, fill=mydarkblue,
                  label={below:{\color{mydarkblueid}\id{i}{A1}{2..3}} }
                      ] (S2A-right) {LO};

      \path
          to ++(270:3) node {\textbf{B}}
          to ++(0:0.5 * \widthletter) node[epoch] {\epoch{0}}
          to ++(0:1.05 * \widthoriginepoch) node[letter, label=below:{\id{i}{B0}{0}}] {H}
          to ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{\,A0}{0}}] {E}
          to ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{1..2}}] (S0B-right) {LO}
          to ++(0:5 * \widthletter) node[epoch] (S1B-left) {\epoch{0}}
          to ++(0:1.05 * \widthoriginepoch) node[letter, label=below:{\id{i}{B0}{0}}] {H}
          to ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{\,A0}{0}}] {E}
          to ++(0:\widthletter) node[letter, fill=mylightorange, label=below:{\color{mylightorange}\id{i}{B0}{0}\id{m}{B1}{0}}] {L}
          to ++(0:\widthletter) node[block, label=above:{\id{i}{B0}{1..2}}] (S1B-right) {LO}
          to ++(0:5 * \widthletter) node[epoch] (S2B-left) {\epoch{B2}}
          to ++(0:1.3 * \widthepoch) node[block, fill=mydarkpurple,
                  label={ [] below:{\color{mydarkpurpleid}\id{i}{B2}{0..4}} }
              ] (S2B-right) {HELLO};

      \draw[->, thick] (S0A-right) -- node[above, align=center]{\emph{rename to \epoch{A1}}} (S1A-left);
      \draw[dotted] (S1A-right) -- (S2A-left); % (S2A-right) -- (A-sync) (S2B-right) -- (B-sync);
      \draw[->, thick] (S0B-right) -- node[below, align=center]{\emph{insert "l"}\\\emph{between}\\\emph{"e" and "l"}} (S1B-left);
      \draw[dashed, ->, thick, shorten >= 3] (S1B-right.east) -- node[right, xshift=5pt, align=center]{\emph{insert "l" at} {\color{mylightorange}\id{i}{B0}{0}\id{m}{B1}{0}}} (S2A-left.west);
      \draw[->, thick] (S1B-right) -- node[below, align=center]{\emph{rename to \epoch{B2}}} (S2B-left);

    \end{tikzpicture}
  \caption{Concurrent \emph{rename} operations leading to divergent states}
  \label{fig:conflicting-rename-operations}
\end{figure}

Après avoir diffusé son opération \emph{insert}, le noeud B effectue une opération \emph{rename} sur son état.
Cette opération réassigne à chaque élément un nouvel identifiant à partir de l'identifiant du premier élément de la séquence (\id{i}{B0}{0}), de l'identifiant du noeud (\textbf{B}) et de son numéro de séquence courant (2).
Cette opération introduit aussi une nouvelle époque : \epoch{B2}.
Puisque l'opération \emph{rename} de A n'a pas encore été délivrée au noeud B à ce moment, les deux opérations \emph{rename} sont concurrentes.

Puisque des époques concurrentes sont générées, les époques forment désormais l'\emph{arbre des époques}.
Nous représentons dans la \autoref{fig:epoch-tree} l'\emph{arbre des époques} que les neoeuds obtiennent une fois qu'ils se sont synchronisés à terme.
Les époques sont representées sous la forme de noeuds de l'arbre et la relation \emph{parent-enfant} entre elles est illustrée sous la forme de flèches noires.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[scale=0.8,every node/.style={scale=0.8}]
      \path
          node[op] (e0) {\epoch{0}}
          to ++(270:1.5)
          to ++(180:0.95) node[op] (eA1) {\epoch{A1}};
      \path
          to ++(270:1.5)
          to ++(0:0.95) node[op] (eB2) {\epoch{B2}};

      \draw[thick, ->] (e0) -- (eA1);
      \draw[thick, ->] (e0) -- (eB2);
  \end{tikzpicture}
  \caption{The \emph{epoch tree} corresponding to the scenario of \autoref{fig:conflicting-rename-operations}}
  \label{fig:epoch-tree}
\end{figure}

À l'issue du scénario décrit dans la \autoref{fig:conflicting-rename-operations}, les noeuds A et B sont respectivement aux époques \epoch{A1} et \epoch{B2}.
Pour converger, tous les noeuds devraient atteindre la même époque à terme.
Cependant, la fonction \textsc{renameId} décrite dans \autoref{alg:renameId} permet seulement au noeuds de progresser d'une époque \emph{parente} à une de ses époques \emph{enfants}.
Le noeud A (resp. B) est donc dans l'incapacité de progresser vers l'époque du noeud B (resp. A).
Il est donc nécessaire de faire évoluer notre mécanisme de renommage pour sortir de cette impasse.

Tout d'abord, les noeuds doivent se mettre d'accord sur une époque commune de l'\emph{arbre des époques} comme époque cible.
Afin d'éviter des problèmes de performances dûs à une coordination synchrone, les noeuds doivent sélectionner cette époque de manière non-coordonnée, \ie en utilisant seulement les données présentes dans l'\emph{arbre des époques}.
Nous présentons un tel mécanisme dans \autoref{sec:priority}.

Ensuite, les noeuds doivent se déplacer à travers l'\emph{arbre des époques} afin d'atteindre l'époque cible.
La fonction \textsc{renameId} permet déjà aux noeuds de descendre dans l'arbre.
Les cas restants à gérer sont ceux où les noeuds se trouvent actuellement à une époque \emph{soeur} ou \emph{cousine} de l'époque cible.
Dans ces cas, les noeuds doivent être capable de remonter dans l'\emph{arbre des époques} pour retourner au \ac{LCA} de l'époque courante et l'époque cible.
Ce déplacement est en fait similaire à annuler l'effet des opérations \emph{rename} précédemment appliquées.
Nous proposons un algorithme qui remplit cet objectif dans la \autoref{sec:reverting-rename-ops}.

\subsection{Relation de priorité entre renommages}

\label{sec:priority}

Pour que chaque noeud sélectionne la même époque cible de manière non-coordonnée, nous définissons la relation \emph{priority}.

\begin{definition}[Relation \emph{priority}]
  La relation \emph{priority} est un ordre total strict sur l'ensemble des époques.
  Elle permet aux noeuds de comparer n'importe quelle paire d'époques.
\end{definition}

En utilisant la relation \emph{priority}, nous définissons l'époque cible de la manière suivante :

\begin{definition}[Époque cible]
  L'époque de l'ensemble des époques vers laquelle les noeuds doivent progresser.
  Les noeuds sélectionnent comme époque cible l'époque maximale d'après l'ordre établit par \emph{priority}.
\end{definition}

Pour définir la relation \emph{priority}, nous pouvons choisir entre plusieurs stratégies.
Dans le cadre de ce travail, nous utilisons l'ordre lexicographique sur le chemin des époques dans l'\emph{arbre des époques}.
La \autoref{fig:priority-example} fournit un exemple.

\begin{figure}[!ht]
  \subfloat[Example of execution with concurrent \emph{rename} operations]{
      \begin{minipage}{\linewidth}
          \centering
          \begin{tikzpicture}[scale=0.8,every node/.style={scale=0.8}]
              \path
                  node {\textbf{A}}
                  to ++(0:1) node (a0) {}
                  to ++(0:1) node[point, label=above:{rename to \epoch{A1}}] (a1) {}
                  to ++(0:5) node (a-end) {};

              \draw[->, thick] (a0) --  (a1) -- (a-end);

              \path
                  to ++(270:1.5) node {\textbf{B}}
                  to ++(0:1) node (b0) {}
                  to ++(0:1) node[point, label=below:{rename to \epoch{B2}}] (b2) {}
                  to ++(0:4) node[point, label=above:{rename to \epoch{B7}}] (b7) {}
                  to ++(0:1) node (b-end) {};

              \draw[->, thick] (b0) -- (b2) -- (b7) -- (b-end);

              \path
                  to ++(270:3) node {\textbf{C}}
                  to ++(0:1) node (c0) {}
                  to ++(0:3) node (c-receives-a1) {}
                  to ++(0:1) node[point, label=below:{rename to \epoch{C6}}] (c6) {}
                  to ++(0:2) node (c-end) {};

              \draw[->, thick] (c0) -- (c6) -- (c-end);

              \draw[->, dashed, shorten >= 1] (a1) -- (c-receives-a1);
          \end{tikzpicture}
          \label{fig:priority-execution}
      \end{minipage}}
  \hfil
  \subfloat[Corresponding epoch tree with \emph{priority} relation shown]{
      \begin{minipage}{\linewidth}
          \centering
          \begin{tikzpicture}[scale=0.8,every node/.style={scale=0.8}]
              \path
                  node[op] (e0) {\epoch{0}}
                  to ++(225:1.5) node[op] (eA1) {\epoch{A1}}
                  to ++(270:1.5) node[op] (eC6) {\epoch{C6}};
              \path
                  to ++(315:1.5) node[op] (eB2) {\epoch{B2}}
                  to ++(270:1.5) node[op, red] (eB7) {\epoch{B7}};

              \draw[->, thick] (e0) edge (eA1) (eA1) edge (eC6) (e0) edge (eB2) (eB2) edge (eB7);
              \draw[->, dashed, thick, red] (eB7.135) -- (eB2.225) (eB2.180) -- (eC6.45) -- (eA1.315) (eA1.0) -- (e0.270);
          \end{tikzpicture}
          \label{fig:priority-epoch-tree}
      \end{minipage}}
  \caption{Selecting target epoch from execution with concurrent \emph{rename} operations}
  \label{fig:priority-example}
\end{figure}

La \autoref{fig:priority-execution} décrit une exécution dans laquelle trois noeuds A, B et C générent plusieurs opérations avant de se synchroniser à terme.
Comme seules les opérations \emph{rename} sont pertinentes le problème qui nous occupe, seules ces opérations sont représentées dans cette figure.
Initialement, le noeud A génère une opération \emph{rename} qui introduit l'époque \epoch{A1}.
Cette opération est délivrée au noeud C, qui génère ensuite sa propre opération \emph{rename} qui introduit l'époque \epoch{C6}.
De manière concurrente à ces opérations, le noeud B génère deux opérations \emph{rename}, introduisant \epoch{B2} et \epoch{B7}.

Une fois que les noeuds se sont synchronisés, ils obtiennent l'\emph{arbre des époques} représenté dans la \autoref{fig:priority-epoch-tree}.
Dans cette figure, la flèche pointillé rouge représente l'ordre entre les époques d'après la relation \emph{priority} tandis que l'époque cible choisie est représentée sous la forme d'un noeud rouge.

Pour déterminer l'époque cible, les noeuds reposent sur la relation \emph{priority}.
D'après l'ordre lexicographique sur le chemin des époques dans l'\emph{arbre des époques}, nous avons \epoch{0} < \epoch{0}\epoch{A1} < \epoch{0}\epoch{A1}\epoch{C6} < \epoch{0}\epoch{B2} < \epoch{0}\epoch{B2}\epoch{B7}.
Chaque noeud sélectionne donc \epoch{B7} comme époque cible de manière non-coordonnée.

D'autres stratégies pourraient être proposées pour définir la relation \emph{priority}.
Par exemple, \emph{priority} pourrait reposer sur des métriques intégrées au sein des opérations \emph{rename} pour représenter le travail accumulé sur le document.
Cela permettrait de favoriser la branche de l'\emph{arbre des époques} avec le plus de collaborateurs actifs pour minimiser la quantité globale de calculs effectués par les noeuds du système.

\subsection{Algorithme d'annulation de l'opération de renommage}

\label{sec:reverting-rename-ops}

Nous présentons maintenant la fonction \textsc{revertRenameId}.
Décrite dans \autoref{alg:revertRenameId}, cette fonction permet aux noeuds d'annuler une opération \emph{rename} appliquée précéddemment.
Pour ce faire, \textsc{revertRenameId} associe les identifiants de l'époque \emph{enfant} aux identifiants correspondant dans l'époque \emph{parente}.

\begin{figure}[!ht]
  \footnotesize
  \begin{algorithmic}
      \Function{revertRenameId}{id, renamedIds, nId, nSeq}
          % \Statex \LeftComment{$id}$ is the identifier to reverse rename}
          % \Statex \LeftComment{$renamedIds}$ is the former state shared by the \emph{rename} op}
          % \Statex \LeftComment{$nId}$ is $node~id}$ of the node which issued the \emph{rename} op}
          % \Statex \LeftComment{$nSeq}$ is $node~seq}$ of the node which issued the \emph{rename} op}
          % \\
          \State length $\gets$ renamedIds.length
          \State firstId $\gets$ renamedIds[0]
          \State lastId $\gets$ renamedIds[length - 1]
          \State pos $\gets$ position(firstId)
          \\
          \State newFirstId $\gets$ \new~Id(pos, nId, nSeq, 0)
          \State newLastId $\gets$ \new~Id(pos, nId, nSeq, length - 1)
          \\
          \If{id < newFirstId}
              \State \Return revRenIdLessThanNewFirstId(id, firstId, newFirstId)
          \ElsIf{isRenamedId(id, pos, nId, nSeq, length)}
              \State index $\gets$ getFirstOffset(id)
              \State \Return renamedIds[index]
          \ElsIf{newLastId < id}
              \State \Return revRenIdGreaterThanNewLastId(id, lastId)
          \Else
              % Ajouter commentaire sur cas
              \State index $\gets$ getFirstOffset(id)
              \State \Return revRenIdfromPredId(id, renamedIds, index)
          \EndIf
      \EndFunction
      \\
      \Function{revRenIdfromPredId}{id, renamedIds, index}
          \State predId $\gets$ renamedIds[index]
          \State succId $\gets$ renamedIds[index + 1]
          \State tail $\gets$ getTail(id, 1)
          \\
          \If{tail < predId}
              \State \Comment{$id$ has been inserted causally after the \emph{rename} op}
              \State \Return concat(predId, MIN\_TUPLE, tail)
          \ElsIf{succId < tail}
              \State \Comment{$id$ has been inserted causally after the \emph{rename} op}
              \State offset $\gets$ getLastOffset(succId) - 1
              \State predOfSuccId $\gets$ createIdFromBase(succId, offset)
              \State \Return concat(predOfSuccId, MAX\_TUPLE, tail)
          \Else
              \State \Return tail
          \EndIf
      \EndFunction
  \end{algorithmic}
  \caption{Main functions to revert an identifier renaming}
  \label{alg:revertRenameId}
\end{figure}

Les objectifs de \textsc{revertRenameId} sont les suivants :
\begin{enumerate*}[label=(\roman*)]
  \item Restaurer à leur ancienne valeur les identifiants générés causalement avant ou de manière concurrente à l'opération \emph{rename} annulée
  \item Assigner de nouveaux identifiants respectant l'ordre souhaité aux éléments qui ont été insérés causalement après l'opération \emph{rename} annulée.
\end{enumerate*}
Nous illustrons son comportement à l'aide de la \autoref{fig:revertRenameId}.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[scale=0.8,every node/.style={scale=0.8}]
      \path
          node {\textbf{A}}
          to ++(0:0.5 * \widthletter) node[epoch] (S1A-left) {\epoch{A1}}
          to ++(0:1.3 * \widthepoch) node[block, fill=mydarkblue,
                  label={below:{\color{mydarkblueid}\id{i}{A1}{0..3}} }
                      ] (S1A-right) {HELO}
          to ++(0:8 * \widthletter) node[epoch] (S2A-left) {\epoch{A1}}
          to ++(0:1.3 * \widthepoch) node[block, fill=mydarkblue,
                  label={below:{\color{mydarkblueid}\id{i}{A1}{0..1}} }
                      ] {HE}
          to ++(0:\widthblock) node[letter, fill=mylightblue,
                  label={above:{\color{mylightblue!20!mydarkblueid}\id{i}{A1}{1}\id{i}{B0}{0}\id{m}{B1}{0}} }
                      ] {L}
          to ++(0:\widthletter) node[block, fill=mydarkblue,
                  label={below:{\color{mydarkblueid}\id{i}{A1}{2..3}} }
                      ] (S2A-right) {LO}
          to ++(0:2 * \widthblock) node[point] (between-S2A-S3A) {}
          to ++(0:3 * \widthletter) node[epoch] (S3A-left) {\epoch{0}}
          to ++(0:1.05 * \widthoriginepoch) node[letter, label=below:{\id{i}{B0}{0}}] {H}
          to ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{\,A0}{0}}] {E}
          to ++(0:\widthletter) node[letter, fill=mylightorange, label=below:{\color{mylightorange}\id{i}{B0}{0}\id{m}{B1}{0}}] {L}
          to ++(0:\widthletter) node[block, label=above:{\id{i}{B0}{1..2}}] (S3A-right) {LO}
          to ++ (0:3 * \widthblock) node[epoch] (S4A-left) {\epoch{B2}}
          to ++(0:1.3 * \widthepoch) node[block, fill=mydarkpurple,
                  label={ [] below:{\color{mydarkpurpleid}\id{i}{B2}{0..4}} }
              ] {HELLO};

      \path
          to ++(270:3) node {\textbf{B}}
          to ++(0:0.5 * \widthletter) node[epoch] (S1B-left) {\epoch{0}}
          to ++(0:1.05 * \widthoriginepoch) node[letter, label=below:{\id{i}{B0}{0}}] {H}
          to ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{\,A0}{0}}] {E}
          to ++(0:\widthletter) node[letter, fill=mylightorange, label=below:{\color{mylightorange}\id{i}{B0}{0}\id{m}{B1}{0}}] {L}
          to ++(0:\widthletter) node[block, label=above:{\id{i}{B0}{1..2}}] (S1B-right) {LO}
          to ++(0:5 * \widthletter) node[epoch] (S2B-left) {\epoch{B2}}
          to ++(0:1.3 * \widthepoch) node[block, fill=mydarkpurple,
                  label={ [] below:{\color{mydarkpurpleid}\id{i}{B2}{0..4}} }
              ] (S2B-right) {HELLO};

      \draw[dotted] (S1A-right) -- (S2A-left);
      \draw[dashed, ->, thick, shorten >= 3] (S1B-right.east) -- node[right, xshift=5pt, align=center]{\emph{insert "l" at} {\color{mylightorange}\id{i}{B0}{0}\id{m}{B1}{0}}} (S2A-left.west);
      \draw[->, thick] (S1B-right) -- node[below, align=center]{\emph{rename to \epoch{B2}}} (S2B-left);
      \draw[dotted] (S2A-right) -- (between-S2A-S3A) (S3A-right) -- (S4A-left);
      \draw[->, dashed, thick] (S2B-right.east) -- node[right, xshift=5pt, align=center]{\emph{rename to \epoch{B2}}} (between-S2A-S3A);
      \draw[->, loosely dash dot, thick, shorten >= 1] (between-S2A-S3A) -- node[above, align=center]{\emph{revert to \epoch{0}}} (S3A-left);
      \draw[->, dashed, thick, shorten >= 3] (between-S2A-S3A) edge[bend right] (S4A-left.west);
  \end{tikzpicture}
  \caption{Reverting a previously applied \emph{rename} operation}
  \label{fig:revertRenameId}
\end{figure}

Cette figure reprend le scénario de la \autoref{fig:concurrent-insert-rename-inconsistent}.
Le noeud A reçoit l'opération \emph{rename} du noeudd B, qui est concurrente à l'opération \emph{rename} que le noeud A a appliqué précédemment.
Selon la relation \emph{priority} proposée, le noeud A sélectionne l'époque introduite \epoch{B2} comme l'époque cible.
Il procède donc à ramener son état à un état équivalent à l'époque \epoch{0}, le \ac{LCA} de son époque courante \epoch{A1} et de l'époque cible \epoch{B2}.
Pour ce faire, il applique \textsc{revertRenameId} à chaque identifiant de son état courant.

\textsc{revertRenameId} détermine quelle stratégie appliquer pour restaurer un identifiant donné en utilisant des motifs.
Par exemple, les identifiants de la forme \id{pos}{nId~nSeq}{offset} (\id{i}{A1}{offset} dans l'exemple courant) correspondent aux nouvelles valeurs des identifiants qui composent l'\emph{ancien état}.
Pour retrouver les identifiants d'origine, \textsc{revertRenameId} utilise simplement leur offset puisqu'il correspond à leur index dans l'\emph{ancien état}.

Les identifiants de la forme \id{pos}{nId~nSeq}{offset}$\trm{tail}$ (\eg \id{i}{A1}{1}\id{i}{B0}{0}\id{m}{B1}{0}) correspondent à des identifiants qui ont été soit insérés de façon concurrente à l'opération \emph{rename}, soit causalement après.
Pour traiter ces identifiant, \textsc{revertRenameId} retire tout d'abord le premier tuple (\id{i}{A1}{1}) pour isoler la queue de l'identifiant (\id{i}{B0}{0}\id{m}{B1}{0}).
En faisant cela, \textsc{revertRenameId} annule la transformation appliquée à l'identifiant par \textsc{renIdFromPredId} si l'identifiant a été inséré de manière concurrente.
L'algorithme compare ensuite la queue de l'identifiant aux identifiants de l'élément précédant et de l'élément suivant dans l'\emph{ancien état}.
Dans cette exemple, nous avons \id{i}{B0}{0}\id{f}{A0}{0} < \id{i}{B0}{0}\id{m}{B1}{0} < \id{i}{B0}{1}.
L'algorithme peut alors retourner la queue comme identifiant résultant tout en préservant l'ordre souhaité, puisque sa valeur est comprise entre celles des identifiants du prédécesseur et du successeur.

Sinon, cela signifie que l'identifiant donné a été inséré de manière causale après l'opération \emph{rename}.
Puisqu'aucun identifiant correspondant n'existe encore à l'époque \emph{parente}, \textsc{revertRenameId} peut retourner n'importe quel identifiant tant qu'il préserve l'ordre souhaité.
Pour ce faire, \textsc{revertRenameId} génère l'identifiant à partir de l'identifiant du prédecesseur ou du successeur, et en utilisant des tuples exclusifs au mécanisme de renommage : $\trm{MIN\_TUPLE}$ et $\trm{MAX\_TUPLE}$.

\mnnote{TODO: Modifier exemple pour illustrer le cas de figure où on a besoin de MIN/MAX\_TUPLE}

Une fois que le noeud A a converti son état à un état équivalent à l'époque \epoch{0} en utilisant \textsc{revertRenameId}, il peut appliquer \textsc{renameId} pour calculer l'état correspondant à \epoch{B2}.

Comme pour \autoref{alg:renameId}, \autoref{alg:revertRenameId} ne présente seulement que le cas principal de \textsc{revertRenameId}.
Il s'agit du cas où l'identifiant à restaurer appartient à l'interval des identifiants renommés $\trm{newFirstId} \leq \trm{id} \leq \trm{newLastId}$).
Les fonctions pour gérer les cas restants sont présentées dans \autoref{app:revert-rename-id}.

Notons que \textsc{renameId} et \textsc{revertRenameId} ne sont pas des fonctions réciproques.
\textsc{revertRenameId} restaure à leur valeur initiale les identifiants insérés causalement avant ou de manière concurrente à l'opération \emph{rename}.
Par contre, \textsc{renameId} ne fait pas de même pour les identifiants insérés causalement après l'opération \emph{rename}.
Rejouer une opération \emph{rename} précédemment annulée altère donc ces identifiants.
Cette modification peut entraîner une divergence entre les noeuds, puis qu'un même élément sera désigné par des identifiants différents.

Ce problème est toutefois évité dans notre système grâce à la relation \emph{priority} utilisée.
Puisque la relation \emph{priority} est définie en utilisant l'ordre lexicographique sur le chemin des époques dans l'\emph{arbre des époques}, les noeuds se déplacent seulement vers l'époque la plus à droite de l'\emph{arbre des époques} lorsqu'ils changent d'époque.
Les noeuds évitent donc d'aller et revenir entre deux mêmes époques, et donc d'annuler et rejouer les opérations \emph{rename} correspondantes.

\subsection{Mise à jour du processus d'intégration d'une opération}
\subsection{Mise à jour des règles de récupération de la mémoire des états précédents}

Les noeuds stockent les époques et les \emph{anciens états} correspondant pour transformer les identifiants d'une époque à l'autre.
Au fur et à mesure que le système progresse, certaines époques et métadonnées associées deviennent obsolètes puisque plus aucune opération ne peut être émise depuis ces époques.
Les noeuds peuvent alors supprimer ces époques.
Dans cette section, nous présentons un mécanisme permettant aux noeudds de déterminer les époques obsolètes.

Pour proposer un tel mécanisme, nous nous reposons sur la notion de \emph{stabilité causale des opérations} \cite{10.1007/978-3-662-43352-2_11}.
Une opération est causalement stable une fois qu'elle a été délivrée à tous les noeuds.
Dans le contexte de l'opération \emph{rename}, cela implique que tous les noeuds ont progressé à l'époque introduite par cette opération ou à une époque plus grande d'après la relation \emph{priority}.
À partir de ce constat, nous définissons les \emph{potentielles époques courantes} :

\begin{definition}[Potentielles époques courantes]
  L'ensemble des époques auxquelles les noeuds peuvent se trouver actuellement et à partir desquelles ils peuvent émettre des opérations, du point de vue du noeud courant.
  Il s'agit d'un sous-ensemble de l'ensemble des époques, composé de l'époque maximale introduite par une opération \emph{rename} causalement stable et de toutes les époques plus grande que cette dernière d'après la relation \emph{priority}.
\end{definition}

Pour traiter les prochaines opérations, les noeuds doivent maintenir les chemins entre toutes les époques de l'ensemble des \emph{potentielles époques courantes}.
Nous appelons \emph{époques requises} l'ensemble des époques correspondant.

\begin{definition}[Époques requises]
  L'ensemble des époques qu'un noeud doit conserver pour traiter les potentielles prochaines opérations.
  Il s'agit de l'ensemble des époques qui forment les chemins entre chaque époque appartenant à l'ensemble des \emph{potentielles époques courantes} et leur \ac{LCA}.
\end{definition}

Il s'ensuit que toute époque qui n'appartient pas à l'ensemble des \emph{époques requises} peut être retirée par les noeuds.
La \autoref{fig:GC-epochs} illustre un cas d'utilisation du mécanisme de récupération de mémoire proposé.

\begin{figure}[!ht]
  \subfloat[Execution]{
      \begin{minipage}{\linewidth}
          \centering
          \begin{tikzpicture}[scale=0.8,every node/.style={scale=0.8}]
              \path
                  node {\textbf{A}}
                  to ++(0:0.5) node (a0) {}
                  to ++(0:1) node[point, label=above:{rename to \epoch{A1}}] (a1) {}
                  to ++(0:1) node (a2) {}
                  to ++(0:1) node (a7) {}
                  to ++(0:1) node[point, label=above:{rename to \epoch{A8}}] (a8) {}
                  to ++(0:1.5) node (a-receives-b2) {}
                  to ++(0:1.5) node[point, label=above:{rename to \epoch{A9}}] (a9) {}
                  to ++(0:1.5) node (a-end) {};

              \draw[->, thick] (a0) --  (a1) -- (a2);
              \draw[dotted] (a2) -- (a7);
              \draw[->, thick] (a7) -- (a8) -- (a9) -- (a-end);

              \path
                  to ++(270:2) node {\textbf{B}}
                  to ++(0:0.5) node (b0) {}
                  to ++(0:1) node[point, label=below:{rename to \epoch{B2}}] (b2) {}
                  to ++(0:1.5) node (b-receives-a1) {}
                  to ++(0:1.5) node (b3) {}
                  to ++(0:1) node (b6) {}
                  to ++(0:1) node[point, label=below:{rename to \epoch{B7}}] (b7) {}
                  to ++(0:2.5) node (b-end) {};

              \draw[->, thick] (b0) -- (b2) -- (b3);
              \draw[dotted] (b3) -- (b6);
              \draw[->, thick] (b6) -- (b7) -- (b-end);

              \draw[->, dashed, shorten >= 1] (a1) -- (b-receives-a1);
              \draw[->, dashed, shorten >= 1] (b2) -- (a-receives-b2);
          \end{tikzpicture}
          \label{fig:GC-execution}
      \end{minipage}}
  \hfil
  \subfloat[States of respective epoch trees with \emph{potential current epochs} and \emph{required epochs} displayed]{
      \begin{minipage}{\linewidth}
          \centering
          \begin{tikzpicture}[scale=0.8,every node/.style={scale=0.8}]
              \path
                  node {\textbf{A}}
                  to ++(270:1) node[causalop] (Ae0) {\epoch{0}}
                  to ++(225:1.5) node[op] (AeA1) {\epoch{A1}}
                  to ++(270:1.5) node[op] (AeA8) {\epoch{A8}};
              \path
                  to ++(270:1)
                  to ++(315:1.5) node[causalop] (AeB2) {\epoch{B2}}
                      node[outer sep=12pt] (A-tl-potential-epochs) {}
                      node[outer sep=15pt] (A-tl-required-epochs) {}
                  to ++(270:1.5) node[op, red] (AeA9) {\epoch{A9}}
                      node[outer sep=12pt] (A-br-potential-epochs) {}
                      node[outer sep=15pt] (A-br-required-epochs) {};

              \draw[dashed] (A-tl-potential-epochs.north west) rectangle (A-br-potential-epochs.south east);
              \draw[dotted, thick, darkgreen] (A-tl-required-epochs.north west) rectangle (A-br-required-epochs.south east);

              \path
                  to ++(0:4) node {\textbf{B}}
                  to ++(270:1) node[causalop] (Be0) {\epoch{0}}
                  to ++(315:1.5) node[op] (BeB2) {\epoch{B2}}
                  to ++(270:1.5) node[op, red] (BeB7) {\epoch{B7}}
                      node[outer sep=12pt] (B-br-potential-epochs) {}
                      node[outer sep=15pt] (B-br-required-epochs) {};
              \path
                  to ++(0:4)
                  to ++(270:1)
                  to ++(225:1.5) node[causalop] (BeA1) {\epoch{A1}}
                      node[outer sep=12pt] (B-tl-potential-epochs) {};

              \draw[dashed] (B-tl-potential-epochs.north west) rectangle (B-br-potential-epochs.south east);
              \draw[dotted, thick, darkgreen] (B-tl-potential-epochs.north west)[xshift=-3pt, yshift=33pt] rectangle (B-br-required-epochs.south east);

              \draw[thick, ->] (Ae0) edge (AeA1) (AeA1) edge (AeA8) (Ae0) edge (AeB2) (AeB2) edge (AeA9);
              \draw[thick, ->] (Be0) edge (BeB2) (BeB2) edge (BeB7) (Be0) edge (BeA1);
              \draw[->, dashed, thick, red] (AeA9.135) -- (AeB2.225) (AeB2.180) -- (AeA8.45) -- (AeA1.315) (AeA1.0) -- (Ae0.270);
              \draw[->, dashed, thick, red] (BeB7.135) -- (BeB2.225) (BeB2.180) -- (BeA1.0) -- (Be0.270);

          \end{tikzpicture}
          \label{fig:GC-epoch-trees}
      \end{minipage}}
  \caption{Garbage collecting epochs and corresponding \emph{former states}}
  \label{fig:GC-epochs}
\end{figure}

Dans la \autoref{fig:GC-execution}, nous représentons une exécution au cours de laquelle deux noeuds A et B génère respectivement plusieurs opérations \emph{rename}.
Dans la \autoref{fig:GC-epoch-trees}, nous représentons les \emph{arbre des époques} respectifs de chaque noeud.
Les époques introduites par des opérations \emph{rename} causalement stables sont representées en utilisant des doubles cercles.
L'ensemble des \emph{potentielles époques courantes} est montré sous la forme d'un rectangle noir pointillé, tandis que l'ensemble des \emph{époques requises} est représenté par un rectangle vert pointillé.

\mnnote{TODO: Trouver un autre terme que pointillé pour dotted}

Le noeud A génère tout d'abord une opération \emph{rename} vers \epoch{A1} et ensuite une opération \emph{rename} vers \epoch{A8}.
Il reçoit ensuite une opération \emph{rename} du noeud B qui introduit \epoch{B2}.
Puisque \epoch{B2} est plus grand que son époque courante actuelle (\epoch{e0}\epoch{A1}\epoch{A8} < \epoch{e0}\epoch{B2}), le noeud A la sélectionne comme sa nouvelle époque cible et procède au renommage de son état en conséquence.
Finalement, le noeud A génère une troisième opération \emph{rename} vers \epoch{A9}.

De manière concurrente, le noeud B génère l'opération \emph{rename} vers \epoch{B2}.
Il reçoit ensuite l'opération \emph{rename} vers \epoch{A1} du noeud A.
Cependant, le noeud B conserve \epoch{B2} comme époque courante (puisque \epoch{e0}\epoch{A1} < \epoch{e0}\epoch{B2}).
Après, le noeud B génère une autre opération \emph{rename} vers \epoch{B7}.

À la livraison de l'opération \emph{rename} introduisant l'époque \epoch{B2} au noeud A, cette opération devient causalement stable.
À partir de ce point, le noeud A sait que tous les noeuds ont progressé jusqu'à cette époque ou une plus grande d'après la relation \emph{priority}.
Les époques \epoch{B2} et \epoch{A9} forment donc l'ensemble des \emph{potentielles époques courantes} et les noeuds peuvent seulement émettre des opérations depuis ces époques ou une de leur descendante encore inconnue.
Le noeud A procède ensuite au calcul de l'ensemble des \emph{époques requises}.
Pour ce faire, il détermine le \ac{LCA} des \emph{potentielles époques courantes} : \epoch{B2}.
Il génère ensuite l'ensemble des \emph{époques requises} en ajoutant toutes les époques formant les chemins entre \epoch{B2} et les \emph{potentielles époques courantes}.
Les époques \epoch{B2} et \epoch{A9} forment donc l'ensemble des \emph{époques requises}.
Le noeud A déduit que les époques \epoch{0}, \epoch{A1} et \epoch{A8} peuvent être supprimées de manière sûre.

À l'inverse, la livraison de l'opération \emph{rename} vers \epoch{A1} au noeud B ne lui permet pas de supprimer la moindre métadonnée.
À partir de ses connaissances, le noeud B calcule que \epoch{A1}, \epoch{B2} et \epoch{B7} forment l'ensemble des \emph{potentielles époques courantes}.
De cette information, le noeud B détermine que ces époques et leur \ac{LCA} forment l'ensemble des \emph{époques requises}.
Toute époque connue appartient donc à l'ensemble des \emph{époques requises}, empêchant leur suppression.

À terme, une fois que le système devient inactif, les noeuds atteignent la même époque et l'opération \emph{rename} correspondante devient causalement stable.
Les noeuds peuvent alors supprimer toutes les autres époques et métadonnées associées, supprimant ainsi le surcoût mémoire introduit par le mécanisme de renommage.

Notons que le mécanisme de récupération de mémoire peut être simplifié dans les systèmes empêchant les opérations \emph{rename} concurrenteS.
Puisque les époques forment une chaîne dans de tels systèmes, la dernière époque introduite par une opération \emph{rename} causalement stable devient le \ac{LCA} des \emph{potentielles époques courantes}.
Il s'ensuit que cette époque et ses descendantes forment l'ensemble des \emph{époques requises}.
Les noeuds n'ont donc besoin que de suivre les opérations \emph{rename} causalement stables pour déterminer quelles époques peuvent être supprimées dans les systèmes sans opérations \emph{rename} concurrentes.

Pour déterminer qu'une opération \emph{rename} donnée est causalement stable, les noeuds doivent être conscients des autres et de leur avancement.
Un protocole de gestion de groupe tel que \cite{swim2002,lifeguard2018} est donc requis.

La stabilité causale peut prendre un certain temps à atteinte.
En attendant, les noeuds peuvent en fait décharger les anciens états sur le disque dur puis qu'ils sont seulement nécessaires pour traiter les opérations concurrentes aux opérations \emph{rename}.
Nous approfondissons ce sujet dans la \autoref{sec:offloading-former-states}.

\section{Validation}
\subsection{Complexité temporelle}
\subsection{Expérimentations}

Afin de valider l'approche que nous proposons, nous avons procédé à une évaluation expérimentale.
Les objectifs de cette évaluation étaient de mesurer
\begin{enumerate*}[label=(\roman*)]
  \item le surcoût mémoire de la séquence répliquée
  \item le surcoût en calculs ajouté aux opérations \emph{insert} et \emph{remove} par le mécanisme de renommage
  \item le coût d'intégration des opérations \emph{rename}.
\end{enumerate*}

Par le biais de simulations, nous avons généré le jeu de données utilisé par nos benchmarks.
Ces simulations reproduisent le scénario suivant.

\subsubsection{Scénario d'expérimentation}

Plusieurs authors rédigent de manière collaborative un article en temps réel.
Dans un premier temps, les auteurs spécifie principalement le contenu de l'article.
Quelques opérations \emph{remove} sont tout même générées pour simuler des fautes de frappes.
Une fois que le document atteint une taille arbitrairement définie comme critique, les collaborateurs passent à la seconde phase de la collaboration.
Au cours de cette phase, les auteurs arrêtent d'ajouter du nouveau contenu mais se concentre à la place sur le remaniement du contenu existant.
Ceci est simulé en équilibrant le ratio entre les opérations \emph{insert} et \emph{remove}.
Chaque auteur doit émettre un nombre donné d'opérations \emph{insert} et \emph{remove}.
La simulation prend fin une fois que tous les collaborateurs ont reçu toutes les opérations.
Au cours de la simulation, nous prenons des instantanés de l'état des pairs à des points donnés pour suivre leur évolution.

\subsubsection{Implémentation des simulations}

Nous avons effectué nos simulations avec les paramètres expérimentaux suivants : nous avons déployé 10 bots à l'aide de conteneurs Docker sur une même machine.
Chaque conteneur correspond à un processus Node.js mono-threadé et permet de simuler un auteur.
Les bots partagent et éditent de façon collaborative le document en utilisant soit LogootSplit soit RenamableLogootSplit en fonction de la session.
Dans chaque cas, chaque bot génère localement une opération \emph{insert} ou \emph{remove} toutes les 200 $\pm$ 50ms et la diffuse immédiatement aux autres noeuds via un réseau P2P maillé.
Au cours de la première phase, la probabilité d'émetter une opération \emph{insert} (resp. \emph{remove}) est de 80\% (resp. 20\%).
Une fois que le document atteint 60k caractères (environ 15 pages), les bots passent à la seconde phase et mettent chaque probabilité à 50\%.
Après chaque opération locale, le bot peut déplacer son curseur à une autre position aléatoire dans le document avec une probabilité de 5\%.
Chaque bot génère 15k opérations \emph{insert} ou \emph{remove} et s'arrête une fois qu'il a observé 150k opérations.
Des instantanés de l'état du bot sont pris de façon périodique, toutes les 10k opérations observées.

De plus, dans le cas de RenamableLogootSplit, 1 à 4 bots sont désignés de façon arbitraire comme des \emph{renaming bots} en fonction de la session.
Les \emph{renaming bots} génèrent des opérations \emph{rename} toutes les 30k opérations qu'ils observent.
Ces opérations \emph{rename} sont générées de façon à assurer qu'elles soient concurrentes.

Dans un but de reproductibilité, nous avons mis à disposition notre code, nos benchmarks et les résultats à l'adresse suivante : \url{https://github.com/coast-team/mute-bot-random/}.

\subsection{Résultats}

En utilisant les instantanés générés, nous avons effectué plusieurs benchmarks.
Ces benchmarks évaluent les performances de RenamableLogootSplit et les compare à celles de LogootSplit.
Les résultats sont présentés et analysés ci-dessous.

\subsubsection{Convergence}

Nous avons tout d'abord vérifié la convergence de l'état des noeuds à l'issue des simulations.
Pour chaque simulation, nous avons comparé l'état final de chaque noeud à l'aide de leur instantanés respectifs.
Nous avons pu confirmer que les noeuds convergaient sans aucune autre forme de communication que les opérations, satisfaisant donc le modèle de la \ac{SEC}.

Ce résultat établit un premier jalon dans la validation de la correction de RenamableLogootSplit.
Il n'est cependant qu'empirique.
Des travaux supplémentaires pour prouver formellement sa correction doivent être entrepris.

\subsubsection{Consommation mémoire}

Nous avons ensuite procédé à l'évaluation de l'évolution de la consommation mémoire du document au cours des simulations, en fonction du \ac{CRDT} utilisé et du nombre de \emph{renaming bots}.
Nous présentons les résultats obtenus dans la \autoref{fig:evolution-document-size}.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.7\columnwidth]{img/snapshot-sizes-alt-legende-v2.png}
  \caption{Evolution of the size of the document}
  \label{fig:evolution-document-size}
\end{figure}

Pour chaque graphique dans la \autoref{fig:evolution-document-size}, nous représentons 4 données différentes.
La ligne pointillée bleue correspond à la taille du contenu du document, \ie du texte, tandis que la ligne continue rouge représente la taille complète du document LogootSplit.

La ligne verte en pointillés représente la taille du document RenamableLogootSplit dans son meilleur cas.
Dans ce scénario, les noeuds considèrent que les opérations \emph{rename} sont supprimables dès qu'ils les reçoivent.
Les noeuds peuvent alors bénéficier des effets du mécanisme de renommage tout en supprimant les métadonnées qu'il introduit : les \emph{anciens états} et époques.
Ce faisant, les noeuds peuvent minimiser de manière périodique le surcoût en métadonnées de la structure de données, indépendamment du nombre de \emph{renaming bots} et d'opérations \emph{rename} concurrentes générées.

La ligne pointillée orange représente la taille du document RenamableLogootSplit dans son pire cas.
Dans ce scénario, les noeuds considèrent que les opérations \emph{rename} ne deviennent jamais causalement stables et qu'elles ne peuvent donc jamais être supprimées.
Les noeuds doivent alors conserver de façon permanente les métadonnées introduites par le mécanisme de renommage.
Les performances de RenamableLogootSplit diminuent donc à mesure que le nombre de \emph{renaming bots} et d'opérations \emph{rename} générées augmente.
Néanmoins, nous observons que RenamableLogootSplit peut surpasser les performances de LogootSplit tant que le nombre de \emph{renaming bots} reste faible (1 ou 2).
Ce résultat s'explique par le fait que le mécanisme de renommage permet aux noeuds de supprimer les métadonnées de la structure de données utilisée en interne pour représenter la séquence.

Pour récapituler les résultats présentés, le mécanisme de renommage introduit un surcoût temporaire en métadonnées qui augmente avec chaque opération \emph{rename}.
Mais le surcoût se résorbe à terme une fois que le système devient quiescent et que les opérations \emph{rename} deviennent causalement stables.
Dans la section \autoref{sec:offloading-former-states}, nous détaillerons l'idée que les \emph{anciens états} peuvent être déchargés sur le disque en attendant que la stabilité causale soit atteinte pour atténuer le surcoût temporaire en métadonnées.

\subsubsection{Temps d'intégration des opérations standards}

Nous avons ensuite comparé l'évolution du temps d'intégration des opérations standards, \ie les opérations \emph{insert} et \emph{remove}, sur des documents LogootSplit et RenamableLogootSplit.
Puisque les deux types d'opérations partagent la même complexité temporelle, nous avons seulement utilisé des opérations \emph{insert} dans nos benchmarks.
Nous faisons par contre la différence entre les mises à jours \emph{locales} et \emph{distantes}.
Conceptuellement, les modifications locales peuvent être décomposées comme présenté dans \cite{baquero2017pure} en les deux étapes suivantes :
\begin{enumerate*}[label=(\roman*)]
  \item la génération de l'opération correspondante
  \item l'application de l'opération correspondante sur l'état local.
\end{enumerate*}
Cependant, pour des raisons de performances, nous avons fusionné ces deux étapes dans notre implémentation.
Nous distinguons donc les résultats des modifications \emph{locales} et des modifications \emph{distantes} dans nos benchmarks.
La \autoref{fig:evolution-integration-time-insert} présente les résultats obtenus.

\begin{figure}[!ht]
  \centering
  \subfloat[Local updates]{
      \includegraphics[width=0.45\columnwidth]{img/integration-time-boxplot-local-operations-without-outliers.pdf}
      \label{fig:evolution-integration-time-local-insert}}
  \hfil
  \subfloat[Remote updates]{
      \includegraphics[width=0.45\columnwidth]{img/integration-time-boxplot-remote-operations-without-outliers.pdf}
      \label{fig:evolution-integration-time-remote-insert}}
  \caption{Integration time of standard operations}
  \label{fig:evolution-integration-time-insert}
\end{figure}

Dans ces figures, les boxplots orange correspondent aux temps d'intégration sur des documents LogootSplit, les boxplots bleu sur des documents RenamableLogootSplit.
Bien que les deux mesures soient initialement équivalentes, les temps d'intégration sur des documents RenamableLogootSplit sont ensuite réduits par rapport à ceux de LogootSplit une fois que des opérations \emph{rename} ont été intégrées.
Cette amélioration s'explique par le fait que l'opération \emph{rename} optimise la représentation interne de la séquence.

Dans le cadre des opérations distantes, nous avons mesuré des temps d'intégration spécifiques à RenamableLogootSplit : le temps d'intégration d'opérations distantes provenant d'époques \emph{parentes} et d'époques \emph{soeurs}, respectivement affiché sous la forme de boxplots blanche et rouge dans la \autoref{fig:evolution-integration-time-remote-insert}.

Les opérations distantes provenant d'époques \emph{parentes} sont des opérations générées de manière concurrente à l'opération \emph{rename} mais appliquées après cette dernière.
Puisque l'opération doit être transformée au préalable en utilisant \textsc{renameId}, nous observons un surcoût computationnel par rapport aux autres opérations.
Mais ce surcoût est compensé par l'optimisation de la représentation interne de la séquence effectuée par l'opération \emph{rename}.

Concernant les opérations provenant d'époques \emph{soeurs}, nous observons un surcoût additionnel puisque les noeuds doivent tout d'abord annulé les effets de l'opération \emph{rename} concurrente en utilisant \textsc{revertRenameId}.
À cause de cette étape supplémentaire, les performances de RenamableLogootSplit pour ces opérations sont comparables à celles de LogootSplit.

Pour récapituler, les fonctions de transformation ajoutent un surcoût aux temps d'intégration des opérations concurrentes aux opérations \emph{rename}.
Malgré ce surcoût, RenamableLogootSplit obtient de meilleures performances que LogootSplit tant que la distance entre l'époque de génération de l'opération et l'époque courante du noeud reste limité.
Au fur et à mesure que la distance entre les deux époques augmente, les performances de RenamableLogootSplit diminuent, jusqu'à atteindre des performances moins bonnes que celles de LogootSplit, puisque le surcoût est multiplié.
Néanmoins, le mécanisme de renommage réduit le temps d'intégration de la majorité des opérations, \ie les opérations générées entre deux séries d'opérations \emph{rename}.

\subsubsection{Temps d'intégration de l'opération de renommage}
\section{Discussion}
\subsection{Implémentation alternative à base d'operation-log}
\subsection{Définition de relations de priorité plus optimales}
\subsection{Report de la transition vers la nouvelle epoch principale}
\section{Conclusion}
% \include{assets/chapter_application_HAL}

\NumberThisInToc
\chapter{Stratégies de déclenchement du renommage}
\minitoc
\section{Motivation}
\section{Stratégies proposées}
\subsection{Propriétés}
\subsection{Stratégie 1 : ???}
\subsection{Stratégie 2 : ???}

NOTE: Peut considérer une stratégie où on prend en compte la hauteur de l'epoch tree pour déclencher un renommage : peut attendre qu'on ait plus qu'une epoch pour autoriser un nouveau renommage d'avoir lieu.
Permettrait d'empêcher le cas où un noeud revient après 6 mois d'absence et doit intégrer 100 renommages avant de pouvoir collaborer.
Mais dans le cas où un noeud ne rejoint plus la collaboration, bloque le mécanisme de renommage pour les autres

\section{Évaluation}
\section{Conclusion}
% \include{assets/chapter_extension}

\NumberThisInToc
\chapter{Conclusions et perspectives}
\minitoc
\section{Résumé des contributions}
\section{Perspectives}
\subsection{Définition de relations de priorité plus optimales}
\subsection{Redéfinition de la sémantique du renommage en déplacement d'éléments}
\subsection{Définition de types de données répliquées sans conflits plus complexes}
% \include{assets/conclusion}

\Annex{Algorithmes}
% \include{assets/annex_extension}

%
%%-------------------------------------------------------------------
%%                         Le glossaire
%%-------------------------------------------------------------------
%\BeginGloWith{Voici un glossaire tout-à-fait fictif,
%              introduit par un texte sur toute la largeur
%              des deux colonnes.}
%\twocolumn
%\PrintGlossary

%-------------------------------------------------------------------
%              L'index (toujours sur deux colonnes)
%-------------------------------------------------------------------
\BeginIndWith{Voici un index}
\PrintIndex

\onecolumn

%-------------------------------------------------------------------
%                       La bibliographie
%-------------------------------------------------------------------

% La bibliographie (comme d'habitude)

%\nocite{*}
%\bibliographystyle{named}

\printbibliography

%-------------------------------------------------------------------
%                          Les résumés
%-------------------------------------------------------------------
% (si le résumé apparaît sur une colonne étroite, avec la
% bibliographie à gauche, c'est sans doute parce que vous avez
% oublié de générer les fichiers d'index et de glossaire...)

\NumberAbstractPages
\begin{ThesisAbstract}
  \begin{FrenchAbstract}
    Afin d'assurer leur haute disponibilité, les systèmes distribués à large échelle se doivent de répliquer leurs données tout en minimisant les coordinations nécessaires entre noeuds.
    Pour concevoir de tels systèmes, la littérature et l'industrie adoptent de plus en plus l'utilisation de types de données répliquées sans conflits (CRDTs).
    Les CRDTs sont des types de données qui offrent des comportements similaires aux types existants, tel l'Ensemble ou la Séquence.
    Ils se distinguent cependant des types traditionnels par leur spécification, qui supporte nativement les modifications concurrentes.
    À cette fin, les CRDTs incorporent un mécanisme de résolution de conflits au sein de leur spécification.

    Afin de résoudre les conflits de manière déterministe, les CRDTs associent généralement des identifiants aux éléments stockés au sein de la structure de données.
    Les identifiants doivent respecter un ensemble de contraintes en fonction du CRDT, telles que l'unicité ou l'appartenance à un ordre dense.
    Ces contraintes empêchent de borner la taille des identifiants.
    La taille des identifiants utilisés croît alors continuellement avec le nombre de modifications effectuées, aggravant le surcoût lié à l'utilisation des CRDTs par rapport aux structures de données traditionnelles.
    Le but de cette thèse est de proposer des solutions pour pallier ce problème.

    Nous présentons dans cette thèse deux contributions visant à répondre à ce problème :
    \begin{enumerate*}[label=(\roman*)]
      \item Un nouveau CRDT pour Séquence, RenamableLogootSplit, qui intègre un mécanisme de renommage à sa spécification.
      Ce mécanisme de renommage permet aux noeuds du système de réattribuer des identifiants de taille minimale aux éléments de la séquence.
      Cependant, cette première version requiert une coordination entre les noeuds pour effectuer un renommage.
      L'évaluation expérimentale montre que le mécanisme de renommage permet de réinitialiser à chaque renommage le surcoût lié à l'utilisation du CRDT.
      \item Une seconde version de RenamableLogootSplit conçue pour une utilisation dans un système distribué.
      Cette nouvelle version permet aux noeuds de déclencher un renommage sans coordination préalable.
      L'évaluation expérimentale montre que cette nouvelle version présente un surcoût temporaire en cas de renommages concurrents, mais que ce surcoût est à terme.
    \end{enumerate*}
    \KeyWords{CRDTs, édition collaborative en temps réel, cohérence à terme, optimisation mémoire, performance}
  \end{FrenchAbstract}
  \begin{EnglishAbstract}
    \KeyWords{CRDTs, real-time collaborative editing, eventual consistency, memory-wise optimisation, performance}
  \end{EnglishAbstract}
\end{ThesisAbstract}


\end{document}



