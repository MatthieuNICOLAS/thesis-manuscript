\documentclass[12pt]{thesul}
%----------------------------------------------------------------------
%                               Packages
%----------------------------------------------------------------------
\usepackage[french]{babel}
\usepackage{acronym} % \ac[p], \acl[p], \acs[p], \acf[p]
\usepackage[sorting=none]{biblatex}
\bibliography{biblio.bib}
\usepackage{booktabs} % \toprule, \midrule, \cmidrule, \bottomrule
\usepackage{cancel} % \cancel
\usepackage{caption}
\usepackage{csquotes}
\usepackage{hyperref}
\hypersetup{hidelinks}
\usepackage[inline]{enumitem}
\usepackage{import} % \import
\usepackage[french]{minitoc}

\usepackage{xcolor}
\AtBeginDocument{
\definecolor{pdfurlcolor}{rgb}{0,0,0}
\definecolor{pdfcitecolor}{rgb}{0,0,0}
\definecolor{pdflinkcolor}{rgb}{0,0,0}
\definecolor{light}{gray}{.85}
\definecolor{vlight}{gray}{.95}
\definecolor{darkgreen}{RGB}{77,172,38}
\definecolor{darkblue}{RGB}{5,113,176}
\definecolor{mydarkblue}{RGB}{116,173,209}
\definecolor{mydarkblueid}{RGB}{83,154,198}
\definecolor{mylightblue}{RGB}{171,217,233}
\definecolor{mydarkorange}{RGB}{244,109,67}
\definecolor{mylightorange}{RGB}{252,153,54}
\definecolor{mydarkred}{RGB}{215,48,39}
\definecolor{mydarkpurple}{RGB}{140,107,177}
\definecolor{mydarkpurpleid}{RGB}{136,86,167}
}

\usepackage{amssymb}
\usepackage{amsmath}
\interdisplaylinepenalty=2500
\newtheorem{definition}{Définition}
\newtheorem{myrule}{Règle}
\newtheorem{property}{Propriété}
\newtheorem{subproperty}{Propriété}[property]
\usepackage{MnSymbol} % \dashrightarrow

\usepackage{algorithm, algpseudocode}
\floatname{algorithm}{Algorithme} % Renomme caption de "Algorithm" -> "Algorithme"

\usepackage[draft,inline,nomargin,index]{fixme}
\fxsetup{theme=color,mode=multiuser,inlineface=\itshape,envface=\itshape}
\FXRegisterAuthor{mn}{amn}{Matthieu}

\usepackage{tikz} % \begin{tikzpicture} \end{tikzpicture}
\usetikzlibrary{calc}
\usetikzlibrary{graphs}
\usetikzlibrary{quotes}
\usetikzlibrary{shapes.misc}

\usepackage[caption=false,font=footnotesize,labelfont=sf,textfont=sf]{subfig}

\usepackage{pifont} % \ding
\renewcommand{\checkmark}{\ding{51}}
\newcommand{\ballotx}{\ding{55}}

\usepackage{xspace} % \xspace

% Commands
%---------
\newcommand{\eg}{e.g.\xspace}
\newcommand{\ie}{c.-à-d.\xspace}

\newcommand{\hb}{\emph{happens-before}\xspace}

\newcommand{\inbb}[1]{\in \mathbb{#1}}
\newcommand{\new}{\textbf{new}}
\newcommand{\trm}[1]{\mathit{#1}}
\newcommand{\set}[1]{\left\{#1\right\}} % set brace notation

\newcommand{\id}[3]{$\trm{#1}^{\trm{#2}}_{\trm{#3}}$}
\newcommand{\epoch}[1]{$\varepsilon_{#1}$}
\newcommand{\lid}{<_{id}}
\newcommand{\leqid}{$\leq_{id}$~}
\newcommand{\lepoch}{$<_{\varepsilon}$~}
\newcommand{\leqepoch}{$\leq_{\varepsilon}$~}

\newcommand{\bigO}[1]{$\mathcal{O}(#1)$}

\newcommand{\widthletter}{2em}
\newcommand{\widthblock}{3em}
\newcommand{\widthoriginepoch}{1.33em}
\newcommand{\widthepoch}{1.65em}

% Définit noms pour \autoref
%---------
\newcommand{\algorithmautorefname}{Algorithme}
\newcommand{\annexautorefname}{Annexe}
\newcommand{\definitionautorefname}{Définition}
\newcommand{\propertyautorefname}{Propriété}
\newcommand{\subfigureautorefname}{Figure}
\newcommand{\subpropertyautorefname}{Propriété}

% Tikz styles
\tikzset{
    common/.style={anchor=west, draw, rectangle, minimum height=6mm},
    letter/.style={common, minimum width=\widthletter},
    block/.style={common, minimum width=\widthblock},
    epoch/.style={letter, rounded rectangle, rounded rectangle east arc=0pt, minimum width=\widthepoch},
    point/.style={insert path={ node[scale=5*sqrt(\pgflinewidth)]{.} }},
    node/.style={draw, circle, minimum size=1em},
    op/.style={draw, circle, minimum size=2.7em},
    causalop/.style={op, double=white, inner sep=2pt},
    gc-rule-1/.style={dashed, thick, darkblue},
    gc-rule-2/.style={densely dotted, thick, darkgreen},
    cross/.style={
        path picture={
            \draw[mydarkred, very thick]
                (path picture bounding box.south east)--(path picture bounding box.north west)
                (path picture bounding box.south west)--(path picture bounding box.north east);
        }
    }
}


%-------------------------------------------------------------------
%                             Marges
%-------------------------------------------------------------------

% pour positionner les vraies marges:
%\SetRealMargins{1mm}{1mm}

%-------------------------------------------------------------------
%                             En-têtes
%-------------------------------------------------------------------

% Les en-têtes: quelques exemples
%\UppercaseHeadings
%\UnderlineHeadings
%\newcommand\bfheadings[1]{{\bf #1}}
%\FormatHeadingsWith{\bfheadings}
%\FormatHeadingsWith{\uppercase}
%\FormatHeadingsWith{\underline}
\newcommand\upun[1]{\uppercase{\underline{\underline{#1}}}}
\FormatHeadingsWith\upun

\newcommand\itheadings[1]{\textit{#1}}
\FormatHeadingsWith{\itheadings}

% pour avoir un trait sous l'en-tete:
\setlength{\HeadRuleWidth}{0.4pt}

%-------------------------------------------------------------------
%                         Les références
%-------------------------------------------------------------------

\NoChapterNumberInRef
\NoChapterPrefix

%-------------------------------------------------------------------
%                           Brouillons
%-------------------------------------------------------------------

% ceci ajoute une marque « brouillon » et la date
\ThesisDraft

%-------------------------------------------------------------------
%                   Pour collecter un glossaire et un index
%-------------------------------------------------------------------

\makeglossary
\makeindex

%-------------------------------------------------------------------
%                           Acronymes
%-------------------------------------------------------------------

% Acronyms
% --------
% \input{assets/acronyms.tex}
\acrodef{ADT}[ADT]{Abstract Data Type}
\acrodefplural{ADT}[ADTs]{Abstract Data Types}
\acrodef{API}[API]{Application Programming Interface}
\acrodef{AW}[AW]{\emph{Add-Wins}}
\acrodef{CL}[CL]{\emph{Causal-Length}}
\acrodef{CRDT}[CRDT]{Conflict-free Replicated Data Type}
\acrodefplural{CRDT}[CRDTs]{Conflict-free Replicated Data Types}
\acrodef{FIFO}[FIFO]{First In, First Out}
\acrodef{GC}[GC]{Garbage Collection}
\acrodef{JIT}[JIT]{Just-In-Time}
\acrodef{LCA}[PPAC]{Plus Petit Ancêtre Commun}
\acrodef{LUB}[LUB]{Least Upper Bound}
\acrodef{LWW}[LWW]{\emph{Last-Writer-Wins}}
\acrodef{MUTE}[MUTE]{Multi User Text Editor}
\acrodef{MV}[MV]{\emph{Multi-Value}}
\acrodef{OT}[OT]{Operational Transformation}
\acrodefplural{OT}[OT]{Operational Transformations}
\acrodef{P2P}[P2P]{Pair-à-Pair}
\acrodef{PKI}[PKI]{Public Key Infrastructure}
\acrodef{RGA}[RGA]{Replicated Growable Array}
\acrodef{RW}[RW]{\emph{Remove-Wins}}
\acrodef{SEC}[SEC]{Cohérence forte à terme}
\acrodef{WebRTC}[WebRTC]{Web Real-Time Communication}

%-------------------------------------------------------------------
%                           Couleurs
%-------------------------------------------------------------------

% \input{assets/colours.tex}

%-------------------------------------------------------------------
%                     Global custom tikz commands
%-------------------------------------------------------------------

% \input{assets/tikz_presets.tex}

\begin{document}


      \OddHead={{\leftmark\rightmark}{\hfil\slshape\rightmark}}
      \EvenHead={{\leftmark}{{\slshape\leftmark}\hfil}}
      \OddFoot={\hfil\thepage}
      \EvenFoot={\thepage\hfil}
      \pagestyle{ThesisHeadingsII}


%-------------------------------------------------------------------
%                          Encadrements
%-------------------------------------------------------------------

% encadre les chapitres dans la table des matières:
% (ces commandes doivent figurer apres \begin{document}

\FrameChaptersInToc
%\FramePartsInToc


%-------------------------------------------------------------------
%            Réinitialisation de la numérotation des chapitres
%-------------------------------------------------------------------

% Si la commande suivante est présente,
% elle doit figurer APRÈS \begin{document}
% et avant la première commande \part
\ResetChaptersAtParts

%-------------------------------------------------------------------
%               mini-tables des matières par chapitre
%-------------------------------------------------------------------

% préparer les mini-tables des matières par chapitre.
% (commande de minitoc.sty)
\dominitoc

%-------------------------------------------------------------------
%                         Page de titre:
%-------------------------------------------------------------------

\ThesisTitle{Ré-identification sans coordination dans les types de données répliquées sans conflits (CRDTs)}
\ThesisDate{TODO: Définir une date}
\ThesisAuthor{Matthieu Nicolas}

% Type de la these
\ThesisUL
% Jury:

% (ne pas mettre de \\ apres la dernière entree)

% Exemple de création d'une nouvelle catégorie dans le jury:

\NewJuryCategory{family}{\it Membre de la famille :}
                        {\it Membres de la famille :}

\family={Mon frère\\Ma sœur}

\def\blanc{\hspace*{1cm}}

\President    = {Stephan Merz}
\Rapporteurs  = {Le rapporteur 1&de Paris\\
                 Le rapporteur 2\\
                 \blanc suite&taratata\\
                 Le rapporteur 3}
\Examinateurs = {L'examinateur 1&d'ici\\
                 L'examinateur 2}
%\Invites=       {}

% Création de la page de titre:
\MakeThesisTitlePage

%-------------------------------------------------------------------


%-------------------------------------------------------------------
%                          remerciements
%-------------------------------------------------------------------

%\DontFrameThisInToc
\begin{ThesisAcknowledgments}
Les remerciements.
\end{ThesisAcknowledgments}

%-------------------------------------------------------------------
%                            dédicace
%-------------------------------------------------------------------

\begin{ThesisDedication}
Je dédie cette thèse\\
à ma machine.\\
Oui, à Pandore,\\
qui fut la première de toutes.
\end{ThesisDedication}


%-------------------------------------------------------------------
%                  écriture de `Chapitre' et `Partie'
%                      dans la table des matières
%-------------------------------------------------------------------

\WritePartLabelInToc
\WriteChapterLabelInToc

%-------------------------------------------------------------------
%                        table des matières
%-------------------------------------------------------------------

\tableofcontents

%-------------------------------------------------------------------
%              Exemple d'utilisation de \SpecialSection
%-------------------------------------------------------------------
%\SpecialSection{Introduction générale}

\DontWriteThisInToc
\listoffigures

\mainmatter
\NumberThisInToc
\chapter*{Introduction}
\minitoc
\section{Contexte}

\begin{itemize}
  \item Systèmes collaboratifs (wikis, plateformes de contenu, réseaux sociaux) et leurs bienfaits (qualité de l'info, vitesse de l'info (exemple de crise ?), diffusion de la parole).
    Démocratisation (sic) de ces systèmes au cours de la dernière décennie.
  \item En raison du volume de données et de requêtes, adoptent architecture décentralisée.
    Permet ainsi de garantir disponibilité, tolérance aux pannes et capacité de passage à l'échelle.
  \item Mais échoue à adresser problèmes non-techniques : confidentialité, souveraineté, protection contre censure, dépendance et nécessité de confiance envers autorité centrale.
  \item À l'heure où les entreprises derrière ces systèmes font preuve d'ingérence et d'intérêts contraires à ceux de leurs utilisateur-rices (Cambridge Analytica, Prism, non-modération/mise en avant de contenus racistes, invisibilisation de contenus féministes), parait fondamental de proposer les moyens technologiques accessibles pour concevoir et déployer des alternatives.
  \item \mnnote{TODO: Voir si angle écologique/réduction consommation d'énergie peut être pertinent.}
  \item Systèmes pair-à-pair sont une direction intéressante pour répondre à ces problématiques, de part leur absence d'autorité centrale, la distribution des tâches et leur conception mettant le pair au centre.
    Mais posent de nouvelles problématiques de recherche.
  \item Ces systèmes ne disposent d'aucun contrôle sur les noeuds qui les composent.
    Le nombre de noeuds peut donc croître de manière non-bornée et atteindre des centaines de milliers de noeuds.
    La complexité des algorithmes de ces systèmes ne doit donc pas dépendre de ce paramètre, ou alors de manière logarithmique.
  \item De plus, ces noeuds n'offrent aucune garantie sur leur stabilité.
    Ils peuvent donc rejoindre et participer au système de manière éphèmère.
    S'agit du phénomène connu sous le nom de churn.
    Les algorithmes de ces systèmes ne peuvent donc pas reposer sur des mécanismes nécessitant une coordination synchrone d'une proportion des noeuds.
  \item Finalement, ces noeuds n'offrent aucune garanties sur leur fiabilité et intentions.
    Les noeuds peuvent se comporter de manière byzantine.
    Pour assurer la confidentialité, l'absence de confiance requise et le bon fonctionnement du système, ce dernier doit être conçu pour résister aux comportements byzantins de ses acteurs.
  \item Ainsi, il est nécessaire de faire progresser les technologies existantes pour les rendre compatible avec ce nouveau modèle de système.
    Dans le cadre de cette thèse, nous nous intéressons aux mécanismes de réplication de données dans les systèmes collaboratifs pair-à-pair temps réel.
\end{itemize}

\section{Questions de recherche et contributions}

\subsection{Ré-identification sans coordination pour \acp{CRDT} pour Séquence}

\begin{itemize}
  \item Systèmes collaboratifs permettent aux utilisateur-rices de manipuler et éditer un contenu partagé.
    Pour des raisons de performance, ces systèmes autorisent généralement les utilisateur-rices à effectuer des modifications sans coordination.
    Leur copies divergent alors momentanément.
    Un mécanisme de synchronisation leur permet ensuite de récupérer l'ensemble des modifications et de les intégrer, de façon à converger.
    Cependant, des modifications peuvent être incompatibles entre elles, car de sémantiques contraires.
    Un mécanisme de résolution de conflits est alors nécessaire.
  \item Les \acp{CRDT} sont des types de données répliquées.
    Ils sont conçus pour être répliqués par les noeuds d'un système et pour permettre à ces derniers de modifier les données partagées sans aucune coordination.
    Dans ce but, ils incluent des mécanismes de résolution de conflits directement au sein leur spécification.
    Ces mécanismes leur permettent de résoudre le problème évoqué précédemment.
    Cependant, ces mécanimes induisent un surcoût, aussi bien d'un point de vue consommation mémoire et réseau que computationnel.
    Notamment, certains \acp{CRDT} comme ceux pour la Séquence souffrent d'une croissance monotone de leur surcoût.
    Ce surcoût s'avère handicapant dans le contexte des collaborations à large échelle.
  \item Pouvons-nous proposer un mécanisme sans coordination de réduction du surcoût des \acp{CRDT} pour Séquence, \ie compatible avec les systèmes pair-à-pair ?
  \item Dans le cadre des \acp{CRDT} pour Séquence, le surcoût du type de données répliquées provient de la croissance de leurs métadonnées.
    Métadonnées proviennent des identifiants associés aux éléments de la Séquence par les \acp{CRDT}.
    Ces identifiants sont nécessaires pour le bon fonctionnement de leur mécanisme de résolution de conflits.
  \item Plusieurs approches ont été proposées pour réduire le coût de ces identifiants.
    Notamment, \cite{letia:hal-01248270,zawirski:hal-01248197} proposent un mécanisme de ré-assignation d'identifiants de façon à réduire leur taille.
    Mécanisme non commutatif avec les modifications concurrentes de la Séquence, \ie l'insertion ou la suppression.
    Propose ainsi un mécanisme de transformation des modifications concurrentes pour gérer ces conflits.
    Mais mécanisme de ré-assignation n'est pas non plus commutatif avec lui-même.
    De fait, utilisent un algorithme de consensus pour empêcher l'exécution du mécanisme en concurrence.
  \item Proposons RenamableLogootSplit, un nouveau \ac{CRDT} pour Séquence.
    Intègre un mécanisme de renommage directement au sein de sa spécification.
    Intègre un mécanisme de résolution de conflits pour les renommages concurrents.
    Permet ainsi l'utilisation du mécanisme de renommage par les noeuds sans coordination.
\end{itemize}

\subsection{Éditeur de texte collaboratif pair-à-pair}

\begin{itemize}
  \item Systèmes collaboratifs adoptent généralement architecture décentralisée.
    Disposent d'autorités centrales qui facilitent la collaboration, l'authentification des utilisateur-rices, la communication et le stockage des données.
  \item Mais ces systèmes introduisent une dépendance des utilisateur-rices envers ces mêmes autorités centrales, une perte de confidentialité et de souveraineté.
  \item Pouvons-nous concevoir un éditeur de texte collaboratif sans autorités centrales, \ie un éditeur de texte collaboratif à large échelle pair-à-pair ?
  \item Ce changement de modèle, d'une architecture décentralisée à une architecture pair-à-pair, introduit un ensemble de problématiques de domaines variés, \eg
    \begin{enumerate}[label=(\roman*)]
      \item Comment permettre aux utilisateur-rices de collaborer en l'absence d'autorités centrales pour résoudre les conflits de modifications ?
      \item Comment authentifier les utilisateur-rices en l'absence d'autorités centrales ?
      \item Comment structurer le réseau de manière efficace, \ie en limitant le nombre de connexion par pair ?
    \end{enumerate}
  \item Présentons \ac{MUTE} \cite{MUTE2017}.
    S'agit, à notre connaissance, du seul prototype complet d'éditeur de texte collaboratif temps réel pair-à-pair chiffré de bout en bout.
    Allie ainsi les résultats issus des travaux de l'équipe sur les \acp{CRDT} pour Séquence \cite{2013-logootsplit,2021-these-vic} et l'authentification des pairs dans systèmes distribués \cite{2018-trusternity-short,2018-trusternity-long} aux résultats de la littérature sur mécanismes de conscience de groupe \mnnote{TODO: Trouver et ajouter références}, les protocoles d'appartenance aux groupe \cite{swim2002, lifeguard2018}, les réseaux pair-à-pair \cite{2018-spray-nedelec} et les protocoles d'établissement de clés de groupe \cite{1995-burmester-desmedt}.
\end{itemize}

\section{Plan du manuscrit}
\section{Publications}
% \input{assets/intro}

% \NumberThisInToc
% \chapter*{Problématique}
% \minitoc
% \input{assets/chapter_problematic}

\NumberThisInToc
\chapter{État de l'art}
\minitoc

\section{Systèmes distribués}

\begin{itemize}
  \item Contexte des systèmes distribués à large échelle
  \item Réplique les données afin de pouvoir supporter les pannes
  \item Adopte le paradigme de la réplication optimiste \cite{10.1145/1057977.1057980}
  \item Autorise les noeuds à consulter et à modifier la donnée sans aucune coordination entre eux
  \item Autorise alors les noeuds à diverger temporairement
  \item Permet d'être toujours disponible, de toujours répondre aux requêtes même en cas de partition réseau
  \item Permet aussi, en temps normal, de réduire le temps de réponse (privilégie la latence) \cite{pacelc2012}
  \item Comme ce modèle autorise les noeuds à modifier la donnée sans se coordonner, possible d'effectuer des modifications concurrentes
  \item Généralement, un mécanisme de résolution de conflits est nécessaire afin d'assurer la convergence des noeuds dans une telle situation
  \item Plusieurs approches ont été proposées pour implémenter un tel mécanisme
\end{itemize}

\section{Transformées opérationnelles}

\begin{itemize}
  \item Approche permettant de gérer des modifications concurrentes sur un type de données
  \item Consiste à transformer les opérations par rapport aux effets des opérations concurrentes pour rendre les rendre commutatives.
    Permet de rendre l'ordre d'intégration des opérations sans importance par rapport à l'état final obtenu
  \item Se décompose en 2 parties : algorithmes (génériques) et fonctions de transformations (spécifiques au type de données)
  \item Plusieurs algorithmes OT adoptent une architecture centralisée (trouver citations)
  \item Cette architecture pose des problèmes de performances (bottleneck), sécurité (SPOF), coût, d'utilisabilité (mode offline), pérennité (disparition du service), vie privée et de résistance à la censure.
  \item Pour ces raisons, des algorithmes reposant sur une architecture décentralisée ont été proposés
  \item Mais ne règlent qu'en partie ces limites
  \item Notamment, ne sont pas adaptés à des systèmes P2P dynamiques
  \item Besoin de vector clocks sur chaque opération pour détecter la concurrence.
    Vector clocks adaptés dans systèmes à nombre de pairs fixe, mais pas aux systèmes dynamiques (revoir causal barrier pour p-e nuancer ce propos).
  \item Néanmoins, cette approche a permis de démocratiser les systèmes collaboratifs via son adoption par des services tels que Google Docs, Overleaf, Framapad
  \item De plus, dans le cadre de ces travaux, ont été définies les propriétés CCI \cite{10.1145/274444.274447}.
  \item Remettre en question la propriété Causalité des CCI.
    Généralement, confond causalité et happen-before et exprime en finalité une contrainte trop forte.
    Cette contrainte peut réduire la réactivité du système (exemple avec 2 insertions sans liens mais qui force d'attendre la 1ère pour intégrer la 2nde).
    Causalité pose aussi des problèmes de passage à l'échelle car repose sur vector clocks.
    IMO, doit relaxer cette propriété pour pouvoir construire systèmes à large échelle.
\end{itemize}

\mnnote{TODO: Mentionner TP1 et TP2}

\mnnote{TODO: Spécification faible et forte des séquences répliquées}

\section{Types de données répliquées sans conflits}

Pour limiter la coordination entre les noeuds, les systèmes distribués adoptent le paradigme de la réplication optimiste.
Ce paradigme consiste à ce que chaque noeud possède une copie de la donnée.
Chaque noeud possède le droit de la modifier sans se coordonner avec les autres noeuds.
Noeuds peuvent alors temporairement diverger, \ie posséder des états différents.
Un mécanisme de synchronisation leur permet ensuite de partager leurs modifications respectives et de nouveau converger.
Ce paradigme offre ainsi aux noeuds une haute disponibilité \mnnote{TODO: insérer ref sticky model} ainsi qu'une faible latence.

Afin d'ordonner les modifications effectués dans un système, la littérature repose généralement sur la relation \hb \cite{1978-happen-before-lamport}.
Nous l'adaptons ci-dessous à notre contexte :

\begin{definition}[Relation \hb]
  La relation \hb indique qu'une modification $m_1$ a eu lieu avant une modification $m_2$, notée $m_1 \rightarrow m_2$, si et seulement si une des conditions suivantes est respectée :
  \begin{enumerate}[label=(\roman*)]
    \item $m_1$ a eu lieu avant $m_2$ sur le même noeud.
    \item $m_1$ a été délivrée au noeud auteur de $m_2$ avant la génération de $m_2$.
    \item Il existe une modification $m$ telle que $m_1 \rightarrow m \wedge m \rightarrow m_2$.
  \end{enumerate}
\end{definition}

Dans le cadre d'un système distribué, on note que la relation \hb ne permet pas d'établir un ordre total entre les modifications\footnote{Nous utilisons le terme \emph{modifications} pour désigner les \emph{opérations de modifications} des types abstraits de données afin d'éviter une confusion avec le terme \emph{opération} introduit ultérieurement.}.
En effet, deux modifications $m_1$ et $m_2$ peuvent être effectuées en parallèle par deux noeuds différents, sans avoir connaissance de la modification de leur pair respectif.
De telles modifications sont alors dites \emph{concurrentes} :

\begin{definition}[Concurrence]
  Deux modifications $m_1$ et $m_2$ sont concurrentes, noté $m_1 \parallel m_2$, si et seulement si $m_1 \nrightarrow m_2 \wedge m_1 \nrightarrow m_2$.
\end{definition}

Lorsque les modifications possibles sur un type de données sont commutatives, l'intégration des modifications effectuées par les autres noeuds, même concurrentes, ne nécessite aucun mécanisme particulier.
Cependant, les modifications permises par un type de données ne sont généralement pas commutatives car de sémantiques contraires.
Ainsi, une exécution dans un système distribué suivant le paradigme de réplication optimiste peut mener à la génération de modifications concurrentes non commutatives.
Nous parlons alors de conflits.
La figure \autoref{fig:set-conflict} présente un scénario où des modifications de sémantiques opposées sont générées en concurrence.

\begin{figure}[!ht]

  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
      \path
          node {\textbf{A}}
          ++(0:0.5) node (a) {}
          +(0:21) node (a-end) {}
          +(0:2) node[point, label=above right:{$\{a\}$}] (a-initial) {}
          +(0:7) node[point, label=above right:{$\{\}$}, label=below left:{$\trm{rmv}(a)$}] (a-removes) {}
          +(0:12) node[point, label=above right:{$\{a\}$}, label=below left:{$\trm{add}(a)$}] (a-add) {}
          +(0:19) node[point, label=above right:{$?$}] (a-conflicts) {};

      \draw[dotted] (a) -- (a-initial) (a-conflicts) -- (a-end);
      \draw[->, thick] (a-initial) --  (a-removes) -- (a-add) -- (a-conflicts);

      \path
          ++(270:3) node {\textbf{B}}
          ++(0:0.5) node (b) {}
          +(0:21) node (b-end) {}
          +(0:2) node[point, label=below right:{$\{a\}$}] (b-initial) {}
          +(0:15.5) node[point, label=below right:{$\{\}$}, label=above left:{$\trm{rmv}(a)$}] (b-removes) {}
          +(0:19) node[point, label=below right:{$?$}] (b-conflicts) {};

      \draw[dotted] (b) -- (b-initial) (b-conflicts) -- (b-end);
      \draw[->, thick] (b-initial) --  (b-removes) -- (b-conflicts);

      \draw[->, dashed, shorten >= 1] (a-add) edge node[above right, near start] {\emph{sync}} (b-conflicts);
      \draw[->, dashed, shorten >= 1] (b-removes) edge node[below right, near start, xshift=-10pt, yshift=-7pt] {\emph{sync}} (a-conflicts);
    \end{tikzpicture}
  }
  \caption{Modifications concurrentes d'un Ensemble répliqué provoquant un conflit suite à l'ajout et la suppression d'un même élément}
  \label{fig:set-conflict}
\end{figure}

Dans cet exemple, deux noeuds A et B répliquent et partagent un même Ensemble.
Les deux noeuds possèdent le même état initial : $\{a\}$.
Le noeud A retire l'élément $a$ de l'ensemble, $\trm{rmv}(a)$.
Puis, le noeud A ré-ajoute l'élément $a$ dans l'ensemble via l'opération de modification $\trm{add}(a)$.
En concurrence, le noeud B retire lui aussi l'élément $a$ de l'ensemble.
Les deux noeuds se synchronisent ensuite.

À l'issue de ce scénario, l'état à produire n'est pas trivial : le noeud A a exprimé son intention d'ajouter l'élément $a$ à l'ensemble, tandis que le noeud B a exprimé son intention contraire de retirer l'élément $a$ de ce même ensemble.
Ainsi, les états $\{a\}$ et $\{\}$ semblent tous les deux corrects et légitimes dans cette situation.
Il est néanmoins primordial que les noeuds choisissent et convergent vers un même état pour leur permettre de poursuivre leur collaboration.
Pour ce faire, il est nécessaire de mettre en place un mécanisme de résolution de conflits, potentiellement automatique.

Les \acp{CRDT} \cite{shapiro_2011_crdt, 2018-crdts-perguica-baquero-shapiro, 2018-crdts-overview-preguica} répondent à ce besoin.
Les \acp{CRDT} sont de nouvelles spécifications des types de données existants, \eg l'Ensemble ou la Séquence.
Ces nouvelles spécifications sont conçues pour être utilisées dans des systèmes distribués adoptant la réplication optimiste.
Ainsi, elles offrent les deux propriétés suivantes :

\begin{enumerate}[label=(\roman*)]
  \item Les \acp{CRDT} peuvent être modifiés sans coordination avec les autres noeuds.
  \item Tous les noeuds ayant observés le même ensemble de modifications obtiendront des états équivalents.
    Cette propriété est connue sous le nom de \emph{convergence forte} \mnnote{TODO: Ajouter ref}.
\end{enumerate}

Pour offrir la propriété de \emph{convergence forte}, la spécification des \acp{CRDT} reposent sur la théorie des treillis :

\begin{enumerate}[label=(\roman*)]
  \item Les différents états possibles d'un \ac{CRDT} forment un sup-demi-treillis, possédant une relation d'ordre partiel $\leq$.
  \item Les modifications génèrent par inflation un nouvel état supérieur ou égal à l'état original d'après $\leq$.
  \item \label{item:lub} Il existe une fonction de fusion qui, pour toute paire d'états, génère l'état minimal supérieur d'après $\leq$ aux deux états fusionnés.
  On parle aussi de borne supérieure ou de \ac{LUB} pour catégoriser l'état résultant de cette fusion.
\end{enumerate}

Malgré leur spécification différente, les \acp{CRDT} partagent la même sémantique et interface que les types non-répliqués correspondant du point de vue des utilisateurs.
Ainsi, les \acp{CRDT} partagent le comportement des types non-répliqués dans le cadre d'exécutions séquentielles.
Cependant, ils définissent aussi une nouvelle sémantique pour chaque nouveau scénario ne pouvant se produire que dans le cadre d'une exécution distribuée.

Plusieurs sémantiques valides peuvent être proposées pour ces nouveaux scénarios.
Un \ac{CRDT} se doit donc de préciser quelle sémantique il choisit.

L'autre aspect définissant un \ac{CRDT} donné est le modèle qu'il adopte pour propager les modifications.
Au fil des années, la littérature a établi et défini plusieurs modèles dit de synchronisation, chacun ayant ses propres besoins et avantages.
De fait, plusieurs \acp{CRDT} peuvent être proposés pour un même type donné en fonction du modèle de synchronisation choisi.

Ainsi, ce qui définit un \ac{CRDT} est sa sémantique en cas de concurrence et son modèle de synchronisation.
Dans les prochaines sections, nous présenterons les différentes sémantiques possibles pour un type donné, l'Ensemble, en guise d'exemple.
Puis nous présenterons les différents modèles de synchronisation proposés dans la littérature, et détaillerons leurs contraintes et impact sur les \ac{CRDT} les adoptant, toujours en utilisant le même exemple.

\mnnote{TODO: Faire le lien avec les travaux de Burckhardt \cite{10.1145/2535838.2535848} et les MRDTs \cite{10.1145/3360580}}

\subsection{Sémantique en cas de concurrence}

Plusieurs sémantiques peuvent être proposées pour résoudre les conflits.
Certaines de ces sémantiques ont comme avantage d'être générique, \ie applicable à l'ensemble des types de données.
En contrepartie, elles souffrent de cette même généricité, en ne permettant que des comportements simples en cas de conflits.

À l'inverse, la majorité des sémantiques proposées dans la littérature sont spécifiques à un type de données.
Elles visent ainsi à prendre plus finement en compte l'intention des modifications pour proposer des comportements plus précis.

Dans la suite de cette section, nous présentons ces sémantiques génériques ainsi que celles spécifiques à l'Ensemble et, à titre d'exemple, les illustrons à l'aide du scénario présenté dans la \autoref{fig:set-conflict}.

\subsubsection{Sémantique \acl{LWW}}

Une manière simple pour résoudre un conflit consiste à trancher de manière arbitraire et de sélectionner une modification parmi l'ensemble des modifications en conflit.
Pour faire cela de manière déterministe, une approche est de reproduire et d'utiliser l'ordre total sur les modifications qui serait instauré par une horloge globale pour choisir la modification à prioritiser.

Cette approche, présentée dans \cite{johnson1975rfc0677}, correspond à la sémantique nommée \acf{LWW}.
De par son fonctionnement, cette sémantique est générique et est donc utilisée par une variété de \acp{CRDT} pour des types différents.
La \autoref{fig:set-lww} illustre son application à l'Ensemble pour résoudre le conflit de la \autoref{fig:set-conflict}.

\begin{figure}[!ht]

  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
      \path
          node {\textbf{A}}
          ++(0:0.5) node (a) {}
          +(0:21) node (a-end) {}
          +(0:2) node[point, label=above right:{$\{a\}$}] (a-initial) {}
          +(0:7) node[point, label=above right:{$\{\}$}, label=below left:{$\trm{rmv}(a)$}] (a-removes) {}
          +(0:12) node[point, label=above right:{$\{a\}$}, label=below left:{$\trm{add}(a)$}] (a-add) {}
          +(0:19) node[point, label=above right:{$\{\}$}] (a-conflicts) {};

      \draw[dotted] (a) -- (a-initial) (a-conflicts) -- (a-end);
      \draw[->, thick] (a-initial) --  (a-removes) -- (a-add) -- (a-conflicts);

      \path
          ++(270:3) node {\textbf{B}}
          ++(0:0.5) node (b) {}
          +(0:21) node (b-end) {}
          +(0:2) node[point, label=below right:{$\{a\}$}] (b-initial) {}
          +(0:15.5) node[point, label=below right:{$\{\}$}, label=above left:{$\trm{rmv}(a)$}] (b-removes) {}
          +(0:19) node[point, label=below right:{$\{\}$}] (b-conflicts) {};

      \draw[dotted] (b) -- (b-initial) (b-conflicts) -- (b-end);
      \draw[->, thick] (b-initial) --  (b-removes) -- (b-conflicts);

      \draw[->, dashed, shorten >= 1] (a-add) edge node[above right, near start] {\emph{sync}} (b-conflicts);
      \draw[->, dashed, shorten >= 1] (b-removes) edge node[below right, near start, xshift=-10pt, yshift=-7pt] {\emph{sync}} (a-conflicts);
    \end{tikzpicture}
  }
  \caption{Résolution du conflit en utilisant la sémantique \ac{LWW}}
  \label{fig:set-lww}
\end{figure}

Comme indiqué précédemment, le scénario illustré dans la \autoref{fig:set-lww} présente un conflit entre les modifications concurrentes $\trm{add}(a)$ et $\trm{rmv}(a)$ générées de manière concurrente respectivement par les noeuds A et B.
Pour le résoudre, la sémantique \ac{LWW} associe à chaque modification une estampille.
L'ordre créé entre les modifications par ces dernières permet de déterminer quelle modification désigner comme prioritaire.
Ici, nous considérons que $\trm{add}(a)$ a eu lieu plus tôt que $\trm{rmv}(a)$.
La sémantique \ac{LWW} désigne donc $\trm{rmv}(a)$ comme prioritaire et ignore $\trm{add}(a)$.
L'état obtenu à l'issue de cet exemple par chaque noeud est donc $\{\}$.

Il est à noter que si la modification $\trm{rmv}(a)$ du noeud B avait eu lieu plus tôt dans notre exemple, l'état final obtenu aurait été $\{a\}$.
Ainsi, des exécutions reproduisant le même ensemble de modifications produiront des résultats différents en fonction de l'ordre créé par les estampilles associées à chaque modification.
Ces estampilles étant des métadonnées du mécanisme de résolution de conflits, elles sont dissimulées aux utilisateur-rices.
Le comportement de cette sémantique peut donc être perçu comme aléatoire et s'avérer perturbant pour les utilisateur-rices.

La sémantique \ac{LWW} repose sur l'horloge de chaque noeud pour attribuer une estampille à chacune de leurs modifications.
Les horloges physiques étant sujettes à des imprécisions et notamment des décalages, utiliser les estampilles qu'elles fournissent peut provoquer des anomalies vis-à-vis de la relation \hb.
Les systèmes distribués préfèrent donc généralement utiliser des horloges logiques \cite{1978-happen-before-lamport}.
\mnnote{TODO: Ajouter refs des horloges logiques plus intelligentes (Interval Tree Clock, Hybrid Clock...)}

\subsubsection{Sémantique \acl{MV}}

Une seconde sémantique générique\footnote{Bien que généralement associée au type \emph{Registre} uniquement.} est la sémantique \acf{MV}.
Cette approche propose de gérer les conflits de la manière suivante : plutôt que de prioritiser une modification par rapport aux autres modifications concurrentes, la sémantique \ac{MV} maintient l'ensemble des états résultant possibles.
Nous présentons son application à l'Ensemble dans la \autoref{fig:set-mv}.

\begin{figure}[!ht]

  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
      \path
          node {\textbf{A}}
          ++(0:0.5) node (a) {}
          +(0:21) node (a-end) {}
          +(0:2) node[point, label=above right:{$\{a\}$}] (a-initial) {}
          +(0:7) node[point, label=above right:{$\{\}$}, label=below left:{$\trm{rmv}(a)$}] (a-removes) {}
          +(0:12) node[point, label=above right:{$\{a\}$}, label=below left:{$\trm{add}(a)$}] (a-add) {}
          +(0:19) node[point, label=above right:{$\{\{\},\{a\}\}$}] (a-conflicts) {};

      \draw[dotted] (a) -- (a-initial) (a-conflicts) -- (a-end);
      \draw[->, thick] (a-initial) --  (a-removes) -- (a-add) -- (a-conflicts);

      \path
          ++(270:3) node {\textbf{B}}
          ++(0:0.5) node (b) {}
          +(0:21) node (b-end) {}
          +(0:2) node[point, label=below right:{$\{a\}$}] (b-initial) {}
          +(0:15.5) node[point, label=below right:{$\{\}$}, label=above left:{$\trm{rmv}(a)$}] (b-removes) {}
          +(0:19) node[point, label=below right:{$\{\{\},\{a\}\}$}] (b-conflicts) {};

      \draw[dotted] (b) -- (b-initial) (b-conflicts) -- (b-end);
      \draw[->, thick] (b-initial) --  (b-removes) -- (b-conflicts);

      \draw[->, dashed, shorten >= 1] (a-add) edge node[above right, near start] {\emph{sync}} (b-conflicts);
      \draw[->, dashed, shorten >= 1] (b-removes) edge node[below right, near start, xshift=-10pt, yshift=-7pt] {\emph{sync}} (a-conflicts);
    \end{tikzpicture}
  }
  \caption{Résolution du conflit en utilisant la sémantique \ac{MV}}
  \label{fig:set-mv}
\end{figure}

La \autoref{fig:set-mv} présente la gestion du conflit entre les modifications concurrentes $\trm{add}(a)$ et $\trm{rmv}(a)$ par la sémantique \ac{MV}.
Devant ces modifications contraires, chaque noeud calcule chaque état possible, \ie un état sans l'élément $a$, $\{\}$, et un état avec ce dernier, $\{a\}$.
Le \ac{CRDT} maintient alors l'ensemble de ces états en parallèle.
L'état obtenu est donc $\{\{\},\{a\}\}$.

Ainsi, la sémantique \ac{MV} expose les conflits aux utilisateur-rices lors de leur prochaine consultation de l'état du \ac{CRDT}.
Les utilisateur-rices peuvent alors prendre connaissance des intentions de chacun-e et résoudre le conflit manuellement.
Dans la \autoref{fig:set-mv}, résoudre le conflit revient à re-effectuer une modification $\trm{add}(a)$ ou $\trm{rmv}(a)$ selon l'état choisi.
Ainsi, si plusieurs personnes résolvent en concurrence le conflit de manière contraire, la sémantique \ac{MV} exposera de nouveau les différents états proposés sous la forme d'un conflit.

Il est intéressant de noter que cette sémantique mène à un changement du domaine du \ac{CRDT} considéré : en cas de conflit, la valeur retournée par le \ac{CRDT} correspond à un Ensemble de valeurs du type initialement considéré.
E.g. si nous considérons que le type correspondant au \ac{CRDT} dans la \autoref{fig:set-mv} est le type $\trm{Set}\langle V \rangle$, nous observons que la valeur finale obtenue a pour type $\trm{Set}\langle \trm{Set}\langle V \rangle \rangle$.
Il s'agit à notre connaissance de la seule sémantique opérant ce changement.

\subsubsection{Sémantiques \acl{AW} et \acl{RW}}

Comme évoqué précédemment, d'autres sémantiques sont spécifiques au type de données concerné.
Ainsi, nous abordons à présent des sémantiques spécifiques au type de l'Ensemble.

Dans le cadre de l'Ensemble, un conflit est provoqué lorsque des modifications $\trm{add}$ et $\trm{rmv}$ d'un même élément sont effectuées en concurrence.
Ainsi, deux approches peuvent être proposées pour résoudre le conflit :

\begin{enumerate}[label=(\roman*)]
  \item Une sémantique où la modification $\trm{add}$ d'une élément prend la précédence sur les modifications concurrentes $\trm{rmv}$ du même élément, nommée \acf{AW}.
    L'élément est alors présent dans l'état obtenu à l'issue de la résolution du conflit.
  \item Une sémantique où la modification $\trm{rmv}$ d'une élément prend la précédence sur les opérations concurrentes $\trm{add}$ du même élément, nommée \acf{RW}.
    L'élément est alors absent de l'état obtenu à l'issue de la résolution du conflit.
\end{enumerate}

La \autoref{fig:set-aw-rw} illustre l'application de chacune de ces sémantiques sur notre exemple.

\begin{figure}[!ht]

  \subfloat[Application de la sémantique \ac{AW}]{
      \begin{minipage}{\columnwidth}
        \resizebox{\columnwidth}{!}{
          \centering
          \begin{tikzpicture}
            \path
                node {\textbf{A}}
                ++(0:0.5) node (a) {}
                +(0:21) node (a-end) {}
                +(0:2) node[point, label=above right:{$\{a\}$}] (a-initial) {}
                +(0:7) node[point, label=above right:{$\{\}$}, label=below left:{$\trm{rmv}(a)$}] (a-removes) {}
                +(0:12) node[point, label=above right:{$\{a\}$}, label=below left:{$\trm{add}(a)$}] (a-add) {}
                +(0:19) node[point, label=above right:{$\{a\}$}] (a-conflicts) {};

            \draw[dotted] (a) -- (a-initial) (a-conflicts) -- (a-end);
            \draw[->, thick] (a-initial) --  (a-removes) -- (a-add) -- (a-conflicts);

            \path
                ++(270:3) node {\textbf{B}}
                ++(0:0.5) node (b) {}
                +(0:21) node (b-end) {}
                +(0:2) node[point, label=below right:{$\{a\}$}] (b-initial) {}
                +(0:15.5) node[point, label=below right:{$\{\}$}, label=above left:{$\trm{rmv}(a)$}] (b-removes) {}
                +(0:19) node[point, label=below right:{$\{a\}$}] (b-conflicts) {};

            \draw[dotted] (b) -- (b-initial) (b-conflicts) -- (b-end);
            \draw[->, thick] (b-initial) --  (b-removes) -- (b-conflicts);

            \draw[->, dashed, shorten >= 1] (a-add) edge node[above right, near start] {\emph{sync}} (b-conflicts);
            \draw[->, dashed, shorten >= 1] (b-removes) edge node[below right, near start, xshift=-10pt, yshift=-7pt] {\emph{sync}} (a-conflicts);
          \end{tikzpicture}
          \label{fig:set-aw}}
      \end{minipage}}
  \hfil
  \subfloat[Application de la sémantique \ac{RW}]{
      \begin{minipage}{\columnwidth}
        \centering
        \resizebox{\columnwidth}{!}{
          \begin{tikzpicture}
            \path
                node {\textbf{A}}
                ++(0:0.5) node (a) {}
                +(0:21) node (a-end) {}
                +(0:2) node[point, label=above right:{$\{a\}$}] (a-initial) {}
                +(0:7) node[point, label=above right:{$\{\}$}, label=below left:{$\trm{rmv}(a)$}] (a-removes) {}
                +(0:12) node[point, label=above right:{$\{a\}$}, label=below left:{$\trm{add}(a)$}] (a-add) {}
                +(0:19) node[point, label=above right:{$\{\}$}] (a-conflicts) {};

            \draw[dotted] (a) -- (a-initial) (a-conflicts) -- (a-end);
            \draw[->, thick] (a-initial) --  (a-removes) -- (a-add) -- (a-conflicts);

            \path
                ++(270:3) node {\textbf{B}}
                ++(0:0.5) node (b) {}
                +(0:21) node (b-end) {}
                +(0:2) node[point, label=below right:{$\{a\}$}] (b-initial) {}
                +(0:15.5) node[point, label=below right:{$\{\}$}, label=above left:{$\trm{rmv}(a)$}] (b-removes) {}
                +(0:19) node[point, label=below right:{$\{\}$}] (b-conflicts) {};

            \draw[dotted] (b) -- (b-initial) (b-conflicts) -- (b-end);
            \draw[->, thick] (b-initial) --  (b-removes) -- (b-conflicts);

            \draw[->, dashed, shorten >= 1] (a-add) edge node[above right, near start] {\emph{sync}} (b-conflicts);
            \draw[->, dashed, shorten >= 1] (b-removes) edge node[below right, near start, xshift=-10pt, yshift=-7pt] {\emph{sync}} (a-conflicts);
          \end{tikzpicture}
          \label{fig:set-rw}}
      \end{minipage}}
  \caption{Résolution du conflit en utilisant soit la sémantique \ac{AW}, soit la sémantique \ac{RW}}
  \label{fig:set-aw-rw}
\end{figure}

\subsubsection{Sémantique \acl{CL}}

Une nouvelle sémantique pour l'Ensemble fut proposée \cite{2020-cl-set-weihai} récemment.
Cette sémantique se base sur les observations suivantes :

\begin{enumerate}[label=(\roman*)]
  \item $\trm{add}$ et $\trm{rmv}$ d'un élément prennent place à tour de rôle, chaque modification invalidant la précédente.
  \item $\trm{add}$ (resp. $\trm{rmv}$) concurrents d'un même élément représentent la même intention.
    Prendre en compte une de ces modifications concurrentes revient à prendre en compte leur ensemble.
\end{enumerate}

À partir de ces observations, \citeauthor{2020-cl-set-weihai} proposent de déterminer pour chaque élément la chaîne d'ajouts et retraits la plus longue.
C'est cette chaîne, et précisément son dernier maillon, qui indique si l'élement est présent ou non dans l'ensemble final.
La \autoref{fig:set-cl} illustre son fonctionnement.

\begin{figure}[!ht]

  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
      \path
          node {\textbf{A}}
          ++(0:0.5) node (a) {}
          +(0:21) node (a-end) {}
          +(0:2) node[point, label=above right:{$\{a\}$}] (a-initial) {}
          +(0:7) node[point, label=above right:{$\{\}$}, label=below left:{$\trm{rmv}(a)$}] (a-removes) {}
          +(0:12) node[point, label=above right:{$\{a\}$}, label=below left:{$\trm{add}(a)$}] (a-add) {}
          +(0:19) node[point, label=above right:{$\{a\}$}] (a-conflicts) {};

      \draw[dotted] (a) -- (a-initial) (a-conflicts) -- (a-end);
      \draw[->, thick] (a-initial) --  (a-removes) -- (a-add) -- (a-conflicts);

      \path
          ++(270:3) node {\textbf{B}}
          ++(0:0.5) node (b) {}
          +(0:21) node (b-end) {}
          +(0:2) node[point, label=below right:{$\{a\}$}] (b-initial) {}
          +(0:15.5) node[point, label=below right:{$\{\}$}, label=above left:{$\trm{rmv}(a)$}] (b-removes) {}
          +(0:19) node[point, label=below right:{$\{a\}$}] (b-conflicts) {};

      \draw[dotted] (b) -- (b-initial) (b-conflicts) -- (b-end);
      \draw[->, thick] (b-initial) --  (b-removes) -- (b-conflicts);

      \draw[->, dashed, shorten >= 1] (a-add) edge node[above right, near start] {\emph{sync}} (b-conflicts);
      \draw[->, dashed, shorten >= 1] (b-removes) edge node[below right, near start, xshift=-10pt, yshift=-7pt] {\emph{sync}} (a-conflicts);
    \end{tikzpicture}
  }
  \caption{Résolution du conflit en utilisant la sémantique \ac{CL}}
  \label{fig:set-cl}
\end{figure}

Dans notre exemple, la modification $\trm{rmv(a)}$ effectuée par B est en concurrence avec une modification identique effectuée par A.
La sémantique \ac{CL} définit que ces deux modifications partagent la même intention.
Ainsi, A ayant déjà appliqué sa propre modification préalablement, il ne prend pas en compte \emph{de nouveau} cette modification lorsqu'il la reçoit de B.
Son état reste donc inchangé.

À l'inverse, la modification $\trm{add(a)}$ effectuée par A fait suite à sa modification $\trm{rmv}(a)$.
La sémantique \ac{CL} définit alors qu'elle fait suite à toute autre modification $\trm{rmv}(a)$ concurrente.
Ainsi, B intègre cette modification lorsqu'il la reçoit de A.
Son état évolue donc pour devenir $\{a\}$.

\subsubsection{Synthèse}

Dans cette section, nous avons mis en lumière l'existence de solutions différentes pour résoudre un même conflit.
Chacune de ces solutions correspond à une sémantique spécifique de résolution de conflits.
Ainsi, pour un même type de données, différents \acp{CRDT} peuvent être spécifiés.
Chacun de ces \acp{CRDT} est spécifié par la combinaison de sémantiques qu'il adopte, chaque sémantique servant à résoudre un des types de conflits du type de données.

Il est à noter qu'aucune sémantique n'est intrinsèquement meilleure et préférable aux autres.
Il revient aux concepteur-rices d'applications de choisir les \acp{CRDT} adaptés en fonction des besoins et des comportements attendus en cas de conflits.

Par exemple, pour une application collaborative de listes de courses, l'utilisation d'un \ac{MV}-Registre pour représenter le contenu de la liste se justifie : cette sémantique permet d'exposer les modifications concurrentes aux utilisateur-rices.
Ainsi, les personnes peuvent détecter et résoudre les conflits provoquées par ces éditions concurrentes, \eg l'ajout de l'élément \emph{lait} à la liste, pour cuisiner des crêpes, tandis que les \emph{oeufs} nécessaires à ces mêmes crêpes sont retirés.
En parallèle, cette même application peut utiliser un \ac{LWW}-Registre pour représenter et indiquer aux utilisateur-rices la date de la dernière modification effectuée.

\subsection{Modèle de synchronisation}

Dans le modèle de réplication optimiste, les noeuds divergent momentanément lorsqu'ils effectuent des modifications locales.
Pour ensuite converger vers des états équivalents, les noeuds doivent propager et intégrer l'ensemble des modifications.
La \autoref{fig:sync-model-base} illustre ce point.

\begin{figure}[!ht]

  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
      \path
          node {\textbf{A}}
          ++(0:0.5) node (a) {}
          +(0:21) node (a-end) {}
          +(0:2) node[point, label=above right:{$\set{a,e}$}] (a-initial) {}
          +(0:7) node[point, label=above right:{$\set{a,b,e}$}, label=below left:{$\trm{add}(b)$}] (a-add-b) {}
          +(0:12) node[point, label=above right:{$\set{a,b,c,e}$}, label=below left:{$\trm{add}(c)$}] (a-add-c) {}
          +(0:19) node (a-final) {};

      \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
      \draw[->, thick] (a-initial) --  (a-add-b) -- (a-add-c) -- (a-final);

      \path
          ++(270:3) node {\textbf{B}}
          ++(0:0.5) node (b) {}
          +(0:21) node (b-end) {}
          +(0:2) node[point, label=below right:{$\set{a,e}$}] (b-initial) {}
          +(0:10) node[point, label=below right:{$\set{a,d,e}$}, label=above left:{$\trm{add}(d)$}] (b-add-d) {}
          +(0:19) node (b-final) {};

      \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
      \draw[->, thick] (b-initial) --  (b-add-d) -- (b-final);
    \end{tikzpicture}
  }
  \caption{Modifications en concurrence d'un Ensemble répliqué par les noeuds A et B}
  \label{fig:sync-model-base}
\end{figure}

Dans cet exemple, deux noeuds A et B partagent et éditent un même Ensemble à l'aide d'un \ac{CRDT}.
Les deux noeuds possèdent le même état initial : $\set{a,e}$.

Le noeud A effectue les modifications $\trm{add}(b)$ puis $\trm{add}(c)$.
Il obtient ainsi l'état $\set{a,b,c,e}$.
De son côté, le noeud B effectue la modification suivante : $\trm{add}(d)$.
Son état devient donc $\set{a,d,e}$.
Ainsi, les noeuds doivent encore s'échanger leur modifications pour converger vers l'état souhaité\footnote{Le scénario ne comportant uniquement des modifications $\trm{add}$, aucun conflit n'est produit malgré la concurrence des modifications.}, \ie $\set{a,b,c,d,e}$.

% Dans ce scénario, aucune communication n'ayant eu lieu entre A et B au cours de cette exécution.
% Leurs opérations respectives sont donc concurrentes.
% Il est à noter que ce scénario ne présente uniquement des modifications $\trm{add}$.
% Ainsi, aucun conflit n'est produit malgré la concurrence des modifications.
% La sémantique utilisée par le \ac{CRDT} dans cet exemple n'a donc pas d'importance.

Dans le cadre des \acp{CRDT}, le choix de la méthode pour synchroniser les noeuds n'est pas anodin.
En effet, ce choix impacte la spécification même du \ac{CRDT} et ses prérequis.

Initialement, deux approches ont été proposées : une méthode de synchronisation par états \cite{shapiro_2011_crdt, shapiro:inria-00555588} et une méthode de synchronisation par opérations \cite{shapiro_2011_crdt, shapiro:inria-00555588, 2014-making-op-based-crdts-op-based, baquero2017pure}.
Une troisième approche, nommée synchronisation par différence d'états \cite{almeida2015delta, Almeida_2018}, fut spécifiée par la suite.
Le but de cette dernière est d'allier le meilleur des deux approches précédentes.

Dans la suite de cette section, nous présentons ces approches ainsi que leurs caractéristiques respectives.
Pour les illustrer, nous complétons l'exemple décrit ici.
Cependant, nous nous focalisons uniquement sur les messages envoyés par les noeuds et n'évoquons seulement les métadonnées introduites par chaque modèle de synchronisation, par soucis de clarté et de simplicité.

\subsubsection{Synchronisation par états}

L'approche de la synchronisation par états propose que les noeuds diffusent leurs modifications en transmettant leur état.
Les \acp{CRDT} adoptant cette approche doivent définir une fonction \texttt{merge}.
Cette fonction correspond à la fonction de fusion mentionnée précédemment en \ref{item:lub} : elle prend en paramètres une paire d'états et génère en retour l'état correspondant à leur \ac{LUB}.
Cette fonction doit être associative, commutative et idempotente.

Ainsi, lorsqu'un noeud reçoit l'état d'un autre noeud, il fusionne ce dernier avec son état courant à l'aide de la fonction \texttt{merge}.
Il obtient alors un nouvel état intégrant l'ensemble des modifications ayant été effectuées sur les deux états.

La nature croissante des états des \acp{CRDT} couplée aux propriétés d'associativité, de commutativité et d'idempotence de la fonction \texttt{merge} permettent de reposer sur la couche réseau sans lui imposer de contraintes fortes : les messages peuvent être perdus, réordonnés ou même dupliqués.
Les noeuds convergeront tant que la couche réseau garantit que les noeuds seront capables de transmettre leur état aux autres à terme.
Il s'agit là de la principale force des \acp{CRDT} synchronisés par états.

Néanmoins, la définition de la fonction \texttt{merge} offrant ces propriétés peut s'avérer complexe et a des répercussions sur la spécification même du \ac{CRDT}.
Notamment, les états doivent conserver une trace de l'existence des éléments et de leur suppression afin d'éviter qu'une fusion d'états ne les fassent ressurgirent.
Ainsi, les \acp{CRDT} synchronisés par états utilisent régulièrement des pierres tombales.

En plus de l'utilisation de pierres tombales, la taille de l'état peut croître de manière non-bornée dans le cas de certains types de donnés, \eg l'Ensemble ou la Séquence.
Ainsi, ces structures peuvent atteindre à terme des tailles conséquentes.
Dans de tels cas, diffuser l'état complet à chaque modification induirait alors un coût rédhibitoire.
L'approche de la synchronisation par états s'avère donc inadaptée aux systèmes temps réel et repose généralement sur une synchronisation périodique.

Nous illustrons le fonctionnement de cette approche avec la \autoref{fig:sync-model-state}.
Dans cet exemple, après que les noeuds aient effectués leurs modifications respectives, le mécanisme de synchronisation périodique de chaque noeud se déclenche.
Le noeud A (resp. B) diffuse alors son état $\set{a,b,c,e}$ (resp. $\set{a,d,e}$) à B (resp. A).

\begin{figure}[!ht]

  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
      \path
          node {\textbf{A}}
          ++(0:0.5) node (a) {}
          +(0:21) node (a-end) {}
          +(0:2) node[point, label=above right:{$\set{a,e}$}] (a-initial) {}
          +(0:7) node[point, label=above right:{$\set{a,b,e}$}, label=-170:{$\trm{add}(b)$}] (a-add-b) {}
          +(0:11) node[point, label=above right:{$\set{a,b,c,e}$}, label=-170:{$\trm{add}(c)$}] (a-add-c) {}
          +(0:16) node[point, label=below left:{$\trm{sync}$}, label={[xshift=10pt]-10:{$\set{a,b,c,e}$}}] (a-sends-state) {}
          +(0:19) node[point, label=above right:{$\set{a,b,c,d,e}$}] (a-final) {};

      \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
      \draw[->, thick] (a-initial) --  (a-add-b) -- (a-add-c) -- (a-sends-state) -- (a-final);

      \path
          ++(270:3) node {\textbf{B}}
          ++(0:0.5) node (b) {}
          +(0:21) node (b-end) {}
          +(0:2) node[point, label=below right:{$\set{a,e}$}] (b-initial) {}
          +(0:11) node[point, label=below right:{$\set{a,d,e}$}, label=170:{$\trm{add}(d)$}] (b-add-d) {}
          +(0:16) node[point, label=170:{$\trm{sync}$}, label={[xshift=15pt]10:{$\set{a,d,e}$}}] (b-sends-state) {}
          +(0:19) node[point, label=below right:{$\set{a,b,c,d,e}$}] (b-final) {};

      \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
      \draw[->, thick] (b-initial) --  (b-add-d) -- (b-sends-state) -- (b-final);

      \draw[->, dashed, shorten >= 1] (a-sends-state) -- (b-final);
      \draw[->, dashed, shorten >= 1] (b-sends-state) -- (a-final);
    \end{tikzpicture}
  }
  \caption{Synchronisation des noeuds A et B en adoptant le modèle de synchronisation par états}
  \label{fig:sync-model-state}
\end{figure}

À la réception de l'état, chaque noeud utilise la fonction \texttt{merge} pour intégrer les modifications de l'état reçu dans son propre état.
Dans le cadre de l'Ensemble répliqué, cette fonction consiste généralement à faire l'union des états, en prenant en compte l'estampille et le statut (présent ou non) associé à chaque élément.
Ainsi la fusion de leur état respectif, $\set{a,b,c,e} \cup \set{a,d,e}$, permet aux noeuds de converger à l'état souhaité : $\set{a,b,c,d,e}$.

Avant de conclure, il est intéressant de noter que ce modèle de synchronisation propose par nature une diffusion des modifications suivant le modèle de cohérence causale \mnnote{TODO: Ajouter ref}.
En effet, ce modèle de synchronisation assure une livraison soit de toutes les modifications connues d'un noeud, soit d'aucune.
Par exemple, dans la \autoref{fig:sync-model-state}, le noeud B ne peut pas recevoir et intégrer l'élément $c$ sans l'élement $b$.
Ainsi, ce modèle permet naturellement d'éviter ce qui pourrait être interprétées comme des anomalies par les utilisateur-rices.

\subsubsection{Synchronisation par opérations}

L'approche de la synchronisation par opérations propose quant à elle que les noeuds diffusent leurs modifications sous la forme d'opérations.
Pour chaque modification possible, les \acp{CRDT} synchronisés par opérations doivent définir deux fonctions : \texttt{prepare} et \texttt{effect}.

La fonction \texttt{prepare} a pour but de générer une opération correspondant à la modification effectuée, et commutative avec les potentielles opérations concurrentes.
Elle prend en paramètres la modification ainsi que ses paramètres, et l'état courant du noeud.
Cette fonction n'a pas d'effet de bord, \ie ne modifie pas l'état courant, et génère en retour l'opération à diffuser à l'ensemble des noeuds.

Une opération est un message.
Son rôle est d'encoder la modification sous la forme d'un ou plusieurs éléments irréductibles du sup-demi-treillis.

\begin{definition}[Élément irréductible]
  \label{def:irreducible-element}
  Un élément irréductible d'un sup-demi-treillis est un élément atomique de ce dernier.
  Il ne peut être obtenu par la fusion d'autres états.
\end{definition}

Il est à noter que dans le cas des \acp{CRDT} purs synchronisés par opérations \cite{baquero2017pure}, les modifications labellisées avec leur information de causalité correspondent à des éléments irréductibles, \ie à des opérations.
La fonction \texttt{prepare} peut donc être omise pour cette sous-catégorie de \acp{CRDT} synchronisés par opérations.

La fonction \texttt{effect} permet quant à elle d'intégrer les effets d'une opération générée ou reçue.
Elle prend en paramètre l'état courant et l'opération, et retourne un nouvel état.
Ce nouvel état correspond à la \ac{LUB} entre l'état courant et le ou les éléments irréductibles encodés par l'opération.

La diffusion des modifications par le biais d'opérations présentent plusieurs avantages.
Tout d'abord, la taille des opérations est généralement fixe et inférieure à la taille de l'état complet du \ac{CRDT}, puisque les opérations servent à encoder un de ses éléments irréductibles.
Ensuite, l'expressivité des opérations permet de proposer plus simplement des algorithmes efficaces pour leur intégration par rapport aux modifications équivalentes dans les \acp{CRDT} synchronisés par états.
Par exemple, la suppression d'un élément dans un Ensemble se traduit en une opération de manière presque littérale, tandis que pour les \acp{CRDT} synchronisés par états, c'est l'absence de l'élément dans l'état qui va rendre compte de la suppression effectuée.
Ces avantages rendent possible la diffusion et l'intégration une à une des modifications et rendent ainsi utilisables les \acp{CRDT} synchronisés par opérations pour construire des systèmes temps réels.

Il est à noter que la seule contrainte imposée aux \acp{CRDT} synchronisés par opérations est que leurs opérations concurrentes soient commutatives.
Ainsi, il n'existe aucune contrainte sur la commutativité des opérations liées causalement.
De la même manière, aucune contrainte n'est définie sur l'idempotence des opérations.
Ces libertés impliquent qu'il peut être nécessaire que les opérations soient délivrées au \ac{CRDT} en respectant un ordre donné et en garantissant leur livraison en exactement une fois pour garantir la convergence.
Ainsi, un intergiciel chargé de la diffusion et de la livraison des opérations est usuellement associé aux \acp{CRDT} synchronisés par opérations pour respecter ces contraintes.

Généralement, les \acp{CRDT} synchronisés par opérations sont présentés dans la littérature comme nécessitant une livraison causale des opérations.
Ce modèle de livraison permet de respecter le modèle de cohérence causale et ainsi de simplifier raisonnement sur exécutions.

Ce modèle introduit néanmoins plusieurs effets négatifs.
Tout d'abord, ce modèle peut provoquer un délai dans la diffusion des modifications.
En effet, la perte d'une opération par le réseau provoque la mise en attente de la livraison des opérations suivantes.
Les opérations mises en attente ne sont délivrées qu'une fois l'opération perdue re-diffusée et délivrée.

De plus, il nécessite que des informations de causalité précises soient attachées à chaque opération.
Pour cela, les systèmes reposent généralement sur l'utilisation de vecteurs de version \mnnote{TODO: Insérer ref}.
Or, la taille de cette structure de données croît de manière linéaire avec le nombre de noeuds du système.
Les métadonnées de causalité peuvent ainsi représenter la majorité des données diffusées sur le réseau\footnote{
  La relation de causalité étant transitive, les opérations et leurs relations de causalité forment un DAG.
  \cite{1997-causal-barrier} propose d'ajouter en dépendances causales d'une opération seulement les opérations correspondant aux extremités du DAG au moment de sa génération.
  Ce mécanisme plus complexe permet de réduire la consommation réseau, mais induit un surcoût en calculs et en mémoire utilisée.
}.
\mnnote{TODO: Ajouter mention que OT a été abandonné à cause de cette contrainte même.}
Cependant, nous observons que la livraison dans l'ordre causal de toutes les opérations n'est pas toujours nécessaire.
Par exemple, l'ordre d'intégration de deux opérations d'ajout d'éléments différents dans un Ensemble n'a pas d'importance.
Nous pouvons alors nous affranchir de la livraison dans l'ordre causal pour accélérer la vitesse d'intégration des modifications et pour réduire les métadonnées envoyées.

Une autre contrainte généralement associée aux \acp{CRDT} synchronisés par opérations est la nécessité d'une livraison en exactement un exemplaire de chaque opération.
Cette contrainte dérive de :
\begin{enumerate}[label=(\roman*)]
  \item La potentielle non-idempotence des opérations.
  \item La nécessité de la livraison de chaque opération pour la livraison causale.
\end{enumerate}
Toutefois, nous observons que des opérations peuvent être sémantiquement rendues obsolètes par d'autres opérations, \eg une opération d'ajout d'un élément dans un Ensemble est rendue obsolète par une opération de suppression ultérieure du même élément.
Ainsi, l'intergiciel de livraison peut se contenter d'assurer une livraison en un exemplaire au plus des opérations non-obsolètes.
Ce choix permet de réduire la consommation réseau en évitant la diffusion d'opérations désormais non-pertinentes.

Pour compenser la perte d'opérations par le réseau et ainsi garantir la livraison à terme des opérations pertinentes, l'intergiciel de livraison des opérations doit mettre en place un mécanisme d'anti-entropie.
Plusieurs mécanismes de ce type ont été proposés dans la littérature \cite{1983-anti-entropy-vv, 2007-dynamo, 2015-approximate-hash-based-set-reconciliation, 2017-anti-entropy-without-merkle-trees} \mnnote{TODO: Ajouter refs Scuttlebutt si applicable à Op-based} et proposent des compromis variés entre complexité en temps, complexité spatiale et consommation réseau.

Nous illustrons le modèle de synchronisation par opérations à l'aide de la \autoref{fig:sync-model-op}.
Dans ce nouvel exemple, les noeuds diffusent les modifications qu'ils effectuent sous la forme d'opérations.
Nous considèrons que le \ac{CRDT} utilisé est un \ac{CRDT} pur synchronisé par opérations, \ie que les modifications et opérations sont confondues.

\begin{figure}[!ht]

  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
      \path
          node {\textbf{A}}
          ++(0:0.5) node (a) {}
          +(0:26) node (a-end) {}
          +(0:2) node[point, label=above right:{$\set{a,e}$}] (a-initial) {}
          +(0:7) node[point, label=above right:{$\set{a,b,e}$}, label=-170:{$\trm{add}(b)$}] (a-add-b) {}
          +(0:11) node[point, label=above right:{$\set{a,b,c,e}$}, label=-170:{$\trm{add}(c)$}] (a-add-c) {}
          +(0:14) node[point, label=above right:{$\set{a,b,c,d,e}$}] (a-receives-add-d) {}
          +(0:21) node[point, label={[xshift=8pt]-10:{$\trm{add(b)}$}}] (a-receives-query-sync) {}
          +(0:24) node (a-final) {};

      \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
      \draw[->, thick] (a-initial) --  (a-add-b) -- (a-add-c) -- (a-receives-add-d) -- (a-receives-query-sync) -- (a-final);

      \path
          ++(270:3) node {\textbf{B}}
          ++(0:0.5) node (b) {}
          +(0:26) node (b-end) {}
          +(0:2) node[point, label=below right:{$\set{a,e}$}] (b-initial) {}
          +(0:11) node[point, label=below right:{$\set{a,d,e}$}, label=170:{$\trm{add}(d)$}] (b-add-d) {}
          +(0:14) node[point, label=below right:{$\set{a,c,d,e}$}] (b-receives-add-c) {}
          +(0:18) node[point, label=170:{$\trm{query\ sync}$}] (b-sends-query-sync) {}
          +(0:24) node[point, label=below right:{$\set{a,b,c,d,e}$}] (b-final) {};

      \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
      \draw[->, thick] (b-initial) --  (b-add-d) -- (b-receives-add-c) -- (b-sends-query-sync) -- (b-final);

      \draw[->, dashed, shorten >= 1] (a-add-c) -- (b-receives-add-c);
      \draw[->, dashed, shorten >= 1] (b-add-d) -- (a-receives-add-d);
      \draw[->, dashed, shorten >= 1] (b-sends-query-sync) -- (a-receives-query-sync);
      \draw[->, dashed, shorten >= 1] (a-receives-query-sync) -- (b-final);

      \path
        ++(270:1.5)
        ++(0:0.5)
        +(0:8.5) node[cross] (network-error) {};

      \draw[->, dashed, shorten >= 1] (a-add-b) -- (network-error);
    \end{tikzpicture}
  }
  \caption{Synchronisation des noeuds A et B en adoptant le modèle de synchronisation par opérations}
  \label{fig:sync-model-op}
\end{figure}

Le noeud A diffuse donc les opérations $\trm{add}(b)$ et $\trm{add}(c)$.
Il reçoit ensuite l'opération $\trm{add}(d)$ de B, qu'il intègre à sa copie.
Il obtient alors l'état $\set{a,b,c,d,e}$.

De son côté, le noeud B ne reçoit initialement pas l'opération $\trm{add}(b)$ suite à une défaillance réseau.
Il génère et diffuse $\trm{add}(d)$ puis reçoit l'opération $\trm{add}(c)$.
Nous considérons que la livraisons des opérations $\trm{add}$ n'est pas obligatoire dans cet exemple, cette opération est alors intégrée.
Le noeud B obtient alors l'état $\set{a,c,d,e}$.

Ensuite, le mécanisme d'anti-entropie du noeud B se déclenche.
Le noeud B envoie alors à A une demande de synchronisation contenant un résumé de son état, \eg son vecteur de version.
À partir de cette donnée, le noeud A détermine que B n'a pas reçu l'opération $\trm{add}(a)$.
Il génère alors une réponse contenant cette opération et lui envoie.
À la réception de l'opération, le noeud B l'intègre.
Il obtient l'état $\set{a,b,c,d,e}$ et converge ainsi avec A.

Avant de conclure, nous noterons qu'il est nécessaire pour les noeuds de maintenir leur journal d'opérations.
En effet, les noeuds l'utilisent pour renvoyer les opérations manquées lors de l'exécution du mécanisme d'anti-entropie évoqué ci-dessus.
Ceci se traduit par une augmentation perpétuelle des métadonnées des \acp{CRDT} synchronisés par opérations.
Pour y pallier, des travaux \cite{baquero2017pure, 2021-improving-reactivity-pure-op-based-crdts-bauwens} proposent de tronquer le journal des opérations pour en supprimer les opérations connues de tous.
Les noeuds reposent alors sur la notion de stabilité causale pour déterminer les opérations supprimables de manière sûre.

\begin{definition}[Stabilité causale]
  Une opération est stable causalement lorsqu'elle a été observée par l'ensemble des noeuds du système.
  Ainsi, toute opération future dépend causalement des opérations causalement stables, \ie les noeuds ne peuvent plus générer d'opérations concurrentes aux opérations causalement stables de manière honnête .
\end{definition}

Un mécanisme d'instantané \mnnote{TODO: Ajouter refs} doit néanmoins être associé au mécanisme de troncage du journal pour générer un état équivalent à celui résultant des opérations supprimées.
Ce mécanisme est en effet nécessaire pour permettre un nouveau noeud de rejoindre le système et d'obtenir l'état courant à partir de l'instantané et du journal tronqué.

Pour résumer, cette approche permet de mettre en place simplement un système fonctionnel à l'aide d'un \ac{CRDT} synchronisé par opérations et d'un intergiciel de diffusion et de livraison RCB.
Mais comme illustré ci-dessus, chaque \ac{CRDT} synchronisé par opérations établit les propriétés de ses différentes opérations et délègue potentiellement des responsabilités à l'intergiciel de diffusion et livraison.
La complexité de cette approche réside ainsi dans l'ajustement du couple $\langle \trm{CRDT}, \trm{intergiciel} \rangle$ pour régler finement et optimiser leur fonctionnement en tandem.
Des approches \cite{baquero2017pure, 2021-improving-reactivity-pure-op-based-crdts-bauwens} ont été proposées ces dernières années pour concevoir et structurer plus proprement ces composants et leurs relations, mais reposent encore sur une livraison causale des opérations.
\mnnote{TODO: Vérifier que c'est bien le cas dans \cite{2021-improving-reactivity-pure-op-based-crdts-bauwens}}

\subsubsection{Synchronisation par différences d'états}

Dans \cite{almeida2015delta}, \citeauthor{almeida2015delta} introduisent un nouveau modèle de synchronisation pour \acp{CRDT}.
La proposition de ce modèle est nourrie par les observations suivantes :
\begin{enumerate}[label=(\roman*)]
  \item Les \acp{CRDT} synchronisés par opérations sont vulnérables aux défaillances du réseau et nécessitent généralement pour pallier à cette vulnérabilité une livraison des opérations en exactement un exemplaire et respectant l'ordre causal.
  \item Les \acp{CRDT} synchronisés par états pâtissent du surcoût induit par la diffusion de leurs états complets, généralement croissant continuellement.
\end{enumerate}

Pour pallier aux faiblesses de chaque approche et allier le meilleur des deux mondes, les auteurs proposent les \acp{CRDT} synchronisés par différences d'états \cite{almeida2015delta,Almeida_2018, enes2019}.
Il s'agit en fait d'une sous-famille des \acp{CRDT} synchronisés par états.
Ainsi, comme ces derniers, ils disposent d'une fonction \texttt{merge} permettant de produire la LUB entre deux états, et qui est associative, commutative et idempotente.

La spécificité des \acp{CRDT} synchronisés par différences d'états est qu'une modification locale produit en retour un delta.
Un delta encode la modification effectuée sous la forme d'un état du lattice.
Les deltas étant des états, ils peuvent être diffusés puis intégrés par les autres noeuds à l'aide de la fonction \texttt{merge}.
Ceci permet de bénéficier des propriétés d'associativité, de commutativité et d'idempotence offertes par cette fonction.
Les \acp{CRDT} synchronisés par différences d'états offrent ainsi :
\begin{enumerate}[label=(\roman*)]
  \item Une diffusion des modifications avec un surcoût pour le réseau proche de celui des \acp{CRDT} synchronisés par opérations.
  \item Une résistance aux défaillances réseaux similaire celle des \acp{CRDT} synchronisés par états.
\end{enumerate}

Cette définition des \acp{CRDT} synchronisés par différences d'états, introduite dans \cite{almeida2015delta,Almeida_2018}, fut ensuite précisée dans \cite{enes2019}.
Dans cet article, \citeauthor{enes2019} précisent qu'utiliser des éléments irréductibles (cf. \autoref{def:irreducible-element}) comme deltas est optimal du point de vue de la taille des deltas produits.

Concernant la diffusion des modifications, les \acp{CRDT} synchronisés par différences d'états autorisent un large éventail de possibilités.
Par exemple, les deltas peuvent être diffusés et intégrés de manière indépendante.
Une autre approche possible consiste à tirer avantage du fait que les deltas sont des états : il est possible d'agréger plusieurs deltas à l'aide la fonction \texttt{merge}, éliminant leurs éventuelles redondances.
Ainsi, la fusion de deltas permet ensuite de diffuser un ensemble de modifications par le biais d'un seul et unique delta, minimal.
Et en dernier recours, les \acp{CRDT} synchronisés par différences d'états peuvent adopter le même schéma de diffusion que les \acp{CRDT} synchronisés par états, \ie diffuser leur état complet de manière périodique.
Plusieurs de ces approches sont évaluées et comparées de manière expérimentale dans \cite{enes2019}.

Nous illustrons cette approche avec la \autoref{fig:sync-model-delta}.
Dans cet exemple, nous considérons que les noeuds adoptent la seconde approche évoquée, \ie que périodiquement les noeuds aggrégent les deltas issus de leurs modifications et diffusent le delta résultant.

\begin{figure}[!ht]

  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
      \path
          node {\textbf{A}}
          ++(0:0.5) node (a) {}
          +(0:21) node (a-end) {}
          +(0:2) node[point, label=above right:{$\set{a,e}$}] (a-initial) {}
          +(0:7) node[point, label=above right:{$\set{a,b,e}$}, label=-170:{$\trm{add}(b)$}] (a-add-b) {}
          +(0:11) node[point, label=above right:{$\set{a,b,c,e}$}, label=-170:{$\trm{add}(c)$}] (a-add-c) {}
          +(0:16) node[point, label=below left:{$\trm{sync}$}, label={[xshift=12pt]-10:{$\set{b,c}$}}] (a-sends-state) {}
          +(0:19) node[point, label=above right:{$\set{a,b,c,d,e}$}] (a-final) {};

      \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
      \draw[->, thick] (a-initial) --  (a-add-b) -- (a-add-c) -- (a-sends-state) -- (a-final);

      \path
          ++(270:3) node {\textbf{B}}
          ++(0:0.5) node (b) {}
          +(0:21) node (b-end) {}
          +(0:2) node[point, label=below right:{$\set{a,e}$}] (b-initial) {}
          +(0:11) node[point, label=below right:{$\set{a,d,e}$}, label=170:{$\trm{add}(d)$}] (b-add-d) {}
          +(0:16) node[point, label=170:{$\trm{sync}$}, label={[xshift=15pt]10:{$\set{d}$}}] (b-sends-state) {}
          +(0:19) node[point, label=below right:{$\set{a,b,c,d,e}$}] (b-final) {};

      \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
      \draw[->, thick] (b-initial) --  (b-add-d) -- (b-sends-state) -- (b-final);

      \draw[->, dashed, shorten >= 1] (a-sends-state) -- (b-final);
      \draw[->, dashed, shorten >= 1] (b-sends-state) -- (a-final);
    \end{tikzpicture}
  }
  \caption{Synchronisation des noeuds A et B en adoptant le modèle de synchronisation par différences d'états}
  \label{fig:sync-model-delta}
\end{figure}

Le noeud A effectue les modifications $\trm{add}(b)$ et $\trm{add}(c)$, qui retournent respectivement les deltas $\set{b}$ et $\set{c}$.
Le noeud A aggrége ces deltas et diffuse donc le delta suivant $\trm{b,c}$.
Quant au noeud B, il effectue la modification $\trm{add}(d)$ qui produit le delta $\set{d}$.
S'agissant de son unique modification, il diffuse ce delta inchangé.

Quand A (resp. B) reçoit le delta $\set{d}$ (resp. $\set{b,c}$), il l'intègre à sa copie en utilisant la fonction \texttt{merge}.
Les deux noeuds convergent alors à l'état $\set{a,b,c,d,e}$.

La synchronisation par différences d'états permet donc de réduire la taille des messages diffusés sur le réseau par rapport à la synchronisation par états.
Cependant, il est important de noter que la décomposition en deltas entraîne la perte d'une des propriétés intrinsèques des \acp{CRDT} synchronisés par états : le respect du modèle de cohérence causale.
En effet, sans mécanisme supplémentaire, la perte ou le ré-ordonnement de deltas par le réseau peut mener à une livraison dans le désordre des modifications à l'un des noeuds.
S'ils souhaitent assurer une diffusion causale des modifications, les \acp{CRDT} synchronisés par différences d'états doivent donc définir et intégrer dans leur spécification un mécanisme similaire à l'intergiciel de livraison des \acp{CRDT} synchronisés par opérations.
En revanche et à l'instar des \acp{CRDT} synchronisés par opérations, les \acp{CRDT} synchronisés par différences d'états peuvent aussi faire le choix inverse : s'affranchir du modèle de cohérence causale pour accélerer la diffusion des modifications et minimiser le surcoût du type répliqué.

Ainsi, les \acp{CRDT} synchronisés par différences d'états sont une évolution prometteuse des \acp{CRDT} synchronisés par états.
Ce modèle de synchronisation rend ces \acp{CRDT} utilisables dans les systèmes temps réels sans introduire de contraintes sur la fiabilité du réseau.
Mais pour cela, il ajoute une couche supplémentaire de complexité à la spécification des \acp{CRDT} synchronisés par états, \ie le mécanisme dédié à la livraison des deltas, qui peut s'avérer source d'erreurs et de coûts supplémentaires.

\subsubsection{Synthèse}

Nous récapitulons les principales propriétés et différences des modèles de synchronisations pour \acp{CRDT} dans \autoref{tab:synchronisation-models}.

\begin{table}[!ht]
  \centering
  \caption{Récapitulatif comparatif des différents modèles de synchronisation pour \acp{CRDT}}
  \label{tab:synchronisation-models}
  % \resizebox{\columnwidth}{!}{
    \begin{tabular}{lccc}
      \toprule
                                                & State-based & Op-based    & Delta-based \\
      \midrule
      États forment sup-demi-treillis           & \checkmark  & \checkmark  & \checkmark  \\
      Intègre modifications par fusion d'états  & \checkmark  & \ballotx    & \checkmark  \\
      Intègre modifications de manière atomique & \ballotx    & \checkmark  & \checkmark  \\
      Résistant aux défaillances réseau         & \checkmark  & \ballotx    & \checkmark  \\
      Peut s'affranchir de la cohérence causale & \ballotx    & \checkmark  & \checkmark  \\
      Adapté pour systèmes temps réel           & \ballotx    & \checkmark  & \checkmark  \\
      \bottomrule
    \end{tabular}
  % }
\end{table}

\subsection{Adoption dans la littérature et l'industrie}

\begin{itemize}
  \item Proposition et conception de \acp{CRDT} pour une variété de types de données : Registre, Compteur \mnnote{TODO: Ajouter IPA}, Ensemble, Liste/Sequence, Graphe, JSON, Filesystem, Access Control.
    Propose généralement plusieurs sémantiques de résolution de conflits par type de données.
  \item Conception et développement de librairies mettant à disposition des développeurs d'applications des types de données composés \cite{Nicolaescu2015Yjs, Nicolaescu2016YATA, yjsimplem, jsoncrdt2017, automerge}
    \mnnote{TODO: Revoir et ajouter Melda (PaPoC'22) si fitting}
  \item Conception de langages de programmation intégrant des CRDTs comme types primitifs, destinés au développement d'applications distribuées \cite{Meiklejohn2015Lasp2, DePorre2020cscript}
  \item Conception et implémentation de bases de données distribuées, relationnelles ou non, privilégiant la disponibilité et la minimisation de la latence à l'aide des CRDTs \cite{RiakKV, AntidoteDB, Anna2021, Concordant, yu:hal-02983557}
    \mnnote{TODO: Ajouter Redis et Akka}
  \item Conception d'un nouveau paradigme d'applications, Local-First Software, dont une des fondations est les CRDTs \cite{localfirstsoftware2019, pushpin2020}
    \mnnote{TODO: Vérifier et ajouter l'article avec Digital Garden (PaPoC'22?) si fitting}
  \item Éditeurs collaboratifs temps réel à large échelle et offrant de nouveaux scénarios de collaboration grâce aux CRDTs \cite{Nedelec2016CRATE, MUTE2017}
\end{itemize}

\section{Séquences répliquées sans conflits}

\begin{itemize}
  \item Présentation du type Sequence et de son utilisation
  \item Spécification du type : données, modifications
  \item Présentation de conflits
  \begin{itemize}
    \item dOpt puzzle
  \end{itemize}
  \item Introduction des principales approches pour Sequence \acp{CRDT}.
    Préciser que, sauf mention contraire, ces \acp{CRDT} adoptent le modèle de synchronisation par opérations en raison de la taille non-bornée de l'état.
\end{itemize}

\subsection{Approche à pierres tombales}

\subsubsection{WOOT}

\begin{itemize}
  \item WOOT \cite{2006-woot-oster} fait suite aux travaux présentés dans \cite{2006-tombstone-transformation-functions-oster}.
    Il est considéré a posteriori comme le premier \ac{CRDT} synchronisé par opérations pour Séquence\footnote{\cite{2007-crdt-shapiro} n'ayant formalisé les \acp{CRDT} qu'en 2007.}.
  \item Conçu pour l'édition collaborative \ac{P2P}, son but est de surmonter les limites de l'approche \ac{OT}.
    En effet, l'approche \ac{OT} souffre de la nécessité d'associer à chaque opération des informations de causalité, \ie un vecteur d'horloges.
    La taille de cette structure de données augmentant avec le nombre de noeuds du système, cette approche se révèle inadaptée aux systèmes \ac{P2P} dynamique, \ie systèmes dans lesquels un grand nombre de noeuds peuvent rejoindre puis quitter la collaboration.
  \item L'intuition de WOOT est la suivante : WOOT modifie la sémantique de la modification $\trm{ins}$ pour qu'elle corresponde à l'insertion d'un nouvel élément entre deux autres, et non plus à l'insertion d'un nouvel élément à une position donnée.
    Ce changement, qui est compatible avec l'intention des utilisateur-rices, n'est cependant pas anodin.
    En effet, il permet à WOOT de rendre $\trm{ins}$ commutative avec les modifications concurrentes. en exprimant la position du nouvel élément de manière relative à d'autres éléments et non plus via un index qui est spécifique à un état donné.
  \item Afin de préciser quels éléments correspondent aux prédécesseur et successeur de l'élément inséré, WOOT repose sur un système d'identifiants.
    WOOT associe ainsi un identifiant unique à chaque élément de la Séquence.
    La modification $\trm{rmv}$ utilise aussi les identifiants pour indiquer l'élément à supprimer.
  \item WOOT utilise des pierres tombales pour rendre $\trm{ins}$, qui nécessite la présence des deux éléments entre lesquels nous insérons un nouvel élément, commutative avec $\trm{rmv}$.
    Ainsi, une pierre tombale est conservée est conservée dans la Séquence pour indiquer sa présence passée, mais les données de l'élément sont supprimées.
    Dans le cadre d'une Séquence WOOT de caractères, $\trm{rmv}$ a donc pour effet de masquer l'élément.
  \item Finalement, WOOT définit $<_{id}$, un ordre strict total sur les identifiants associés aux éléments.
    En effet, il convient de noter que la relation $\prec$ ne spécifie qu'un ordre partiel entre les éléments.
    Ainsi, $\prec$ ne permet pas d'ordonner les éléments insérés en concurrence et possédant les mêmes prédecesseur et successeur, \eg $\trm{ins}(a \prec 1 \prec b)$ et $\trm{ins}(a \prec 2 \prec b)$.
    Pour que tous les noeuds convergent, ils doivent choisir comment ordonner ces éléments de manière déterministe et indépendante de l'ordre de réception des modifications.
    Ils utilisent pour cela $<_{id}$.
  \item Ainsi WOOT offre une spécification de la Séquence dont les opérations sont commutatives, \ie ne génèrent pas de conflits.
    Nous illustrons son fonctionnement à l'aide de la \autoref{fig:woot}.

    \begin{figure}[!ht]

      \centering
      \resizebox{\columnwidth}{!}{
        \begin{tikzpicture}
          \newcommand\initialstate[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$a1$}] {H}
              ++(0:\widthletter) node[letter, label=#2:{$a2$}] {E}
              ++(0:\widthletter) node[letter, label=#2:{$b1$}] {M}
              ++(0:\widthletter) node[letter, label=#2:{$a3$}] {L}
              ++(0:\widthletter) node[letter, label=#2:{$a4$}] {O};
          }

          \newcommand\insl[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$a1$}] {H}
              ++(0:\widthletter) node[letter, label=#2:{$a2$}] {E}
              ++(0:\widthletter) node[letter, label=#2:{$a5$}] {L}
              ++(0:\widthletter) node[letter, label=#2:{$b1$}] {M}
              ++(0:\widthletter) node[letter, label=#2:{$a3$}] {L}
              ++(0:\widthletter) node[letter, label=#2:{$a4$}] {O};
          }

          \newcommand\rmvm[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$a1$}] {H}
              ++(0:\widthletter) node[letter, label=#2:{$a2$}] {E}
              ++(0:\widthletter) node[letter, label=#2:{$b1$}] {\cancel{M}}
              ++(0:\widthletter) node[letter, label=#2:{$a3$}] {L}
              ++(0:\widthletter) node[letter, label=#2:{$a4$}] {O};
          }

          \newcommand\finalstate[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$a1$}] {H}
              ++(0:\widthletter) node[letter, label=#2:{$a2$}] {E}
              ++(0:\widthletter) node[letter, label=#2:{$a5$}] {L}
              ++(0:\widthletter) node[letter, label=#2:{$b1$}] {\cancel{M}}
              ++(0:\widthletter) node[letter, label=#2:{$a3$}] {L}
              ++(0:\widthletter) node[letter, label=#2:{$a4$}] {O};
          }

          \path
              node {\textbf{A}}
              ++(0:0.5) node (a) {}
              +(0:30) node (a-end) {}
              +(0:2) node[point] (a-initial) {}
              +(0:12) node[point, label=-170:{$\trm{ins}(E \prec L \prec M)$}, label={[xshift=45pt]-10:{$\trm{ins(a2 \prec \langle a5,L \rangle \prec b1)}$}}] (a-ins-l) {}
              +(0:20) node[point] (a-recv-rmv-m) {}
              +(0:28) node (a-final) {};

          \initialstate{(a-initial)}{90};
          \insl{(a-ins-l)}{90};
          \finalstate{(a-recv-rmv-m)}{90};

          \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
          \draw[->, thick] (a-initial) --  (a-ins-l) --  (a-recv-rmv-m) -- (a-final);

          \path
              ++(270:3) node {\textbf{B}}
              ++(0:0.5) node (b) {}
              +(0:30) node (b-end) {}
              +(0:2) node[point] (b-initial) {}
              +(0:12) node[point, label=170:{$\trm{rmv}(M)$}, label={[xshift=45pt]10:{$\trm{rmv(b1)}$}}] (b-rmv-m) {}
              +(0:20) node[point] (b-recv-ins-l) {}
              +(0:28) node (b-final) {};

          \initialstate{(b-initial)}{-90};
          \rmvm{(b-rmv-m)}{-90};
          \finalstate{(b-recv-ins-l)}{-90};

          \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
          \draw[->, thick] (b-initial) --  (b-rmv-m) -- (b-recv-ins-l) -- (b-final);

          \draw[->, dashed, shorten >= 1] (a-ins-l) -- (b-recv-ins-l);
          \draw[->, dashed, shorten >= 1] (b-rmv-m) -- (a-recv-rmv-m);
        \end{tikzpicture}
      }
      \caption{Modifications concurrentes d'une séquence répliquée WOOT}
      \label{fig:woot}
    \end{figure}

    Dans cet exemple, deux noeuds A et B partagent et éditent collaborativement une séquence répliquée WOOT.
    Initialement, ils possèdent le même état : la séquence contient les éléments "HEMLO", et à chaque élément est associé un identifiant, \eg $a1$, $b1$, $a2$...
  \item Le noeud A insère l'élément "L" entre les éléments "E" et "M", \ie $\trm{ins}(E \prec L \prec M)$.
    WOOT convertit cette modification en opération $\trm{ins}(a2 \prec \langle a5,L \rangle \prec b1)$. L'opération est intégrée à la copie locale, ce qui produit l'état "HELMLO", puis diffusée sur le réseau.
  \item En concurrence, le noeud B supprime l'élément "M" de la séquence, \ie $\trm{rmv}(M)$.
    De la même manière, WOOT génère l'opération correspondante $\trm{rmv}(b1)$.
    Comme expliqué précédemment, l'intégration de cette opération ne supprime pas l'élément "M" de l'état mais se contente de le masquer.
    L'état produit est donc "HE\cancel{M}LO".
    L'opération est ensuite diffusée.
  \item A (resp. B) reçoit ensuite l'opération de B, $\trm{rmv}(b1)$ (resp. A, $\trm{ins}(a2 \prec \langle a5,L \rangle \prec b1)$), et l'intègre à sa copie.
    Les opérations de WOOT étant commutatives, les noeuds obtiennent le même état final : "HEL\cancel{M}LO".
  \item Grâce à la commutativité de ses opérations, WOOT s'affranchit du modèle de livraison causale nécessitant l'utilisation coûteuse de vecteurs d'horloges.
    WOOT met en place un modèle de livraison sur-mesure basé sur les pré-conditions des opérations :
    \begin{enumerate}[label=(\roman*)]
      \item L'opération $\trm{ins}(predId \prec \langle id,elt \rangle \prec succId)$ ne peut être délivrée qu'après la livraison des opérations d'insertion des éléments associés à $predId$ et $succId$.
      \item L'opération $\trm{rmv}(id)$ ne peut être délivrée qu'après la livraison de l'opération d'insertion de l'élément associé à $id$.
    \end{enumerate}
    Ce modèle de livraison ne requiert qu'une quantité fixe de métadonnées associées à chaque opération pour être respecté.
    WOOT est donc adapté aux systèmes \ac{P2P} dynamiques.
  \item \mnnote{TODO: Mentionner que WOOT ne propose pas de mécanisme pour purger les tombstones, par choix : souhaite mettre en place des fonctionnalités d'undo.}
  \item Des améliorations de WOOT furent par la suite proposées : WOOTO \cite{2007-wooto-weiss} et WOOTH \cite{2011-evaluation-crdts-ahmed-nacer}.
    \mnnote{TODO: Ajouter limite de WOOT : complexité en temps de l'algorithme d'intégration des insertions distantes trop importante}
    Dans \cite{2007-wooto-weiss}, \citeauthor{2007-wooto-weiss} remanient la structure des identifiants associés aux éléments.
    Cette modification permet un algorithme d'intégration des opérations $\trm{ins}$ plus efficace.
    Dans \cite{2011-evaluation-crdts-ahmed-nacer}, \citeauthor{2011-evaluation-crdts-ahmed-nacer} se basent sur WOOTO et proposent l'utilisation de structures de données améliorant la complexité des algorithmes d'intégration des opérations, au détriment des métadonnées stockées localement par chaque noeud.
  \item Néanmoins, l'évaluation expérimentale des différentes approches pour l'édition collaborative \ac{P2P} en temps réel menée dans \cite{2011-evaluation-crdts-ahmed-nacer} a montré que les \acp{CRDT} de la famille WOOT n'étaient pas assez efficaces.
    Dans le cadre de cette expérience, des utilisateur-rices effectuaient des tâches d'édition collaborative données.
    Les traces de ces sessions d'édition collaboratives furent ensuite rejouées en utilisant divers mécanismes de résolution de conflits, dont WOOT, WOOTO et WOOTH.
    Le but était de mesurer les performances de ces mécanismes, notamment leurs temps d'intégration des modifications et opérations.
    Dans le cas de la famille WOOT, \citeauthor{2011-evaluation-crdts-ahmed-nacer} ont constaté que ces temps dépassaient parfois 50ms.
    Il s'agit là de la limite des délais acceptables par les utilisateur-rices d'après \cite{1984-human-performance-with-computers-shneiderman,2007-modeling-effects-delayed-feedback-jay}.
    Ces performances disqualifient donc les \acp{CRDT} de la famille WOOT comme approches viables pour l'édition collaborative \ac{P2P} temps réel.
\end{itemize}

\subsubsection{\acl{RGA}}

\begin{itemize}
  \item \acf{RGA} \cite{ROH2011354} est le second \ac{CRDT} appartenant à l'approche à pierres tombales.
    Spécifié dans le cadre d'un effort pour établir les principes nécessaires à la conception de Replicated Abstract Data Types (RADTs).
  \item Dans cet article, définissent et se basent sur 2 principes pour concevoir RADTs.
    Le premier d'entre eux est Operation Commutativity (OC).
    Celui-ci indique que toutes paires possibles d'opérations concurrentes doit être commutative.
    Permet de garantir que l'intégration par des noeuds différents d'une même séquence d'opérations concurrentes, mais dans des ordres différents, produira un état équivalent.
  \item Le second principe sur lequel repose les RADTs est la Precedence Transitivity (PT).
    Définit une relation de précédence, $\dashrightarrow$ , qui permet d'établir un ordre de priorité sur les intentions des opérations, pour déterminer laquelle conserver en cas de conflits.
    Precedence Transitivity définit que pour tout trio d'opérations a, b et c, si on a $a \dashrightarrow b$ et $b \dashrightarrow c$, on a $a \dashrightarrow c$.
  \item À partir de ces principes, proposent plusieurs RADTs : Replicated Fixed-Size Array (RFA), Replicated Hash Table (RFT) et \acf{RGA}, qui nous intéresse ici.
  \item Dans \ac{RGA}, l'intention de l'insertion est définit comme l'insertion d'un nouvel élément directement après un élément existant.
    Ainsi, \ac{RGA} se base sur le prédecesseur d'un élément pour déterminer où l'insérer.
    De fait, tout comme WOOT, \ac{RGA} repose sur un système d'identifiants qu'il associe aux éléments pour pouvoir s'y référer par la suite.
    Nommé S4Vector, ces identifiants sont de la forme suivante $\langle \trm{ssid},\trm{sum},\trm{ssn},\trm{seq} \rangle$ avec:
    \begin{itemize}
      \item $\trm{ssid}$, identifiant de la session de collaboration
      \item $\trm{sum}$, somme du vecteur d'horloges courant du noeud auteur de l'élément à son insertion
      \item $\trm{ssn}$, identifiant du noeud auteur de l'élément
      \item $\trm{seq}$, numéro de séquence de l'auteur de l'élément à son insertion
    \end{itemize}
    L'insertion est donc définie de la manière suivante : $\trm{ins}(\trm{predId} \prec \langle \trm{id},\trm{elt} \rangle)$.
    Dans présentations suivantes de \ac{RGA}, utilisent horloge de Lamport \cite{1978-happen-before-lamport} plutôt.
    Nous abstrayons donc ici la structure des identifiants avec le symbole $t$.
  \item Puisque plusieurs éléments peuvent être insérés en concurrence à la même position, \ie avec le même prédecesseur, il est nécessaire de définir une relation d'ordre strict total pour ordonner les éléments de manière déterministe et indépendante de l'ordre de réception des modifications.
    Pour cela, utilise l'ordre lexicographique sur les composants des identifiants des éléments.
    Par exemple, dans le cadre des S4Vector, on a $\langle 1, 10, A, 2\rangle < \langle 2, 5, B, 1 \rangle$ ou $\langle 1, 10, A, 2 \rangle < \langle 1, 15, B, 1 \rangle$.
    L'utilisation de cet ordre comme stratégie de résolution de conflits permet de rendre commutative les modifications $\trm{ins}$ concurrentes.
  \item Concernant les suppressions, \ac{RGA} se comporte de manière similaire à WOOT : la séquence conserve une tombstone pour chaque élément supprimé, de façon à pouvoir insérer à la bonne position un élément dont le prédecesseur a été supprimé en concurrence.
    Cette stratégie rend commutative les modifications $\trm{ins}$ et $\trm{rmv}$.
  \item Nous récapitulons le fonctionnement de \ac{RGA} à l'aide de la \autoref{fig:rga}.
    \begin{figure}[!ht]

      \centering
      \resizebox{\columnwidth}{!}{
        \begin{tikzpicture}
          \newcommand\initialstate[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$t_1$}] {H}
              ++(0:\widthletter) node[letter, label=#2:{$t_2$}] {E}
              ++(0:\widthletter) node[letter, label=#2:{$t_3$}] {M}
              ++(0:\widthletter) node[letter, label=#2:{$t_4$}] {L}
              ++(0:\widthletter) node[letter, label=#2:{$t_5$}] {O};
          }

          \newcommand\insl[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$t_1$}] {H}
              ++(0:\widthletter) node[letter, label=#2:{$t_2$}] {E}
              ++(0:\widthletter) node[letter, label=#2:{$t_6$}] {L}
              ++(0:\widthletter) node[letter, label=#2:{$t_3$}] {M}
              ++(0:\widthletter) node[letter, label=#2:{$t_4$}] {L}
              ++(0:\widthletter) node[letter, label=#2:{$t_5$}] {O};
          }

          \newcommand\rmvm[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$t_1$}] {H}
              ++(0:\widthletter) node[letter, label=#2:{$t_2$}] {E}
              ++(0:\widthletter) node[letter, label=#2:{$t_3$}] {\cancel{M}}
              ++(0:\widthletter) node[letter, label=#2:{$t_4$}] {L}
              ++(0:\widthletter) node[letter, label=#2:{$t_5$}] {O};
          }

          \newcommand\finalstate[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$t_1$}] {H}
              ++(0:\widthletter) node[letter, label=#2:{$t_2$}] {E}
              ++(0:\widthletter) node[letter, label=#2:{$t_6$}] {L}
              ++(0:\widthletter) node[letter, label=#2:{$t_3$}] {\cancel{M}}
              ++(0:\widthletter) node[letter, label=#2:{$t_4$}] {L}
              ++(0:\widthletter) node[letter, label=#2:{$t_5$}] {O};
          }

          \path
              node {\textbf{A}}
              ++(0:0.5) node (a) {}
              +(0:30) node (a-end) {}
              +(0:2) node[point] (a-initial) {}
              +(0:12) node[point, label=-170:{$\trm{ins}(E \prec L)$}, label={[xshift=5em]-10:{$\trm{ins(t_2 \prec \langle t_6,L \rangle)}$}}] (a-ins-l) {}
              +(0:20) node[point] (a-recv-rmv-m) {}
              +(0:28) node (a-final) {};

          \initialstate{(a-initial)}{90};
          \insl{(a-ins-l)}{90};
          \finalstate{(a-recv-rmv-m)}{90};

          \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
          \draw[->, thick] (a-initial) --  (a-ins-l) --  (a-recv-rmv-m) -- (a-final);

          \path
              ++(270:3) node {\textbf{B}}
              ++(0:0.5) node (b) {}
              +(0:30) node (b-end) {}
              +(0:2) node[point] (b-initial) {}
              +(0:12) node[point, label=170:{$\trm{rmv}(M)$}, label={[xshift=5em]10:{$\trm{rmv(t_3)}$}}] (b-rmv-m) {}
              +(0:20) node[point] (b-recv-ins-l) {}
              +(0:28) node (b-final) {};

          \initialstate{(b-initial)}{-90};
          \rmvm{(b-rmv-m)}{-90};
          \finalstate{(b-recv-ins-l)}{-90};

          \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
          \draw[->, thick] (b-initial) --  (b-rmv-m) -- (b-recv-ins-l) -- (b-final);

          \draw[->, dashed, shorten >= 1] (a-ins-l) -- (b-recv-ins-l);
          \draw[->, dashed, shorten >= 1] (b-rmv-m) -- (a-recv-rmv-m);
        \end{tikzpicture}
      }
      \caption{Modifications concurrentes d'une séquence répliquée \ac{RGA}}
      \label{fig:rga}
    \end{figure}
    \mnnote{TODO: Trouver exemple et le présenter.}
  \item À la différence des auteurs de WOOT, \citeauthor{ROH2011354} jugent le coût des tombstones trop élévé.
    Ils proposent alors un mécanisme de \ac{GC} des tombstones.
    Ce mécanisme repose sur deux conditions :
    \begin{enumerate}[label=(\roman*)]
      \item \label{item:gc-rga-1}
        La stabilité causale de l'opération $\trm{rmv}$, \ie l'ensemble des noeuds a observé la suppression de l'élément et ne peut émettre d'opérations utilisant l'élément supprimé comme prédecesseur.
      \item \label{item:gc-rga-2}
        L'impossibilité pour l'ensemble des noeuds de générer un \emph{S4Vector} plus petit que l'élément suivant la tombstone\footnote{On constate cependant que la condition \ref{item:gc-rga-1} implique la condition \ref{item:gc-rga-2}, puisque tout noeud ayant observé l'insertion de l'élément suivant possédera un vecteur d'horloges supérieur.}.
    \end{enumerate}
  \item Concernant le modèle de livraison adopté, \ac{RGA} repose sur une livraison causale des opérations.
    \cite{ROH2011354} indique que ce modèle de livraison pourrait être relaxé, de façon à ne plus dépendre de vecteurs d'horloges.
    Ce point est néanmoins laissé comme piste de recherche future.
    À notre connaissance, celle-ci n'a pas été explorée dans la littérature.
    Dans \cite{2021-these-vic}, \citeauthor{2021-these-vic} indique que \ac{RGA} pourrait adopter le même modèle de livraison que WOOT.
    Pour rappel, celui-ci consiste en :
    \begin{enumerate}[label=(\roman*)]
      \item L'opération $\trm{ins}(\trm{predId} \prec \langle \trm{id},\trm{elt} \rangle)$ ne peut être délivrée qu'après la livraison de l'opération d'insertion de l'élément associé à $\trm{predId}$.
      \item L'opération $\trm{rmv}(\trm{id})$ ne peut être délivrée qu'après la livraison de l'opération d'insertion de l'élément associé à $\trm{id}$.
    \end{enumerate}
    Nous secondons cette observation.
  \item \mnnote{TODO: Ajouter quelques lignes sur efficacité de \ac{RGA}.
      Meilleure complexité en temps pour l'intégration des opérations.
      \cite{10.1145/2933057.2933090, ATTIYA2021141} montrent que \ac{RGA} est optimal du point de vue complexité spatiale comme \ac{CRDT} pour Séquence par élément basée sur l'approche tombstone.
      Implémenté dans Yjs et Automerge.
    }
  \item Plusieurs extensions de \ac{RGA} furent proposées par la suite.
    Dans \cite{briot:hal-01343941}, \citeauthor{briot:hal-01343941} indiquent que les pauvres performances des modifications locales\footnote{Relativement par rapport aux algorithmes de l'approche \ac{OT}.} des \acp{CRDT} pour Séquence constituent une de leurs limites.
    Il s'agit en effet des performances impactant le plus l'expérience utilisateur, celleux-ci s'attendant à un feedback immédiat de la part de l'application.
    Les auteurs souhaitent donc réduire la complexité en temps des modifications locales à une complexité logarithmique.
    Pour cela, ils proposent l'\emph{identifier structure}, une structure de données auxiliaire utilisable par les \acp{CRDT} pour Séquence.
    Cette structure permet de retrouver plus efficacement l'identifiant d'un élément à partir de son index, au pris d'un surcoût en métadonnées.
    \citeauthor{briot:hal-01343941} combinent cette structure de données à un mécanisme d'aggrégation des élements en blocs\footnote{Nous détaillerons ce mécanisme par la suite.} tels que proposés par \cite{2012-string-wise,2013-logootsplit}, qui permet de réduire la quantité de métadonnées stockées par la séquence répliquée.
    Cette combinaison aboutit à la définition d'un nouveau \ac{CRDT} pour Séquence, \emph{RGATreeSplit}, qui offre une meilleure complexité en temps et en espace.
  \item Dans \cite{2019-interleaving-anomalies-collaborative-editors-kleppmann}, \citeauthor{2019-interleaving-anomalies-collaborative-editors-kleppmann} mettent en lumière un problème des \acp{CRDT} pour Séquence.
    Lorsque des séquences de modifications sont effectuées en concurrence par des noeuds, les \acp{CRDT} assurent la convergence des répliques mais pas la correction du résultat.
    Notamment, il est possible que les éléments insérés en concurrence se retrouvent entrelacés.
    \begin{figure}[!ht]

      \centering
      \resizebox{\columnwidth}{!}{
        \begin{tikzpicture}
          \newcommand\initialstate[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$t_1$}] {A}
              ++(0:\widthletter) node[letter, label=#2:{$t_2$}] {B}
              ++(0:\widthletter) node[letter, label=#2:{$t_3$}] {C}
              ++(0:\widthletter) node[letter, label=#2:{$t_4$}] {!}
          }

          \newcommand\inse[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$t_1$}] {A}
              ++(0:\widthletter) node[letter, label=#2:{$t_2$}] {B}
              ++(0:\widthletter) node[letter, label=#2:{$t_3$}] {C}
              ++(0:\widthletter) node[letter, label=#2:{$t_5$}] {E}
              ++(0:\widthletter) node[letter, label=#2:{$t_4$}] {!}
          }

          \newcommand\insf[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$t_1$}] {A}
              ++(0:\widthletter) node[letter, label=#2:{$t_2$}] {B}
              ++(0:\widthletter) node[letter, label=#2:{$t_3$}] {C}
              ++(0:\widthletter) node[letter, label=#2:{$t_5$}] {E}
              ++(0:\widthletter) node[letter, label=#2:{$t_6$}] {F}
              ++(0:\widthletter) node[letter, label=#2:{$t_4$}] {!}
          }

          \newcommand\insd[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$t_1$}] {A}
              ++(0:\widthletter) node[letter, label=#2:{$t_2$}] {B}
              ++(0:\widthletter) node[letter, label=#2:{$t_3$}] {C}
              ++(0:\widthletter) node[letter, label=#2:{$t_9$}] {D}
              ++(0:\widthletter) node[letter, label=#2:{$t_5$}] {E}
              ++(0:\widthletter) node[letter, label=#2:{$t_6$}] {F}
              ++(0:\widthletter) node[letter, label=#2:{$t_4$}] {!}
          }

          \newcommand\insg[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$t_1$}] {A}
              ++(0:\widthletter) node[letter, label=#2:{$t_2$}] {B}
              ++(0:\widthletter) node[letter, label=#2:{$t_3$}] {C}
              ++(0:\widthletter) node[letter, label=#2:{$t_7$}] {G}
              ++(0:\widthletter) node[letter, label=#2:{$t_4$}] {!}
          }

          \newcommand\insh[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$t_1$}] {A}
              ++(0:\widthletter) node[letter, label=#2:{$t_2$}] {B}
              ++(0:\widthletter) node[letter, label=#2:{$t_3$}] {C}
              ++(0:\widthletter) node[letter, label=#2:{$t_7$}] {G}
              ++(0:\widthletter) node[letter, label=#2:{$t_8$}] {H}
              ++(0:\widthletter) node[letter, label=#2:{$t_4$}] {!}
          }

          \newcommand\finalstate[2]{
            \path
              #1
              ++(0:0.5)
              ++(#2:0.5) node[letter, label=#2:{$t_1$}] {A}
              ++(0:\widthletter) node[letter, label=#2:{$t_2$}] {B}
              ++(0:\widthletter) node[letter, label=#2:{$t_3$}] {C}
              ++(0:\widthletter) node[letter, label=#2:{$t_9$}] {D}
              ++(0:\widthletter) node[letter, label=#2:{$t_7$}] {G}
              ++(0:\widthletter) node[letter, label=#2:{$t_8$}] {H}
              ++(0:\widthletter) node[letter, label=#2:{$t_5$}] {E}
              ++(0:\widthletter) node[letter, label=#2:{$t_6$}] {F}
              ++(0:\widthletter) node[letter, label=#2:{$t_4$}] {!}
          }

          \path
              node {\textbf{A}}
              ++(0:0.5) node (a) {}
              +(0:49) node (a-end) {}
              +(0:2) node[point] (a-initial) {}
              +(0:9) node[point, label=-170:{$\trm{ins}(C \prec E)$}, label={[xshift=0.3em]-10:{$\trm{ins(t_3 \prec \langle t_5,E \rangle)}$}}] (a-ins-e) {}
              +(0:17) node[point, label=-170:{$\trm{ins}(E \prec F)$}, label={[xshift=0.3em]-10:{$\trm{ins(t_5 \prec \langle t_6,F \rangle)}$}}] (a-ins-f) {}
              +(0:26) node[point, label=-170:{$\trm{ins}(C \prec D)$}, label={[xshift=0.3em]-10:{$\trm{ins(t_3 \prec \langle t_9,D \rangle)}$}}] (a-ins-d) {}
              +(0:35) node[point, label=-170:{$\trm{sync}$}] (a-send-sync) {}
              +(0:39) node[point] (a-recv-sync) {}
              +(0:47) node (a-final) {};

          \initialstate{(a-initial)}{90};
          \inse{(a-ins-e)}{90};
          \insf{(a-ins-f)}{90};
          \insd{(a-ins-d)}{90};
          \finalstate{(a-recv-sync)}{90};

          \draw[dotted] (a) -- (a-initial) (a-final) -- (a-end);
          \draw[->, thick] (a-initial) --  (a-ins-e) --  (a-ins-f) --  (a-ins-d) --  (a-send-sync) --  (a-recv-sync) -- (a-final);

          \path
              ++(270:3) node {\textbf{B}}
              ++(0:0.5) node (b) {}
              +(0:49) node (b-end) {}
              +(0:2) node[point] (b-initial) {}
              +(0:9) node[point, label=170:{$\trm{ins}(C \prec G)$}, label={[xshift=0.3em]10:{$\trm{ins}(t_3 \prec \langle t7,G \rangle)$}}] (b-ins-g) {}
              +(0:17) node[point, label=170:{$\trm{ins}(G \prec H)$}, label={[xshift=0.3em]10:{$\trm{ins}(t_7 \prec \langle t8,H \rangle)$}}] (b-ins-h) {}
              +(0:35) node[point, label=170:{$\trm{sync}$}] (b-send-sync) {}
              +(0:39) node[point] (b-recv-sync) {}
              +(0:47) node (b-final) {};

          \initialstate{(b-initial)}{-90};
          \insg{(b-ins-g)}{-90};
          \insh{(b-ins-h)}{-90};
          \finalstate{(b-recv-sync)}{-90};

          \draw[dotted] (b) -- (b-initial) (b-final) -- (b-end);
          \draw[->, thick] (b-initial) --  (b-ins-g) --  (b-ins-h) --  (b-send-sync) -- (b-recv-sync) -- (b-final);

          \draw[->, dashed, shorten >= 1] (a-send-sync) -- (b-recv-sync);
          \draw[->, dashed, shorten >= 1] (b-send-sync) -- (a-recv-sync);
        \end{tikzpicture}
      }
      \caption{Entrelacement d'éléments insérés de manière concurrente}
      \label{fig:rga-interleaving}
    \end{figure}
    \mnnote{TODO: Insérer et présenter exemple}
    Pour remédier à ce problème, les auteurs définissent une nouvelle spécification que doivent respecter les approches pour la mise en place de séquences répliquées : \emph{la spécification forte sans entrelacement des séquences répliquées}.
    Basée sur la spécification forte des séquences répliquées spécifiée dans \cite{10.1145/2933057.2933090, ATTIYA2021141}, cette nouvelle spécification ajoute comme propriété que les éléments insérés en concurrence ne doivent pas s'entrelacer dans l'état final.
    \citeauthor{2019-interleaving-anomalies-collaborative-editors-kleppmann} proposent ensuite une évolution de \ac{RGA} respectant cette spécification.
    Pour cela, les auteurs ajoutent à l'opération $\trm{ins}$ un paramètre, $\trm{samePredId}$, un ensemble correspondant à l'ensemble des identifiants connus utilisant le même $\trm{predId}$ que l'élément inséré.
    En maintenant en plus un exemplaire de cet ensemble pour chaque élément de la séquence, il est possible de déterminer si deux opérations $\trm{ins}$ sont concurrentes ou causalement liées et ainsi déterminer comment ordonner leurs éléments.
    Cependant, les auteurs ne prouvent pas dans \cite{2019-interleaving-anomalies-collaborative-editors-kleppmann} que cette extension empêche tout entrelacement\footnote{Un travail en cours \cite{2022-no-doubly-non-interleaving-crdts-weidner} indique en effet qu'une séquence répliquée empêchant tout entrelacement est impossible.}.
\end{itemize}

\subsection{Approche à identifiants densément ordonnés}

\subsubsection{Treedoc}

\begin{itemize}
  \item \cite{2007-crdt-shapiro, 2009-treedoc-preguica} proposent une nouvelle approche pour CRDTs pour Séquence.
    Se base sur des identifiants de position, respectant les propriétés suivantes :
    \begin{enumerate}[label=(\roman*)]
      \item Chaque élément se voit attribuer un identifiant.
      \item \label{item:uniqueness} Aucune paire d'éléments ne partage le même identifiant.
      \item L'identifiant d'un élément est immuable.
      \item Il existe un ordre total strict sur les identifiants, $\lid$, cohérent avec l'ordre des éléments dans la séquence.
      \item \label{item:dense-space}
        Les identifiants sont tirés d'un ensemble dense, noté $\mathbb{I}$.
    \end{enumerate}
  \item La propriété \ref{item:dense-space} signifie que :
    \[\forall \trm{predId}, \trm{succId} \in \mathbb{I}, \exists \trm{id} \in \mathbb{I} \cdot \trm{predId} \lid \trm{id} \lid \trm{succId} \]
    Par exemple, les nombres réels forment un ensemble dense.
    Ceux-ci sont néanmoins inutilisables en informatique puisqu'ils nécessiteraient une précision infinie.
    \cite{2009-treedoc-preguica} utilise donc un type dédié pour les émuler.
  \item L'utilisation d'identifiants de position permet de redéfinir les modifications :
    \begin{enumerate}[label=(\roman*)]
      \item $\trm{ins}(\trm{pred} \prec \trm{elt} \prec \trm{succ})$ devient alors $\trm{ins(\trm{id}, \trm{elt})}$, avec $\trm{predId} \lid \trm{id} \lid \trm{succId}$.
      \item $\trm{rmv}(\trm{elt})$ devient $\trm{rmv}(\trm{id})$.
    \end{enumerate}
    Ces redéfinitions permettent d'obtenir une spécification de la séquence avec des modifications commutatives.
  \item À partir de cette spécification, \citeauthor{2009-treedoc-preguica} propose un CRDT pour Séquence : \emph{Treedoc}.
    Ce dernier se base sur un arbre binaire pour générer les identifiants de position.
  \item La racine de l'arbre binaire, notée $\epsilon$, correspond à l'identifiant du premier élément inséré dans la séquence répliquée.
    Puis, pour générer l'identifiant d'un nouvel élément inséré à gauche (resp. à droite) d'un noeud de l'arbre binaire, Treedoc concatène un $0$ (resp. un $1$) à l'identifiant de ce dernier.
    \mnnote{TODO: Figure arbre binaire d'identifiants.}
    \begin{figure}[!ht]

      \centering
      \resizebox{0.3\columnwidth}{!}{
        \begin{tikzpicture}
          \newcommand\leftchild[3]{
            \path
              #1
              +(220:2) node[node] #2 {#3};
              \draw[thick] #1 -- #2 node[midway, above left] {0};
          }
          \newcommand\rightchild[3]{
            \path
              #1
              +(320:2) node[node] #2 {#3};
            \draw[thick] #1 -- #2 node[midway, above right] {1};
          }

          \path node[node, label={above:{$\epsilon$}}] (c) {C};
          \leftchild{(c)}{(a)}{A};
          \rightchild{(a)}{(b)}{B};
          \rightchild{(c)}{(d)}{D};
          \rightchild{(d)}{(e)}{E};
        \end{tikzpicture}
      }
      \caption{Identifiants de positions}
      \label{fig:treedoc-ids}
    \end{figure}
  \item Ce mécanisme souffre néanmoins d'un écueil : en l'état, plusieurs noeuds du systèmes peuvent générer un même identifiant pour des éléments insérés en concurrence, contravenant alors à la propriété \ref{item:uniqueness}.
    Pour corriger cela, Treedoc ajoute aux identifiants des désambiguateurs : un \emph{Dot}.
    Un désambiguateur est ajouté à chaque partie d'un identifiant lorsque nécessaire, \ie
    \begin{enumerate}[label=(\roman*)]
      \item La partie courante de l'identifiant est la fin de l'identifiant.
      \item La partie courante de l'identifiant nécessite désambiguation, \ie plusieurs éléments utilisent ce même identifiant.
    \end{enumerate}
    Il convient de noter que les noeuds de l'arbre binaire des identifiants peuvent ainsi contenir une liste d'identifiants en cas d'insertions concurrentes.
    \mnnote{TODO: Figure arbre binaire d'identifiants avec désambiguateurs et mini-nodes.}
  \item \mnnote{TODO: Figure exemple d'édition collaborative}
  \item Concernant le modèle de livraison utilisé, \cite{2009-treedoc-preguica} indique reposer sur le modèle de livraison causal.
    En pratique, nous pouvons néanmoins relaxer le modèle de livraison comme expliqué dans \cite{2021-these-vic} :
    \begin{enumerate}[label=(\roman*)]
      \item Les opérations $\trm{ins}$ peuvent être livrées dans n'importe quel ordre.
      \item L'opération $\trm{rmv}(\trm{id})$ ne peut délivrée qu'après la livraison de l'opération d'insertion de l'élément associé à $\trm{id}$.
    \end{enumerate}
  \item Treedoc souffre néanmoins de plusieurs limites.
    Tout d'abord, le mécanisme d'identifiants de positions proposé est couplé à la structure d'arbre binaire.
    Cependant, les utilisateur-rices ont tendance à écrire de manière séquentielle, \ie dans le sens d'écriture de la langue utilisée.
    Les nouveaux identifiants forment donc généralement une liste chaînée, qui déséquilibre l'arbre.
  \item Ensuite, Treedoc doit conserver un noeud de l'arbre des identifiants malgré sa suppression lorsque ce dernier possède des enfants.
    Ce noeud de l'arbre devient alors une pierre tombale.
    Le mécanisme de \ac{GC} des pierres tombales de Treedoc ne repose cependant pas sur la stabilité causale d'opérations, mais sur l'état du noeud de l'arbre, \ie si la pierre tombale devient une feuille.
    Néanmoins, l'évaluation de \cite{2009-treedoc-preguica} a montré que les pierres tombales pouvait représenter jusqu'à 95\% des noeuds de l'arbre.
  \item Finalement, Treedoc souffre du problème de l'entrelacement d'éléments insérés de manière concurrente, contrairement à ce qui est conjecturé dans \cite{2019-interleaving-anomalies-collaborative-editors-kleppmann}.
\end{itemize}

\subsubsection{Logoot}

\begin{itemize}
  \item Logoot \cite{WeissICDCS09, weiss:hal-00450416}
\end{itemize}

\mnnote{NOTE: Ajouter LogootSplit de manière sommaire aussi à cet endroit?}

\mnnote{TODO: Autres Sequence CRDTs à considérer : String-wise CRDT \cite{2012-string-wise}, Chronofold \cite{2020-chronofold}}

\subsection{Synthèse}

\begin{itemize}
  \item Deux approches différentes pour la résolution de conflits ont été proposées pour \acp{CRDT} pour Séquence.
    Chacune de ces approches visent à minimiser surcoût du type répliqué, que ce soit d'un point de vue mémoire, computations et réseau.
  \item Au fil des années, ces approches ont été raffinées avec de nouveaux \acp{CRDT} de plus en plus en efficaces.
  \item Néanmoins, malgré les évaluations et comparaisons, la littérature n'a pas établi une supériorité d'une approche sur l'autre.
    Les approches proposent seulement des compromis différents sur la nature du surcoût, que nous récapitulons dans \autoref{tab:sequence-crdts}.
    L'approche basée sur pierres tombales offre une consommation réseau constante grâce à ses identifiants de taille fixe, mais souffre d'une consommation mémoire ne pouvant qu'augmenter.
    L'approche basée sur identifiants densément ordonnés bénéficie d'un meilleur délai de diffusion des modifications, les modifications pouvant être livrées dans le désordre, mais souffre d'une empreinte réseau augmentant avec la taille de ses identifiants.
    L'approche basée sur pierres tombales et l'approche basée sur identifiants densément ordonnés souffrent toutes les deux d'une augmentation théorique de leur surcoût en mémoire et en computations, respectivement dûe au nombre forcément croissant d'éléments stockées dans la Séquence et à la taille croissante\footnote{\cite{2011-evaluation-crdts-ahmed-nacer} montre expérimentalement que les performances de l'approche basée sur identifiants densément ordonnés restent stables tout au long des tâches d'édition collaborative proposées.} des identifiants associés aux éléments de la Séquence.

    \begin{table}[!ht]
      \centering
      \caption{Récapitulatif comparatif des différents approches pour \acp{CRDT} pour Séquence}
      \label{tab:sequence-crdts}
      % \resizebox{\columnwidth}{!}{
        \begin{tabular}{lcc}
          \toprule
                                                    & Dense ids-based & Tombstoned-based  \\
          \midrule
          Performances stables                      & \ballotx        & \ballotx          \\
          Identifiants de taille fixe               & \ballotx        & \checkmark        \\
          Eléments réellement supprimés             & \checkmark      & \ballotx          \\
          Empreinte réseau fixe                     & \ballotx        & \checkmark        \\
          Peut s'affranchir de la cohérence causale & \checkmark      & \checkmark          \\
          \bottomrule
        \end{tabular}
      % }
    \end{table}

  \item Pour la suite de ce manuscrit, nous prenons LogootSplit comme base de travail.
    Nous détaillons donc son fonctionnement dans la section suivante.
\end{itemize}

\section{LogootSplit}

\label{sec:logootsplit}

LogootSplit \cite{2013-logootsplit} est l'état de l'art des séquences répliquées à identifiants densément ordonnés.
Comme expliqué précédemment, LogootSplit utilise des identifiants provenant d'un ordre total dense pour positionner les éléments dans la séquence répliquée.

\subsection{Identifiants}

Pour ce faire, LogootSplit assigne des identifiants composés d'une liste de tuples aux éléments.
Les tuples sont définis de la manière suivante :

\begin{definition}[Tuple]
  Un \emph{Tuple} est un quadruplet $\langle$position, nodeId, nodeSeq, offset$\rangle$ où
  \begin{itemize}
    \item position incarne la position souhaitée de l'élément.
    \item nodeId est l'identifiant unique du noeud qui a généré le tuple.
    \item nodeSeq est le numéro de séquence courant du noeud à la génération du tuple.
    \item offset indique la position de l'élément au sein d'un bloc. Nous reviendrons plus en détails sur ce composant dans la \autoref{sec:blocs}.
  \end{itemize}
\end{definition}

\mnnote{TODO: Ajouter une relation d'ordre sur les tuples}

Dans ce manuscrit, nous représentons les tuples par le biais de la notation suivante : \id{position}{nodeId~nodeSeq}{offset} où $\trm{position}$ est une lettre minuscule, $\trm{nodeId}$ une lettre majuscule et $\trm{nodeSeq}$ et $\trm{offset}$ des entiers, \eg \id{i}{B0}{0}.

À partir de là, les identifiants LogootSplit sont définis de la manière suivante :

\begin{definition}[Identifiant]
  Un \emph{Identifiant} est une liste de \emph{Tuples}.
\end{definition}

\mnnote{TODO: Définir la notion de base (et autres fonctions utiles sur les identifiants ? genre isPrefix, concat, getTail...)}

Nous représentons les identifiants en listant les tuples qui les composent.
Par exemple, l'identifiant composé des tuples $\langle\langle$i, B, 0, 0$\rangle\langle$f, A, 0, 0$\rangle\rangle$ est présenté de la manière suivante : \id{i}{B0}{0}\id{f}{A0}{0}.

Les identifiants ont pour rôle d'ordonner les éléments relativement les uns par rapport aux autres.
Pour ce faire, une relation d'ordre total aux identifiants est associée à l'ensemble des identifiants :

\begin{definition}[Relation $\lid$]
  La relation $\lid$ est un ordre strict total sur l'ensemble des identifiants.
  Elle permet aux noeuds de comparer n'importe quelle paire d'identifiants.
  Elle est définie en utilisant l'ordre lexicographique sur les composants des différents tuples des identifiants comparés.
\end{definition}

\begin{itemize}
  \item En utilisant cette relation d'ordre, les noeuds peuvent ordonner les éléments grâce à leur identifiant.
  \item Par exemple, déterminent que \id{i}{A1}{0} $\lid$ \id{i}{B0}{0} car les positions sont identiques et que le \emph{nodeId} (A) du premier est plus petit que le \emph{nodeId} (B) du second
  \item et que \id{i}{B0}{0} $\lid$ \id{i}{B0}{0}\id{f}{A0}{0} car le premier est un préfixe du second
\end{itemize}

\mnnote{TODO: Montrer que cet ensemble d'identifiants est un ensemble dense}

\subsection{Aggrégation dynamique d'élements en blocs}

\label{sec:blocs}

Au lieu de stocker les identifiants de chaque élément de la séquence, LogootSplit propose d'aggréger de façon dynamique les éléments dans des blocs.
Pour cela, LogootSplit introduit la notion d'intervalle d'identifiants :

\begin{definition}[IdInterval]
  Un \emph{IdInterval} est un couple $\langle$idBegin, offsetEnd$\rangle$ où
  \begin{itemize}
    \item idBegin est l'identifiant du premier élément de l'interval.
    \item offsetEnd est l'offset du dernier identifiant de l'interval.
  \end{itemize}
\end{definition}

Les intervalles d'identifiants permettent à LogootSplit d'assigner logiquement un identifiant à un ensemble d'éléments, tout en ne stockant réellement que l'identifiant de son premier élément et le dernier offset de son dernier élément.

LogootSplit regroupe les éléments avec des identifiants \emph{contigus} dans un interval.
Nous appelons \emph{contigus} deux identifiants qui partagent une même base (\ie qui sont identiques à l'exception de leur dernier offset) et dont les \emph{offsets} sont consécutifs.
Nous représentons un intervalle d'identifiants à l'aide du formalisme suivant : \id{position}{nodeId~nodeSeq}{begin..end} où $\trm{begin}$ est l'offset du premier identifiant de l'intervalle et $\trm{end}$ du dernier.

Les blocs permettent d'associer un intervalle d'identifiants aux éléments correspondant.
Les blocs sont définis de la manière suivante :

\begin{definition}[Bloc]
  Un \emph{Bloc} est un quadruplet $\langle$idInterval, elts, isAppendable, isPrependable$\rangle$ où
  \begin{itemize}
    \item idInterval est l'intervalle d'identifiants formant le bloc
    \item elts sont les éléments contenus dans le bloc
    \item isAppendable (resp. isPrependable) est un booléen indiquant si l'auteur du bloc peut ajouter un nouvel élément en fin (resp. début) de bloc
  \end{itemize}
\end{definition}

La \autoref{fig:logootsplit-seq} présente un exemple de séquence LogootSplit : dans la \autoref{fig:logootsplit-seq-as-letters}, les identifiants \id{i}{B0}{0}, \id{i}{B0}{1}, \id{i}{B0}{2} forment une chaîne d'identifiants contigus.
LogootSplit est donc capable de regrouper ces éléments en un bloc représentant l'intervalle d'identifiants \id{i}{B0}{0..2} pour minimiser les métadonnées stockées, comme montré dans la \autoref{fig:logootsplit-seq-as-block}.

\begin{figure}[!ht]
  \centering
  \subfloat[Éléments avec leur identifiant correspondant]{
      \begin{minipage}{.48\linewidth}
      \centering
          \begin{tikzpicture}
              \path
                  node[letter, label=below:{\id{i}{B0}{0}}] {H}
                  ++(0:\widthletter) node[letter, label=below:{\id{i}{B0}{1}}] {L}
                  ++(0:\widthletter) node[letter, label=below:{\id{i}{B0}{2}}] {O};
          \end{tikzpicture}
          \label{fig:logootsplit-seq-as-letters}
      \end{minipage}}
  \hfil
  \subfloat[Éléments regroupés en un bloc]{
      \begin{minipage}{.48\linewidth}
      \centering
          \begin{tikzpicture}
              \path
                  node[block, label=below:{\id{i}{B0}{0..2}}] {HLO};
          \end{tikzpicture}
          \label{fig:logootsplit-seq-as-block}
      \end{minipage}}
  \caption{Représentation d'une séquence LogootSplit contenant les éléments "HLO"}
  \label{fig:logootsplit-seq}
\end{figure}

Cette fonctionnalité réduit le nombre d'identifiants stockés au sein de la structure de données, puisque les identifiants sont conservés à l'échelle des blocs plutôt qu'à l'échelle de chaque élément.
Ceci permet de réduire de manière significative le surcoût en métadonnées de la structure de données.
L'utilisation de blocs améliore aussi les performances de la structure de données.
En effet, l'utilisation de blocs permet de parcourir plus efficacement la structure de données.
Les blocs permettent aussi d'effectuer des modifications à l'échelle de la chaîne de caractères et non plus seulement caractère par caractère.

\mnnote{TODO: indiquer que le couple $\langle$nodeId, nodeSeq$\rangle$ permet d'identifier de manière unique la base d'un bloc ou d'un identifiant}

Notons que pour une séquence donnée, nous pouvons identifier chacun de ses identifiants par le triplet $\langle$nodeId, nodeSeq, offset$\rangle$ issue de leur dernier Tuple.
Par exemple, le triplet $\langle$B, 0, 2$\rangle$ désigne de manière unique l'identifiant \id{i}{B0}{2} dans \autoref{fig:logootsplit-seq}.

\subsection{Modèle de données}

\textcite{2013-logootsplit} définissent une séquence LogootSplit de la manière suivante :

\begin{definition}[Séquence LogootSplit]
  \label{def:logootsplit}
  Une séquence \emph{Séquence LogootSplit} est un triplet $\langle$nodeId, nodeSeq, blocks$\rangle$ où
  \begin{itemize}
    \item nodeId est l'identifiant du noeud.
    \item nodeSeq est le numéro de séquence courant du noeud.
    \item blocks est une liste de Blocs correspondant à l'état actuel de la séquence répliquée.
  \end{itemize}
\end{definition}

Plusieurs fonctions sont définies sur cette structure de données et permettent de l'interroger et de la modifier :

\begin{itemize}
  \item ins(S, index, elts) permet d'insérer les éléments elts à la position index dans la séquence S.
    Cette fonction génère et associe un intervalle d'identifiants valide aux éléments insérés
    Elle retourne une opération \emph{insert} permettant aux autres noeuds d'intégrer la modification à leur état.
\end{itemize}

\begin{definition}[insert]
  Une opération \emph{insert} est un couple $\langle$id, elts$\rangle$ où
  \begin{itemize}
    \item id est l'identifiant du premier élément inséré par cette opération.
    \item elts est la liste des éléments insérés par cette opération.
  \end{itemize}
\end{definition}

\begin{itemize}
  \item rem(S, index, length) permet de supprimer length éléments à partir la position index dans la séquence S.
  Cette fonction répertorie les éléments supprimés sous la forme d'intervalles d'identifiants.
  Elle retourne une opération \emph{remove} permettant aux autres noeuds d'intégrer la modification à leur état.
\end{itemize}

\begin{definition}[remove]
  Une opération \emph{remove} est une liste d'intervalles d'identifiants où chaque intervalle désigne un ensemble d'éléments à supprimer.
\end{definition}

Nous présentons dans la \autoref{fig:logootsplit-example} un exemple d'utilisation de cette séquence répliquée.

\begin{figure}[!ht]
  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
        \path
            node {\textbf{A}}
            ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{0..3}}] (S0A) {HRLO}
            ++(0:5 * \widthletter) node[letter, label=below:{\id{i}{B0}{0}}] (S1A-left) {H}
            ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{2..3}}] (S1A-right) {LO}
            ++(0:6 * \widthletter) node[letter, label=below:{\id{i}{B0}{0}}] (S2A-left) {H}
            ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{A0}{0}}] {E}
            ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{2..3}}] (S2A-right) {LO}
            ++(0:6 * \widthletter) node[letter, label=below:{\id{i}{B0}{0}}] (S3A-left) {H}
            ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{A0}{0}}] {E}
            ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{2..4}}] {LO!};


        \path
            ++(270:4) node {\textbf{B}}
            ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{0..3}}] (S0B) {HRLO}
            ++(0:5 * \widthletter) node[block, label=below:{\id{i}{B0}{0..4}}] (S1B) {HRLO!}
            ++(0:7 * \widthletter) node[letter, label=below:{\id{i}{B0}{0}}] (S2B-left) {H}
            ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{2..4}}] (S2B-right) {LO!}
            ++(0:7 * \widthletter) node[letter, label=above:{\id{i}{B0}{0}}] (S3B-left) {H}
            ++(0:\widthletter) node[letter, fill=mydarkorange, label=below:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{A0}{0}}] {E}
            ++(0:\widthletter) node[block, label=above:{\id{i}{B0}{2..4}}] {LO!};

        \draw[->, thick]
          (S0A) edge node[above, align=center]{\emph{remove "R"}} (S1A-left)
          (S1A-right) edge node[above, align=center]{\emph{insert "E"}\\\emph{between}\\\emph{"H" and "L"}} (S2A-left)
          (S0B) edge node[below, align=center]{\emph{insert "!"}\\\emph{at the end}} (S1B);

        \draw[dotted]
          (S2A-right) -- (S3A-left)
          (S1B) -- (S2B-left)
          (S2B-right) -- (S3B-left);

        \draw[dashed, ->, thick, shorten >= 3]
          (S1A-right.east) edge node[right, align=center]{\emph{remove} \id{i}{B0}{1..1}}  (S2B-left.west)
          (S2A-right.east) edge node[below right, align=center]{\emph{insert "E" at} {\color{mydarkorange}\id{i}{B0}{0}\id{f}{A0}{0}}} (S3B-left.west)
          (S1B.east) edge node[below right, near end, align=center]{\emph{insert "!" at} \id{i}{B0}{4}} (S3A-left.west);


        % \draw[->, thick] (S0A-right) -- node[above, align=center]{\emph{rename}} (S1A);
        % \draw[dotted] (S1A) -- (S2A-left);
        % \draw[->, thick] (S0B-right) -- node[below, align=center]{\emph{insert "l"}\\\emph{between}\\\emph{"e" and "l"}} (S1B-left);
        % \draw[dashed, ->, thick, shorten >= 3] (S1B-right.east) -- node[below right, align=center]{\emph{insert "l" at} {\color{mylightorange}\id{i}{B0}{0}\id{m}{B1}{0}}} (S2A-left.west);

    \end{tikzpicture}
  }
  \caption{Modifications concurrentes d'une séquence répliquée LogootSplit}
  \label{fig:logootsplit-example}
\end{figure}

Dans cet exemple, deux noeuds A et B répliquent et éditent collaborativement un document texte en utilisant LogootSplit.
Ils partagent initialement le même état : une séquence composée d'un seul bloc associant les identifiants \id{i}{B0}{0..3} aux éléments "HRLO".
Les noeuds se mettent ensuite à éditer le document.

Le noeud A commence par supprimer l'élément "R" de la séquence.
LogootSplit génère l'opération \emph{remove} correspondante en utilisant l'identifiant de l'élément supprimé (\id{i}{B0}{1}).
Cette opération est envoyée au noeud B pour qu'il intègre cette modification.

Le noeud A insère ensuite un élément "E" dans la séquence, entre le "H" et le "L".
LogootSplit doit alors générer un identifiant $id$ à associer à ce nouvel élément.
Ce nouvel identifiant $id$ doit respecter la contrainte suivante : \id{i}{B0}{0} $\lid$ $id$ $\lid$ \id{i}{B0}{2}.
Cependant, LogootSplit ne peut pas générer un identifiant composé d'un seul tuple respectant cet ordre.
LogootSplit génère alors $id$ en recopiant le premier tuple (\id{i}{B0}{0}) et en y ajoutant un nouveau tuple (\id{f}{A0}{0}).
LogootSplit génère l'opération \emph{insert} correspondante, indiquant l'élément à insérer et sa position grâce à son identifiant.
Cette opération est ensuite diffusée sur le réseau.

En parallèle, le noeud B insère un élément "!" à la fin de la séquence.
Comme le noeud B est l'auteur du bloc \id{i}{B0}{0..3}, il peut y ajouter de nouveaux éléments.
LogootSplit associe donc l'identifiant \id{i}{B0}{4} à l'élément "!" et l'ajoute au bloc existant.

Les noeuds se synchronisent ensuite.
Le noeud A reçoit l'opération \emph{insert} de l'élément "!" à la position \id{i}{B0}{4}.
Le noeud A détermine que cet élément doit être inséré à la fin de la séquence (puisque \id{i}{B0}{3} $\lid$ \id{i}{B0}{4}) et qu'il peut être ajouté au bloc \id{i}{B0}{2..3} (puisque \id{i}{B0}{3} et \id{i}{B0}{4} sont contigus).

De son côté, le noeud B reçoit tout d'abord l'opération \emph{remove} des éléments identifiés par l'intervalle \id{i}{B0}{1..1}, \ie l'élément attaché à l'identifiant \id{i}{B0}{1}.
Le noeud B supprime donc l'élément "R" de son état.

Il reçoit ensuite l'opération \emph{insert} de l'élément "E" à la position \id{i}{B0}{0}\id{f}{A0}{0}.
Le noeud B insère cet élément entre les éléments "H" et "L" (puisque \id{i}{B0}{0} $\lid$ \id{i}{B0}{0}\id{f}{A0}{0} $\lid$ \id{i}{B0}{2}), respectant ainsi l'intention du noeud A.

\mnnote{NOTE: Pourrait définir dans cette sous-section la notion de séquence bien-formée}

\subsection{Modèle de livraison}

\label{sec:logootsplit-delivery-model}

Afin de garantir son bon fonctionnement, LogootSplit doit être associé à une couche de livraison de messages garantissant plusieurs propriétés.

\subsubsection{Livraison des opérations en exactement un exemplaire}

Tout d'abord, la couche de livraison de messages doit assurer que toutes les opérations soient délivrées aux noeuds, mais qu'une seule et unique fois.
La \autoref{fig:why-exactly-once-delivery} représente un exemple illustrant la nécessité de cette contrainte.

\begin{figure}[!ht]
  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
        \path
            node {\textbf{A}}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{0..4}}] (S0A) {OGNON}
            ++(0:5 * \widthletter) node[letter, label=below:{\id{p}{A0}{0}}] (S1A-left) {O}
            ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\id{p}{A0}{0}\id{m}{A1}{0}}] {I}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{1..4}}] (S1A-right) {GNON}
            ++(0:21 * \widthletter) node[letter, label=below:{\id{p}{A0}{0}}] (S2A-left) {O}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{1..4}}] {GNON};


        \path
            ++(270:4) node {\textbf{B}}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{0..4}}] (S0B) {OGNON}
            ++(0:12 * \widthletter) node[letter, label=below:{\id{p}{A0}{0}}] (S1B-left) {O}
            ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\id{p}{A0}{0}\id{m}{A1}{0}}] {I}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{1..4}}] (S1B-right) {GNON}
            ++(0:5 * \widthletter) node[letter, label=below:{\id{p}{A0}{0}}] (S2B-left) {O}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{1..4}}] (S2B-right) {GNON}
            ++(0:8 * \widthletter) node[letter, label=below:{\id{p}{A0}{0}}] (S3B-left) {O}
            ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\id{p}{A0}{0}\id{m}{A1}{0}}] {I}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{1..4}}] {GNON};

        \draw[->, thick]
          (S0A) edge node[above, align=center]{\emph{insert "I"}\\\emph{between}\\\emph{"O" and "G"}} (S1A-left)
          (S1B-right) edge node[above, align=center]{\emph{remove "I"}} (S2B-left);

        \draw[dotted]
          (S1A-right) -- (S2A-left)
          (S0B) -- (S1B-left)
          (S2B-right) -- (S3B-left);

        \draw[dashed, ->, thick, shorten >= 3]
          (S1A-right.east) edge node[right, align=center]{\emph{insert "I" at} {\color{mydarkorange}\id{p}{A0}{0}\id{m}{A1}{0}}}  (S1B-left.west)
          (S1A-right.east) edge node[right, align=center]{\emph{insert "I" at} {\color{mydarkorange}\id{p}{A0}{0}\id{m}{A1}{0}}}  (S3B-left.west)
          (S2B-right.east) edge node[below right, align=center]{\emph{remove} {\color{mydarkorange}\id{i}{B0}{1..1}}} (S2A-left.west);
    \end{tikzpicture}
  }
  \caption{Résurgence d'un élément supprimé suite à la relivraison de son opération \emph{insert}}
  \label{fig:why-exactly-once-delivery}
\end{figure}

Dans cet exemple, deux noeuds A et B répliquent et éditent collaborativement une séquence.
La séquence répliquée contient initialement les éléments "OGNON", qui sont associés à l'intervalle d'identifiants \id{p}{A0}{0..4}.

Le noeud A commence par insérer un nouvel élément, "I", dans la séquence entre les éléments "O" et "G".
L'opération \emph{insert} résultante, insérant l'élément "I" à la position \id{p}{A0}{0}\id{m}{A1}{0}, est diffusée au noeud B.

À la réception de l'opération \emph{insert}, le noeud B l'intègre à son état.
Puis il supprime dans la foulée ce nouvel élément.
L'opération \emph{remove} générée est envoyée au noeud A.

Le noeud A intègre l'opération \emph{remove}, ce qui a pour effet de supprimer l'élément "I" associé à l'identifiant \id{p}{A0}{0}\id{m}{A1}{0}.
Il obtient alors un état équivalent à celui du noeud B.

Cependant, l'opération \emph{insert} insérant l'élément "I" à la position \id{p}{A0}{0}\id{m}{A1}{0} est de nouveau délivrée au noeud B.
De multiples raisons peuvent être à l'origine de cette nouvelle livraison : perte du message d'\emph{acknowledgment}, utilisation d'un protocole de diffusion épidémique des messages, déclenchement du mécanisme d'anti-entropie en concurrence...
Le noeud B ré-intègre alors l'opération \emph{insert}, ce qui fait revenir l'élément "I" et l'identifiant associé.
L'état du noeud B diverge désormais de celui-ci du noeud A.

Pour se prémunir de ce type de scénarios, LogootSplit requiert que la couche de livraison des messages assure une livraison en exactement un exemplaire des opérations.
Cette contrainte permet d'éviter que d'anciens éléments et identifiants ressurgissent après leur suppression chez certains noeuds uniquement à cause d'une livraison multiple de l'opération \emph{insert} correspondante.

\mnnote{QUESTION: Ajouter quelques lignes ici sur comment faire ça en pratique (Ajout d'un dot aux opérations, maintien d'un dot store au niveau de la couche livraison, vérification que dot pas encore présent dans dot store avant de passer opération à la structure de données) ? Ou je garde ça pour le chapitre sur MUTE ?}

\subsubsection{Livraison de l'opération \emph{remove} après l'opération \emph{insert}}

Une autre propriété que doit assurer la couche de livraison de messages est que les opérations \emph{remove} doivent être livrées au \ac{CRDT} après les opérations \emph{insert} correspondantes.
La \autoref{fig:why-causal-remove} présente un exemple justifiant cette contrainte.

\begin{figure}[!ht]
  \centering
  \resizebox{\columnwidth}{!}{
    \begin{tikzpicture}
        \path
            node {\textbf{A}}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{0..4}}] (S0A) {OGNON}
            ++(0:5 * \widthletter) node[letter, label=below:{\id{p}{A0}{0}}] (S1A-left) {O}
            ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\id{p}{A0}{0}\id{m}{A1}{0}}] {I}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{1..4}}] (S1A-right) {GNON}
            ++(0:25 * \widthletter) node[letter, label=below:{\id{p}{A0}{0}}] (S2A-left) {O}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{1..4}}] {GNON};


        \path
            ++(270:4) node {\textbf{B}}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{0..4}}] (S0B) {OGNON}
            ++(0:12 * \widthletter) node[letter, label=below:{\id{p}{A0}{0}}] (S1B-left) {O}
            ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\id{p}{A0}{0}\id{m}{A1}{0}}] {I}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{1..4}}] (S1B-right) {GNON}
            ++(0:5 * \widthletter) node[letter, label=below:{\id{p}{A0}{0}}] (S2B-left) {O}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{1..4}}] (S2B-right) {GNON};

        \path
            ++(270:8) node {\textbf{C}}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{0..4}}] (S0C) {OGNON}
            ++(0:30 * \widthletter) node[letter, label=below:{\id{p}{A0}{0}}] (S1C-left) {O}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{1..4}}] (S1C-right) {GNON}
            ++(0:8 * \widthletter) node[letter, label=below:{\id{p}{A0}{0}}] (S2C-left) {O}
            ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\id{p}{A0}{0}\id{m}{A1}{0}}] {I}
            ++(0:\widthletter) node[block, label=below:{\id{p}{A0}{1..4}}] {GNON};

        \draw[->, thick]
          (S0A) edge node[above, align=center]{\emph{insert "I"}\\\emph{between}\\\emph{"O" and "G"}} (S1A-left)
          (S1B-right) edge node[above, align=center]{\emph{remove "I"}} (S2B-left);

        \draw[dotted]
          (S1A-right) -- (S2A-left)
          (S0B) -- (S1B-left)
          (S0C) -- (S1C-left)
          (S1C-right) -- (S2C-left);

        \draw[dashed, ->, thick, shorten >= 3]
          (S1A-right.east) edge node[right, align=center]{\emph{insert "I" at} {\color{mydarkorange}\id{p}{A0}{0}\id{m}{A1}{0}}}  (S1B-left.west)
          (S1A-right.east) edge node[pos=0.85, right, align=center]{\emph{insert "I" at} {\color{mydarkorange}\id{p}{A0}{0}\id{m}{A1}{0}}}  (S2C-left.west)
          (S2B-right.east) edge node[below right, align=center]{\emph{remove} {\color{mydarkorange}\id{i}{B0}{1..1}}} (S2A-left.west)
          (S2B-right.east) edge node[pos=0.80, right, align=center]{\emph{remove} {\color{mydarkorange}\id{i}{B0}{1..1}}} (S1C-left.west);
    \end{tikzpicture}
  }
  \caption{Non-effet de l'opération \emph{remove} car reçue avant l'opération \emph{insert} correspondante}
  \label{fig:why-causal-remove}
\end{figure}

Dans cet exemple, trois noeuds A, B et C répliquent et éditent collaborativement une séquence.
Le noeud A commence par insérer un nouvel élément, "I", dans la séquence entre les éléments "O" et "G".
L'opération \emph{insert} résultante, insérant l'élément "I" à la position \id{p}{A0}{0}\id{m}{A1}{0}, est diffusée aux autres noeuds.

À la réception de l'opération \emph{insert}, le noeud B l'intègre à son état.
Cependant, le noeud B supprime dans la foulée l'élément nouvellement ajouté.
Il diffuse ensuite l'opération \emph{remove} générée.

Toutefois, suite à un aléa du réseau, l'opération \emph{remove} supprimant l'élément "I" est livrée au noeud C avant l'opération \emph{insert} l'ajoutant à son état.
Lorsque le noeud C reçoit l'opération \emph{remove}, il parcourt son état à la recherche de l'élément "I" pour le supprimer.
Cependant, celui-ci n'est pas présent dans son état courant.
L'intégration de l'opération s'achève donc sans effectuer de modification.

Le noeud C reçoit ensuite l'opération \emph{insert}.
Le noeud C intègre ce nouvel élément dans la séquence en utilisant son identifiant (\id{p}{A0}{0} $\lid$ \id{p}{A0}{0}\id{m}{A1}{0} $\lid$ \id{p}{A0}{1}).

Ainsi, l'état du noeud C diverge de celui-ci des autres noeuds à terme, et cela malgré que les noeuds A, B et C aient intégré le même ensemble d'opérations.
Ce résultat transgresse la propriété de \ac{SEC} que doivent assurer les \acp{CRDT}.
Afin d'empêcher ce scénario de se produire, LogootSplit impose donc la livraison causale des opérations \emph{remove} par rapport aux opérations \emph{insert} correspondantes.

\mnnote{QUESTION: Même que pour la exactly-once delivery, est-ce que j'explique ici comment assurer cette contrainte plus en détails (Ajout des dots des opérations \emph{insert} en dépendances de l'opération \emph{remove}, vérification que dots présents dans dot store avant de passer l'opération \emph{remove} à la structure de données) ou je garde ça pour le chapitre sur MUTE ?}

\subsubsection{Définition du modèle de livraison}

Pour résumer, la couche de livraison des opérations associée à LogootSplit doit respecter le modèle de livraison suivant :

\begin{definition}[Exactly-once + Causal remove]
  \label{def:ls-delivery-model}
  Le modèle de livraison \emph{Exactly-once + Causal remove} définit les 3 règles suivantes sur la livraison des opérations :
  \begin{enumerate}
    \item Une opération doit être délivrée à l'ensemble des noeuds à terme,
    \item Une opération doit être délivrée qu'une seule et unique fois aux noeuds,
    \item Une opération \emph{remove} doit être délivrée à un noeud une fois que les opérations \emph{insert} des éléments concernés par la suppression ont été délivrées à ce dernier.
  \end{enumerate}
\end{definition}

Il est à noter que \textcite{2021-these-vic} a récemment proposé dans ses travaux de thèse Dotted LogootSplit, un nouveau Sequence \ac{CRDT} basée sur les différences.
Inspiré de Logoot et LogootSplit, ce nouveau \ac{CRDT} associe une séquence à identifiants densément ordonnés à un contexte causal.
Le contexte causal est une structure de données permettant à Dotted LogootSplit de représenter et de maintenir efficacement les informations des modifications déjà intégrées à l'état courant.
Cette association permet à Dotted LogootSplit de fonctionner de manière autonome, sans imposer de contraintes particulières à la couche livraison autres que la livraison à terme.

\subsection{Limites}

Comme indiqué précédemment, la taille des identifiants provenant d'un ordre total dense est variable.
Quand les noeuds insèrent de nouveaux éléments entre deux autres ayant la même valeur de \emph{position}, LogootSplit n'a pas d'autre choix que d'augmenter la taille de l'identifiant résultant.
La \autoref{fig:example-split} illustre de tels cas.
Dans cet exemple, puisque le noeud A insère un nouvel élément entre deux identifiants contigus \id{i}{B0}{0} et \id{i}{B0}{1}, LogootSplit ne peut pas générer un identifiant adapté de la même taille.
Pour respecter l'ordre souhaité, LogootSplit génère un identifiant en ajoutant un nouveau tuple à l'identifiant du prédecesseur : \id{i}{B0}{0}\id{f}{A0}{0}.

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}
      \path
          node {\textbf{A}}
          ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{0..2}}] (HLO) {HLO}
          ++(0:5 * \widthletter) node[letter, label=below:{\id{i}{B0}{0}}] (H) {H}
          ++(0:\widthletter) node[letter, fill=mydarkorange, label=above:{\color{mydarkorange}\id{i}{B0}{0}\id{f}{A0}{0}}] {E}
          ++(0:\widthletter) node[block, label=below:{\id{i}{B0}{1..2}}] {LO};

      \draw[->, thick] (HLO) -- node[below, align=center]{\emph{insert "E"}\\\emph{between}\\\emph{"H" and "L"}} (H);
  \end{tikzpicture}
  \caption{Insertion menant à une augmentation de la taille des identifiants}
  \label{fig:example-split}
\end{figure}

Par conséquent, la taille des identifiants a tendance à croître alors que le système progresse.
Cette croissance impacte négativement les performances de la structure de données sur plusieurs aspects.
Puisque les identifiants attachés aux éléments deviennent plus long, le surcoût en métadonnées augmente.
Ceci augmente aussi la consommation en bande-passante puisque les noeuds doivent diffuser les identifiants aux autres.

\mnnote{TODO: Ajouter une phrase pour expliquer que la croissance des identifiants impacte aussi le temps d'intégration des modifications}

De plus, le nombre de blocs composant la séquence répliquée augmente au fil du temps.
En effet, plusieurs contraintes sur la génération d'identifiants empêchent les noeuds d'ajouter des nouveaux éléments aux blocs existants.
Par exemple, seul le noeud qui a généré un bloc peut ajouter un élément à ce dernier.
Ces limitations provoquent la génération de nouveau blocs.
La séquence se retrouve finalement fragmentée en de nombreux blocs de seulement quelques caractères chacun.
Cependant, aucun mécanisme pour fusionner les blocs à posteriori n'est fourni.
L'efficacité de la structure décroît donc puisque chaque bloc entraîne un surcoût.

Comme illustré plus loin, nous avons mesuré au cours de nos évaluations que le contenu représente à terme moins de 1\% de taille de la structure de données.
Les 99\% restants correspondent aux métadonnées utilisées par la séquence répliquée.
Il est donc nécessaire de proposer des mécanismes et techniques afin de mitiger les problèmes soulignés précédemments.

\section{Mitigation du surcoût des séquences répliquées sans conflits}

\begin{itemize}
  \item Plusieurs approches ont été proposées pour réduire croissance des métadonnées dans Sequence \acp{CRDT}
  \item \ac{RGA} (et RGASplit) propose un mécanisme de GC des pierres tombales.
    Nécessite cependant stabilité causale des opérations de suppression.
    S'agit d'une contrainte forte, peu adaptée aux systèmes dynamiques à large échelle.
    \mnnote{TODO: Trouver référence sur la stabilité causale dans systèmes dynamiques}
  \item Core \& Nebula propose un mécanisme de ré-équilibrage de l'arbre pour Treedoc.
    Le ré-équilibrage a pour effet de supprimer des potentielles pierres tombales et de réduire la taille des identifiants.
    Repose sur un algorithme de consensus.
    S'agit de nouveau d'une contrainte forte pour systèmes dynamique à large échelle.
    Pour y pallier, propose de séparer les pairs entre deux ensembles : Core et Nebula.
    Permet de limiter le nombre participant au consensus.
    Un protocole de rattrapage permet aux noeuds de la Nebula de mettre à jour leurs modifications concurrentes à un ré-équilibrage.
  \item LSEQ adopte une autre approche.
    Part du constat que les identifiants dans Logoot croissent de manière linéaire.
    Vise une croissance logarithmique des identifiants.
    Pour cela, propose de nouvelles fonctions d'allocation des identifiants visant à maximiser le nombre d'identifiants insérés avant de devoir augmenter la taille de l'identifiant.
    Propose aussi d'utiliser une base exponentielle pour la valeur \emph{position} des identifiants.
    Atteint ainsi la croissance polylogarithmique des identifiants, sans coordination requise entre les noeuds et mécanisme supplémentaire.
    Solution adaptée aux systèmes distribués à large échelle.
    Conjecture cependant que cette approche se marie mal avec les Sequence \acp{CRDT} utilisant des blocs.
    En effet, ajoute une raison supplémentaire à la croissance des identifiants : l'insertion entre identifiants contigus.
    Force alors la croissance des identifiants.
\end{itemize}

\section{Synthèse}

\begin{itemize}
  \item Systèmes distribués adoptent le modèle de la réplication optimiste pour offrir de meilleures performances, \ie disponibilité et latence, et assurer la résilience du système, \ie accroître la capacité de tolérance aux pannes.
  \item Ce modèle autorise les noeuds à modifier leur copie sans coordination, provoquant ainsi des divergences temporaires.
    Pour résoudre les potentiels conflits et assurer la convergence à terme des copies, systèmes utilisent les \acp{CRDT} en place et lieu des types de données séquentiels.
  \item \acp{CRDT} pour Séquence ont été proposés pour conception d'éditeurs collaboratifs pair-à-pair.
    Deux approches sont utilisées pour concevoir leur mécanismes de résolution de conflits : l'approche basée sur les pierres tombales et l'approche basée sur les identifiants densément ordonnés.
  \item Chacune de ces approches introduit un surcoût croissant, pénalisant leurs performances à terme.
    Plusieurs travaux ont été proposés pour limiter ce surcoût, notamment \cite{letia:hal-01248270, zawirski:hal-01248197} qui présentent un mécanisme de renommage des identifiants pour les \acp{CRDT} pour Séquence basés sur identifiants densément ordonnés.
  \item Mais cette approche requiert un mécanisme de consensus, des renommages concurrents provoquant un nouveau conflit.
    Cette contrainte empêche son utilisation dans les systèmes pair-à-pair ne disposant pas de noeuds suffisamment stables et bien connectés pour exécuter le mécanisme de consensus.
\end{itemize}

\section{Proposition}

\begin{itemize}
  \item Dans ce manuscrit, nous proposons et présentons un nouveau mécanisme de renommage pour \acp{CRDT} pour Séquence, ne nécessitant pas de coordination synchrone entre les noeuds.
  \item Concevons ce mécanisme pour le \ac{CRDT} pour Séquence LogootSplit, mais principe de notre approche est générique.
    Pourrait ainsi l'adapter et proposer un équivalent pour autres \acp{CRDT} pour Séquence, \eg RGASplit.
  \item Présentons et détaillons notre contribution dans le chapitre suivant.
\end{itemize}

\import{chapters/}{rls}
\import{chapters/}{mute}

\NumberThisInToc
\chapter{Conclusions et perspectives}
\minitoc
\section{Résumé des contributions}
\section{Perspectives}

% \begin{itemize}
%   \item Définir stratégie pour déclenchement de l'opération \emph{rename}
%   \item Proposer nouvelles relations \emph{priority} \lepoch
%   \item Utiliser combinaison de CRDT et OT pour concevoir structures de données répliquées complexes (move dans Sequence, DFS...)
% \end{itemize}

\subsection{Définition de relations de priorité pour minimiser les traitements}
\subsection{Redéfinition de la sémantique du renommage en déplacement d'éléments}
\subsection{Définition de types de données répliquées sans conflits plus complexes}

\subsection{Étude comparative des différentes familles de CRDTs}

\begin{itemize}
  \item La spécification récente des Delta-based CRDTs .
    Ce nouveau type de CRDTs se base sur celui des State-based CRDTs.
    Partage donc les mêmes pré-requis :
    \begin{itemize}
      \item États du type de données répliqué forment un sup-demi-treillis
      \item Modifications locales entraînent une inflation de l'état
      \item Possède une fonction de \texttt{merge}, permettant de fusionner deux états S et S', et qui
      \begin{itemize}
        \item Est associative, commutative et idempotente
        \item Retourne S", la \ac{LUB} de S et S' (\ie $\nexists S''' \cdot merge(S, S') < S''' < S''$)
      \end{itemize}
    \end{itemize}
    Et bénéficie de son principal avantage : synchronisation possible entre deux pairs en fusionnant leur états, peu importe le nombre de modifications les séparant.
  \item Spécificité des Delta-based CRDTs est de proposer une synchronisation par différence d'états.
    Plutôt que de diffuser l'entièreté de l'état pour permettre aux autres pairs de se mettre à jour, idée est de seulement transmettre la partie de l'état ayant été mise à jour.
    Correspond à un élément irréductible du sup-demi-treillis.
    Permet ainsi de mettre en place une synchronisation en temps réel de manière efficace.
    Et d'utiliser la synchronisation par fusion d'états complets pour compenser les défaillances du réseau
  \item Ainsi, ce nouveau type de CRDTs semble allier le meilleur des deux mondes :
    \begin{itemize}
      \item Absence de contrainte sur le réseau autre que la livraison à terme
      \item Propagation possible en temps réel des modifications
    \end{itemize}
    Semble donc être une solution universelle :
    \begin{itemize}
      \item Utilisable peu importe la fiabilité réseau à disposition
      \item Empreinte réseau du même ordre de grandeur qu'un Op-based CRDT
      \item Utilisable peu importe la fréquence de synchronisation désirée
    \end{itemize}
    Pose la question de l'intérêt des autres types de CRDTs.
  \item Delta-based CRDT est un State-based CRDT dont on a identifié les éléments irréductibles et qui utilise ces derniers pour la propagation des modifications plutôt que l'état complet.
    Famille des State-based CRDTs semble donc rendue obsolète par celle des Delta-based CRDTs.
    À confirmer.
  \item Les Op-based CRDTs proposent une spécification différente du type répliqué de leur équivalent Delta-based, généralement plus simple.
    À première vue, famille des Op-based CRDTs semble donc avoir la simplicité comme avantage par rapport à celle des Delta-based CRDTs.
    S'agit d'un paramètre difficilement mesurable et auquel on peut objecter si on considère qu'un Op-based CRDT s'accompagne d'une couche livraison de messages, qui cache sa part de complexité.
    Intéressant d'étudier si la spécification différente des Op-based CRDTs présente d'autres avantages par rapport aux Delta-based CRDTs : performances (temps d'intégration des modifications, délai de convergence...), fonctionnalités spécifiques (composition, undo...)
  \item But serait de fournir des guidelines sur la famille de CRDT à adopter en fonction du cas d'utilisation.
\end{itemize}

\subsection{Définition d'opérations supplémentaires pour fonctionnalités liées à l'édition collaborative}

\begin{itemize}
  \item Commentaires
  \item Suggestions
\end{itemize}

\subsection{Conduction d'expériences utilisateurs d'édition collaborative}

\begin{itemize}
  \item Absence d'un dataset réel et réutilisable sur les sessions d'édition collaborative
  \item Généralement, expériences utilisent données d'articles de Wikipédia \mnnote{TODO: Revoir références, mais me semble que c'est celui utilisé pour Logoot, LogootSplit et RGASplit entre autres}.
    Mais ces données correspondent à une exécution séquentielle, \ie aucune édition concurrente ne peut être réalisée avec le système de résolution de conflits de Wikipédia.
    \mnnote{TODO:
      Me semble que Kleppmann a aussi utilisé et mis à disposition ses traces correspondant à la rédaction d'un de ses articles.
      Mais que cet article n'était rédigé que par lui.
      Peu de chances de présence d'éditions concurrentes.
      À retrouver et vérifier.
    }
  \item Inspiré par expériences de Claudia, pourrait mener des sessions d'édition collaborative sur des outils orchestrés pour produire ce dataset
  \item Devrait rendre ce dataset agnostique de l'approche choisie pour la résolution automatique de conflits
  \item Absence de retours sur les collaborations à grande échelle
  \item Comment on collabore lorsque plusieurs centaines d'utilisateur-rices ?
\end{itemize}

\subsection{Comparaison des mécanismes de synchronisation}

Serait intéressant de comparer à d'autres méthodes de synchronisation : mécanisme d'anti-entropie basé sur un Merkle Tree\cite{2007-dynamo, 2015-approximate-hash-based-set-reconciliation, 2017-anti-entropy-without-merkle-trees}, synchronisation par états (state/delta-based \acp{CRDT}).
Dans le cadre des Delta-based \acp{CRDT}, pourrait évaluer un protocole de diffusion épidémique des deltas comme celui proposé par SWIM\cite{swim2002}.

\subsection{Distance entre versions d'un document}

\begin{itemize}
  \item Est-ce que ça a vraiment du sens d'intégrer automatiquement des modifications ayant été généré sur une version du document distante de l'état actuel du document (voir distance de Hamming, Levenstein, String-to-string correction problem (Tichy et al))
  \item Jusqu'à quelle distance est-ce que la fusion automatique a encore du sens ?
  \mnnote{NOTE: Peut connecter ça à la nécessité de conserver un chemin d'une époque à l'autre : si les opérations émises depuis cette époque ont probablement plus d'intérêt pour l'état actuel, couper l'arbre ?}
\end{itemize}

\subsection{Contrôle d'accès}

\begin{itemize}
  \item Pour le moment, n'importe quel utilisateur ayant l'URL du document peut y accéder dans MUTE
  \item Pour des raisons de confidentialité, peut vouloir contrôler quels utilisateurs ont accès à un document
  \item Nécessite l'implémentation de liste de contrôle d'accès
  \item Mais s'agit d'une tâche complexe dans le cadre d'un système distribué
  \item Peut s'inspirer des travaux réalisés au sein de la communautée \acp{CRDT} \cite{2021-access-control-crdts, 2022-dist-access-control-pa} pour cela
\end{itemize}

\subsection{Détection et éviction de pairs malhonnêtes}

\begin{itemize}
  \item À l'heure actuelle, MUTE suppose qu'ensemble des collaborateurs honnêtes
  \item Vulnérable à plusieurs types d'attaques par des adversaires byzantins, tel que l'équivoque
  \item Ce type d'attaque peut provoquer des divergences durables et faire échouer des collaborations
  \item Dans \cite{2018-prunable-authenticated-log, 2021-these-vic}, \citeauthor{2021-these-vic} propose un mécanisme permettant de maintenir des logs authentifiés dans un système distribué
  \item Les logs authentifiés permettent de mettre en lumière les comportements malveillants des adversaires et de borner le nombre d'actions malveillantes qu'ils peuvent effectuer avant d'être évincé
  \item Implémenter ce mécanisme permettrait de rendre compatible MUTE avec des environnements avec adversaires byzantins
  \item Nécessiterait tout de même de faire évoluer le \ac{CRDT} pour résoudre les équivoques détectés
\end{itemize}

\subsection{Vecteur \emph{epoch-based}}

\begin{itemize}
  \item Comme présenté précédemment, nous utilisons plusieurs vecteurs pour représenter des données dans l'application MUTE
  \item Notamment pour le vecteur de version, utilisé pour respecter le modèle de livraison requis par le \ac{CRDT}
  \item Et pour la liste des collaborateurs, utilisé pour offrir des informations nécessaires à la conscience de groupe aux utilisateurs
  \item Ces vecteurs sont maintenus localement par chacun des noeuds et sont échangés de manière périodique
  \item Cependant, la taille de ces vecteurs croit de manière linéaire au nombre de noeuds impliqués dans la collaboration
  \item Les systèmes \ac{P2P} à large échelle sont sujets au \emph{churn}
  \item Dans le cadre d'un tel système, ces structures croissent de manière non-bornée
  \item Ceci pose un problème de performances, notamment d'un point de vue consommation en bande-passante
  \item Cependant, même si on observe un grand nombre de pairs différents dans le cadre d'une collaboration à large échelle
  \item Intuition est qu'une collaboration repose en fait sur un petit noyau de collaborateurs principaux
  \item Et que majorité des collaborateurs se connectent de manière éphèmère
  \item Serait intéressant de pouvoir réduire la taille des vecteurs en oubliant les collaborateurs éphèmères
  \item Dynamo\cite{2007-dynamo} tronque le vecteur de version lorsqu'il dépasse une taille seuil
  \item Conduit alors à une perte d'informations
  \item Pour la liste des collaborateurs, approche peut être adoptée (pas forcément gênant de limiter à 100 la taille de la liste)
  \item Mais pour vecteur de version, conduirait à une relivraison d'opérations déjà observées
  \item Approche donc pas applicable pour cette partie
  \item Autre approche possible est de réutiliser le système d'époque
  \item Idée serait de ACK un vecteur avec un changement d'époque
  \item Et de ne diffuser à partir de là que les différences
  \item Un mécanisme de transformation (une simple soustraction) permettrait d'obtenir le dot dans la nouvelle époque d'une opération concurrente au renommage
  \item Peut facilement mettre en place un mécanisme d'inversion du renommage (une simple addition) pour revenir à une époque précédente
  \item Et ainsi pouvoir circuler librement dans l'arbre des époques et gérer les opérations \emph{rename} concurrentes
  \item Serait intéressant d'étudier si on peut aller plus loin dans le cadre de cette structure de données et notamment rendre commutatives les opérations de renommage concurrentes
\end{itemize}

\subsection{Fusion de versions distantes d'un document collaboratif}

\subsection{Rôles et places des bots dans systèmes collaboratifs}
\begin{itemize}
  \item Stockage du document pour améliorer sa disponibilité
  \item Overleaf en P2P ?
  \item Comment réinsérer des bots dans la collaboration sans en faire des éléments centraux, sans créer des failles de confidentialité, et tout en rendant ces fonctionnalités accessibles ?
\end{itemize}

% \include{assets/conclusion}

\Annex{Algorithmes \textsc{renameId}}
% \include{assets/annex_extension}

\label{app:rename-id}

\begin{algorithm}[!ht]
  \footnotesize
  \begin{algorithmic}
      \Function{renIdLessThanFirstId}{id, newFirstId}
      \If{id < newFirstId}
          \State \Return id
      \Else
          \State pos $\gets$ position(newFirstId)
          \State nId $\gets$ nodeId(newFirstId)
          \State nSeq $\gets$ nodeSeq(newFirstId)
          \State predNewFirstId $\gets$ \new~Id(pos, nId, nSeq, -1)
          \\
          \State \Return concat(predNewFirstId, id)
          \EndIf
      \EndFunction
      \\
      \Function{renIdGreaterThanLastId}{id, newLastId}
          \If{id < newLastId}
              \State \Return concat(newLastId, id)
          \Else
              \State \Return id
          \EndIf
      \EndFunction
  \end{algorithmic}
  \caption{Remaining functions to rename an identifier}
  \label{alg:appendix-rename-id}
\end{algorithm}

\Annex{Algorithmes \textsc{revertRenameId}}

\label{app:revert-rename-id}

\begin{algorithm}[!ht]
  \footnotesize
  \begin{algorithmic}
      \Function{revRenIdLessThanNewFirstId}{id, firstId, newFirstId}
          \State predNewFirstId $\gets$ createIdFromBase(newFirstId, -1)
          \If{isPrefix(predNewFirstId, id)}
              \State tail $\gets$ getTail(id, 1)
              \If{tail < firstId}
                  \State \Return tail
              \Else
                  \State \Comment{$id$ has been inserted causally after the \emph{rename} op}
                  \State offset $\gets$ getLastOffset(firstId)
                  \State predFirstId $\gets$ createIdFromBase(firstId, offset)
                  \State \Return concat(predFirstId, MAX\_TUPLE, tail)
              \EndIf
          \Else
              \State \Return id
          \EndIf
      \EndFunction
      \\
      \Function{revRenIdGreaterThanNewLastId}{id, lastId}
          \If{id < lastId}
              \State \Comment{$id$ has been inserted causally after the \emph{rename} op}
              \State \Return concat(lastId, MIN\_TUPLE, id)
          \ElsIf{isPrefix(newLastId, id)}
              \State tail $\gets$ getTail(id, 1)
              \If{tail < lastId}
                  \State \Comment{$id$ has been inserted causally after the \emph{rename} op}
                  \State \Return concat(lastId, MIN\_TUPLE, tail)
              \ElsIf{tail < newLastId}
                  \State \Return tail
              \Else
                  \State \Comment{$id$ has been inserted causally after the \emph{rename} op}
                  \State \Return id
              \EndIf
          \Else
              \State \Return id
          \EndIf
      \EndFunction
  \end{algorithmic}
  \caption{Remaining functions to revert an identifier renaming}
  \label{alg:appendix-revert-rename-id}
\end{algorithm}

%
%%-------------------------------------------------------------------
%%                         Le glossaire
%%-------------------------------------------------------------------
%\BeginGloWith{Voici un glossaire tout-à-fait fictif,
%              introduit par un texte sur toute la largeur
%              des deux colonnes.}
%\twocolumn
%\PrintGlossary

%-------------------------------------------------------------------
%              L'index (toujours sur deux colonnes)
%-------------------------------------------------------------------
\BeginIndWith{Voici un index}
\PrintIndex

\onecolumn

%-------------------------------------------------------------------
%                       La bibliographie
%-------------------------------------------------------------------

% La bibliographie (comme d'habitude)

%\nocite{*}
%\bibliographystyle{named}

\printbibliography

%-------------------------------------------------------------------
%                          Les résumés
%-------------------------------------------------------------------
% (si le résumé apparaît sur une colonne étroite, avec la
% bibliographie à gauche, c'est sans doute parce que vous avez
% oublié de générer les fichiers d'index et de glossaire...)

\NumberAbstractPages
\begin{ThesisAbstract}
  \begin{FrenchAbstract}
    Afin d'assurer leur haute disponibilité, les systèmes distribués à large échelle se doivent de répliquer leurs données tout en minimisant les coordinations nécessaires entre noeuds.
    Pour concevoir de tels systèmes, la littérature et l'industrie adoptent de plus en plus l'utilisation de types de données répliquées sans conflits (CRDTs).
    Les CRDTs sont des types de données qui offrent des comportements similaires aux types existants, tel l'Ensemble ou la Séquence.
    Ils se distinguent cependant des types traditionnels par leur spécification, qui supporte nativement les modifications concurrentes.
    À cette fin, les CRDTs incorporent un mécanisme de résolution de conflits au sein de leur spécification.

    Afin de résoudre les conflits de manière déterministe, les CRDTs associent généralement des identifiants aux éléments stockés au sein de la structure de données.
    Les identifiants doivent respecter un ensemble de contraintes en fonction du CRDT, telles que l'unicité ou l'appartenance à un ordre dense.
    Ces contraintes empêchent de borner la taille des identifiants.
    La taille des identifiants utilisés croît alors continuellement avec le nombre de modifications effectuées, aggravant le surcoût lié à l'utilisation des CRDTs par rapport aux structures de données traditionnelles.
    Le but de cette thèse est de proposer des solutions pour pallier ce problème.

    Nous présentons dans cette thèse deux contributions visant à répondre à ce problème :
    \begin{enumerate*}[label=(\roman*)]
      \item Un nouveau CRDT pour Séquence, RenamableLogootSplit, qui intègre un mécanisme de renommage à sa spécification.
      Ce mécanisme de renommage permet aux noeuds du système de réattribuer des identifiants de taille minimale aux éléments de la séquence.
      Cependant, cette première version requiert une coordination entre les noeuds pour effectuer un renommage.
      L'évaluation expérimentale montre que le mécanisme de renommage permet de réinitialiser à chaque renommage le surcoût lié à l'utilisation du CRDT.
      \item Une seconde version de RenamableLogootSplit conçue pour une utilisation dans un système distribué.
      Cette nouvelle version permet aux noeuds de déclencher un renommage sans coordination préalable.
      L'évaluation expérimentale montre que cette nouvelle version présente un surcoût temporaire en cas de renommages concurrents, mais que ce surcoût est à terme.
    \end{enumerate*}
    \KeyWords{CRDTs, édition collaborative en temps réel, cohérence à terme, optimisation mémoire, performance}
  \end{FrenchAbstract}
  \begin{EnglishAbstract}
    \KeyWords{CRDTs, real-time collaborative editing, eventual consistency, memory-wise optimisation, performance}
  \end{EnglishAbstract}
\end{ThesisAbstract}


\end{document}



